<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"39a8f26e87f3c7cd6139ba5bcaaa7783c9184264b0c40940de396c4117ab50f3b4b239fc878d1e09cac40d5af888a80e7c488165e883e18d3d735bc209a29bb23a443f3a6ef49cf569d2a2beda3a32beca1a69fcfa98434fd4529d4e7156b1662b7dbf2fb4498dfacba221385be7cdadf45e58abebdd0cf20820f4a369592906427298c2c8c391ff4d3787b20b56094ea75a8ae52f1ed7454bbf6250d67bbfa00770b7b75ea3c72f3cc1c3f0498ee2b30b96d5fae0aba3fd6631594b82c55dd0149fa59001ea5a3e1d3f4766f1cbf933d32110d49ba67c4e88b2c2ed34d0b9da21758baa53bf335ef38bffef59f4177a3f569955be75679348b98d953daffc2c51d3e2a4fa31adf607a6668cb853bc0e3d7d30eca365976006b9997bfed68c30062fd750b073dfd8288a9a448293dc92dbd529956333bd8053bc8c9c8f992e351c176e60646b7f52d5dbadb63d09d808ba8552286e2bf628934d80eacd7a612cf0dfbbec6ed3cc27590694d0916eeefd786737ebcba887d83901b9943b066ae545cb99e8ed71a7a7a373ee1a04d7e2eb976f4a84fe12284330d0b4a6a834552dfc1477ff2d0207e041b36240ba71f03c7524889d275e2793f312f262baf6e225051b393de151970b35d67a74fbaf681c92f28663bdc18c533b90422a580d05d966a80d036443e7091e55660e1c3746f7095272f44c696b3e78ee70bb8edb44678e857453b631732a2fe434fcb259156de52f42516abd7ade067249e63083df9b8f77aa939a864bf902ce8518841f242dc8bdafa1558b37f99ca9ea5fe7790ed14953bb8fed6f67d1dcb15c8bf54cd65c9bc928221e732e39b5dbeb92be325a4a1312eff6e783313c1033c7902d70c5a6a03174fc6eb3558422dc7fbfd5b54bd3dcebdca6a0ea0cd1b64b5427afd09cb253bf1fe09b98f37e1815f2bffae42fa4430ebea1a46582442fb9f7af611f9928f344f501d8e8896377208a648afc0d2c096d1db4494270ea7c9c40fdb7ac20340be67829c087eca7ddc621caca311b6efd395bb16f65ce64280060cbd55fcc09bb58d0bd13b5cdb3fedaae63a20bbbb3038775fcc07a357db97e481cf28bc2b7b5f51502bf4a5ff3e9c02a8e27d553db08b87a62dbec47ddc85d915447cd4a4d80844dc20938ce5a0a2be5586d7b55b631239ee4d33ed498a9748867d55219eddb5e5986de3f685eea0e163a808815742180dc42a6309c3431403319a6ffe367ce43b53020c620a2da5b936b62e8d16e891f84057f92ddbb2c91ed196a31d58ec382bcc0940a21bb934433221168f0ba1581a110571c8bf8c1a3b53c86b803b9947744d97ea3fecb9382b011883486c60ff7e0099dc374f07d847f34ecc52c13dee62cf636ef9b16b239f2db2a566bac23867404b01a5fa83edf14e7470020e95ffefaa42616deb1d48a67fc37f0f34b901b2e44b4e2123f3a2913859a89751bb360c2cf593dc6fa9a0136af7663977e473cd608b2f8cce99e90e86ec5079afd68cc3db0395003bde586cd7e66d079e815f9d6464d7a0aebfad9d9987f4d302eb5b93cb88087fd9be037f55fdd1d8ff5f425598cefbee17aaf91f7e44571ec0b3b31379a0159bed845ecb9a13abe9d81d0e79a24de2276b84adce4a4fa23f95775856cf594f5b0a5424df1f9471f3e9518d86f81377600df6b866853132220036812b467b130f329046732cf55c89c659dc6025fb8ea5cd8bcbee49f027e165fda3a5174f64b060d6bb20535992a5df7ed40a712270b8b940c48417b8e08ef6504b27098609f9dfcb1df6e3ff5567b273e37b4cff8b9f446843ce449fbd13f7607c055fe610aa8240595dcabf300d623fcfe691335165469bc71b2114ef0673eb6cc74a3be02740f423b3478a6fa9070734b58538d343c1bed57e73431c2bd9bec76c841532a21fd426889971ca30e821aa64dab7271e2638760f0d9cb56d387a3364926aba7eb292346a51f816a3fe0e7fbb2d8fd0f2a0309efa7e8ff6df4c209a8818c95fa1bd69ec7eb71791e4fd6ee062cd4bde376afe146d2356b8ed1fce9ef1d071d54170acc93648d1309a0b6e8917eaff5ffec9f574a88969772e4ff04ea27bcebf375f186878ee53a2f7b4dc343e3fec21df36fd829e45ee4d52d974d7e137f5674f9950683ed9c36cc5dc1b1a5bbcbe42e7333bd08bbc14dff12229df1f854a615cbb1379e1b4a15b672801434d3fd14d6aceaa43fb9eca8394c6f92146adb3a6396aa74276d65c7adc1c1720a4aaf1abb2af4adc53ff4e8775979cc6e62ab219541db62ce2788bff2224a03f2ddde8090a0cd37cc0d2c0e501c7a009e41e04b536ecfb71b0dad6ab6bfc7e2d0c73923976eb53c7c7cef604610522e5b7245e8ffbcdeea70a92566ecdf0a023cfcd687269f0457dcb754b2affae699c6c03863b4d4c5371dbb23280ae0df335e5a4a119d58d3bd7e6827037f13b06ce78e24a5ed342484371096d56b17d7640f896cd1c50fd5893414b630716cb251876fa94c564a86c0e8a0ec5d81e3ada5f56c226aa54f2b5f0d29e0d299a74740bf7ba51e1acc646fd62908e6e3910bef55b0372de0ba3b59a582535fa618818a9d7690e1d7b5d40e861b5231c9f72b56578905002f91cf3a5b59739965f13a4055e7c68c84768a60ef5fbc0d1612734268c415f49732273a56040acad201612eefbd39d57fa190071620f2b3ac5d3641fa6c3de3ce82a10d431256ad8f173d827a8c0d30a70668468d87e96f7d8a2f9a78b970918807286bc54188f32adc2d472fe9803b074d7881376d94131f7971a44d204a8955abb029080aa4b7f7388a2d69e8a1207c10facb39658f7bab831d1f79abb0fb9f16ab1fb255776501d7e9f67a20cf5d976961277b02947baba179abd8b25957051571eaaf6e70105fb2c94430ec6c7b93f341c496c097890ca8f411b5c00639b1e352d104609b5b8921fd8f4a7405595c454bd61c29464187171fa0afc13031a2cf328b1629a98e86c82bbd662c14b6d00530d44c4d51211256a535be9cf09c4ce73161b49bef98da7fff8892616b94014d056ed5b6df728f98c2efc0fcec8f7ec89876aafb196e2884ed717bc3be894d060e50a8b14a2bcd1e2bfad17788e1bd64f7f08480dd1fbc6c39bd2b8d229d93d0e6818da985d7e87355de87cbb57a147d764c026d911902cf3726e66473ed0e84f6af5099839b376f9ee942cd62da37227c6b7ef64ad148e00247bc83a32bd94674ad761a9bc13deac9d65cee055189d42722ae2307b4d5abbb06a51910f58ae044613e905b44a4d044712590703f6524c9a2812ab5416361984f35914e226d65d4d618e0ad087115ca010b6b2219bd52395499dd8acb61e926d47cc3db58a53d00fbe61fbd943889fc981ec20186499be92f3abec4752efe107cad0c87d88cdd3e3ca7959366895867f54416fe5e8b2443c0cdfb3985507f49e79adc55105a0224fbcfe2232bd39477d0b9366c7dfe9946019d3c42e13c25ed35f9450aa1f6fe28f0b454e9dd5885cf4af758718af2439ae0c940c7346b7cef11bb7b2ad0e8aeda60297612a684bb45fbff9370aeed70885cbb41072bd44a05b01c07251cb0d3b73ecb1a86b1257ad2205ebae6fcec66bbb9062a6fa8da63a291f891e64b95c6f6355f60f142386cd9adc9b4c13ff9a1cb14936fe0a628d0ef3442d540923ea89bb3a0b63da792e5550435edf44a35f65a26bd17b5894ee0c732be02f0aaa6b1d49cc0140a0c27adc10b88535bfe0f3282c328ca098bd765b09500ea4c579ad018cd2b9121deca0151f43cecc53758656a629f709ed879662cce63c5b31b3e533f97a2ca6c7a45a8740adbbab565562ed01afeec86a4821c32294e0942027eb4f47dd71907d03aea44d2aeb8d86d0615c600a078d25ca13dd0fd045b251c5a3ee8d62991a9dcd8a21cb7b08e72cce67b896f09338f06879eafaf3dcf789817311782f93913382c133c4a1afeb525f98ad49f8af68c508371668673c0da38c48359b08bbc5c6c9f902d8805808c8d1c5f856d0e9f84c12fa65e3ac38767db8d30b79d122dec42739f5e7dee6e0f72ab8c1e6b860baed8a55d576696b899d7e5e5e85265f0bd5a3f91477b7e859081411d032913388fcab1e51734a5743277c3206f9071ddbb3fd37e7f9356b7a5c0d172088c94dc4068a4d9cab21dbc119add7fe81d5d9a1d78579b53bb851ae58b45be3dc7d256b8acf11235c5eba20c23ade669961630931f75edca27d74e20874b579b8098743713df6bceb85629b02f8f35dd180f1cac38bd2b79ff063d6b182f9f5e89152cf9e7124450c1f295891c9a83dd6e465d6d7d9ee96c5fd89aa6162b9231c82a5368a51a02ba2b153a18f30f14ab6e06656b2cf06f011a55de936036e88bb1280c62f216bc72516723aae2def69d04cced07db6ce4c56622d5971437c0c89118de448bd87b59e27550be3293300d5edfce5d14b3d1ce3a249c06d92fdf98ac798b794b318e8e5b5e1d44f069589f1cbd49cdc25492c5d08918aec351f7a1cb287cb06716c62898b26238ae833ae4c1310a2034b0171214ac74b4226164a05f3a0df821845a83901db9f3699a14666868e45c1f0448615ad35497d420935f99a667d5e36a6cbb65d26628251547ded8bda73d6d397184e375393d8e4e566630fafc10b68741b1549eea23d26cc7889e0aad51b127e7c0e92e49a1a80dab3e4a0d67edc7f51c994f1fc4b7c9ca97e8d0c76cf8365f34286a40c006330c34a69ab4660b7fee3db41c1e52e26250657612d5e39f85d266790c1f3341555793e44bd51b5947f2dc8f0bbe2a3a644c1434ce8e64a9d84b7d24b5b5446f7957c473e8e85a0b5ec190f95d7b852ad478fdbafaff6306b6c45a74e96400c217751755af95d873b2102dbe1761808644aaafd23da3b202594531442bdc21016892f88f3fbe70ba94849522a1242a1adf2a9140e46410ad4b0d50f134ab9bf0a990dc3ecff002485052b97b4635e02c1eb3a255eafdc3770635a8d199fef199207aa6c261a59cd1282573f84e82530a2381190e854331e6c0f9cebee4040c60f84228209d7d1f6c7eb859f45f308c3cecc783f774a20ac95e4eabc270fa0a1714f2e2c9f0e600591f919cdba280b4d49e2ee9e6620e99502e9f56ef1691ab5e027dc1d8535d2bff3c90b0a2431a510bd9ca3ca47afae6f4d4e7b652e95f29e71674e846da85fa0f59d871d6e44ae6916cca44a503fe47639e4a95b97c5c655f7e82d5b8a6ca34b70e14eacc6e1f81854097a037b90410dd7fa22d7434bc0edf2f886d2e36346520efbeb7f147204af3b993fb5d65c471d9847e3101dbff668e7a4af7eab2c15b0646953c070a34bf3ede00da3a19c649e6cb052a478c3d60d1bd213f7893169d217f0583b76071da983dd46beebeb29b0963e745ae2b5b5de1278e63648c0a3ab73ddc32ba995d74ff256529395aaa1ce9013372b17ca693c92e312dc4d1d8a6f29fbfb110c85b1a72f9b08cd39e5819df4a3016f2a71332e62743800de5701b54d06e64331768e957a4a8b2e00ff5b5d03c76586afa6a4d591fec18ff7c17d3e5ded40854e9efaa833e252579bf19d02ba1dcd2105bf04d4f70ac2eaa28f1ac06e3c175841bc64debcd5781fa65ccd06505cbd78eab145194721745ffdc1e349ba8d366f876e143864f473d163bf8966383b9b18b51ff3e2481377e8da977ec554e83840018f0c540e12edd2dbfa8c2adca5e32464486cf39f28d756f74ccb770635fdfb834dbb6013c58a7fd6aaeec985d598c6487bbfe1fdc1cbdea547738c5fec93d962ab3cf604b569cb22c2b69d4de8a741f59c6f152260920540b20e0cbd327e3f24a96cf1d284790b989e9814a80d031c4d77fd9eab48125079de9383c07c99de8e12f4035a18fe7b6d0e21d5bb8f4abd61fbc15241a2a15698369902bd8498146781350e4bed69e5ea486aa45b66df14a01601625b3063be00880540348d71544fd232613004c1c2560bb237afa8579e7f0ac5cb26ba3a4acb087e36781487d9e7fca46b09a39bbaf5e5279aa7340bb2cbb4f445ed16921c7f5dffcbe9303fa64def53c5e34004d0d630ca056f8700df482a0cb4f31802c2b829781ef5ff3af6903a5269f991d98fab374c88a6aa9350db01353656abcda175d3c2d59f18f0022286a59cee39eec10f343d93381c5eaa8590d06e009f63ba1e34af15857ddf97cf0dc6131947720f035748910761ea40e10a6a6b8436f3f02f17b99d03336a53b02d2ac24ebcce92583c573c50e62c32178461562e67358083df4f0fa54b05aa4c3a068f1e2581a10f950a298c2e51819e3ad253e1012a7bef588b40adc741d47a8cb5210cc99b4f473461dddf515eb71a2933b6ab0fc08e7e19466456c1ad51a84d6d3b320418c8cd6e233839e7fa54f32c0193bf0d8f0f122d42e42c167d33491f0b01d97e39c5043b3a3b69c2fed08ea2bde3f5141230eaa8fdd6fad1466466dc5b98c71076d32d4ba184db093ae37702e1a437ec1c47951e2afedb485c0110a599d3da08ff840f54c2d75634fa0599aba7505715f37cf02f1c3280560183346e6e14e98f67cd2853b80c2638310a30280849901cc6121e19b4921ac1a92d1f9b9a7e6731af1364bb512e0d275938c831ecf7cae2f820e9cc8ccc857e9512abffe15998f940bc26da34e5d8bdad0bd3262d834601beaeed96993a1fd5d04ef7e0f683f9c5249a48b9129b25bd58e1dbf7f11d9313520d7372b76bed88a96bd1256756cb55b3a1b4e3324a27c4f0fcc350dbf8f19d067990cfcca59da551599bf01113d2f01f3fa2621d06f13e1e053011cb5f3a50b0f2f76e38be130ea3c6875c97a0751250ed031cdfed2104da11f3fb7c36ca66b99c4d1fed5f4a5195d5fecb14a3b9657221e42f4f82400aaf22f97799fd2d09d99781f026a7834619b6220c3b3b55187916c61a39b85572ac256bdca92bbf82cce4e1d549686c743c424b181ef4796e013677f813f60a08afd6af2d10bc5cf6e514e2b21d471b76b05794b85c22c2d26ead441072760325f6f5b6392ebb570c96117e92c2b2a417fb8e2e704d0e8000c51b2acd4cb5016cba37ae19c6d3b971de2c6fd467fd1b555479bec171994084730450fff99f101da57edcbf5514bc165007f744ddd31c168b1da1c5782a13dbd814f2cdfd403383ca2e739c83d7191fefed8c1486da78e78fc1a665c42fefdf3b955b294eec71f7bfd61f85762e01f7efcace0e0061b92e29aae6480752d2b467e8ac178cab5dc2ede6bd2bad7e304767fab875cb25891173beabbdbe9956dec77875d382cab6627a1623eddae717c22278733aaa2e6dde53f221d563a39467f1f83f2447b75375e70745d43c34d9582bdbe1c2bc73066345cfa1c9f2b1f85d278a666aeb39296bb3b249a05bac54eca4452f541522b386e89dbbd4908634b559515e79c3b5d4a2017ee3052c4d93e7a6991e8729bd9ea3d72146078b1f8d55cf49d3875966cf582024238b977a41c73a5aabdbe8d6461da2c0f81c6d564e5496c7026d6c548e0074eda7fcfb1d9a78f4d702176eeffca9977bd546c0d20be6d0aa01b4c7e9ac4df65cee6919085da8771484e63bb0d74c9d7be03f64c7fdff998f4a782428bca3884e2285f1174075f2c9ace7149974587298ba48d3f085be5b39a71e48f64f7b175a23bd0ae43a52d2328321aecc5c8c7aec4e98b80fc617ac96ebdebc3a725294bc902d86e8d3f71e8590f65acaafccf07cfc1b78fff0b1dcb7fc79d8ae9aebc73c362f777ef98fa2902a0469c852bc911f6fcd1994c605b9a8502f0ed53664d01f359d91557f1d2a16fc56205159fd74e67e1a6557236fd15af980243c4aa2ea1ebe9b124c3b029b427477df96762ea61c151676e10bed5337fdcd394579e79dbb6eac17ed81040eb018dd991f4b05206bd2986c0ec4ff7525f6431c20682c833b90a24e195fc8328072d67542993e032e712dddb91251ce33c55df1d11934136db047217a9f46d9a0000d3cef00f87e1c8c9c138f36d5989d9f4f727d478cdf9ffb79a64d011f8ac24e27573b20e97812b2b20957240b820a62f7e8a71afaee23ce8fe37a4c4cb2cdf195e5242fdd00fd75c58fe48f6c4de98cd545d7c125b497ed7dec17757973d503539d09d9831819ef798df94f4f3de8ea7291c361fad4718eb7c2a120e09a44353edc704c1055fab883ead5cbb58bc6a9ac00369c0fe1ab49286191f322c19c7714e77cb40758a85b2c93ff64726952d5460f7466a7a32aab8bd8102a00290d9db567cd9794e669b118644cee0c27dd1dd5b9304456323d65256cc15925301965852e660651480af594f891cfe819b60eebd934b90bb68818798986096fc75c032e98940425a1474da35ee3378eed203c7c32cb2d010541c0b2241d84a30db350f3e30bbcb360cc59b631f0d80c67b57be49970ce52759b6a5f74bdbbf30f4f5e066ff4bed0c1ba57a78d9d310c5731d6891644287613492b4fd0d462ef5b0cd5706d26bdd8d7bac945288b0bb10de8313daef004505fee22ec8a39ce016d5d035fc7ff2d5e95d1d9a808ad2a9886415c300c86c6a7f558fa4332ff093555db7b8cdab3a3fd7ebe21857a376b7c7920b8d0a0502541c38fe769b9550d0cda8d3d50625148fda38ed8e18fabd9fbc5233b4bc5cd27177e91490a42f6406cc46ff1a8bbd7de1dc2a0be2588bff64126e3e9fbbc64a4f1cb48a5a44c0876acfca99dd7f13096a4d588b5c36f0f81f7e1953383961377acca413208c853a9d1ed18deed30e9d1771e411df8ede48c876b28b398db8ea29b1470cc99dbf717d485b649874feb0c2f4e0d161bd99b083c7220415ef982fbe4a8803e173cf0044199cc6cfd85566c4489bbfb5a2307315a056c6f0f8e2145c75fac450454863a727721ec11a0ce068bb90dbc530e4161c208ac9314f0065342186c545e1cdc5b4e3480a29c1b6893fb91e9416580172c62100ce44e9d44cd4da33b66d0720fde889f709d11605b4fa4125fdf5782191adb502ee94d8d6a702fa69a7ae3a28f8f728d69f2e88773ebb7100d264710bee502ad47420a5cccdc4592594d564201d9bb0333f25399187425a0763dbbf13819a6a163754b74e5159764897c556e983f4393843f2322d2aeacb75cb48a54279c54bece3ef757f31a5f3a28f59d53e8af5327771bc467bf151332f8ded0385d9cacfa924fe2256fed4d5b93dd23b56d56474068c852f267b3ae5c1e1410c4f5d0914009b9a194af5e3b23a3e55356c83d392644c4dc82a76610624c9734563f37aaed0b100183b731bcc049c1ab1f050383225d56eb4be4db877941d2f6f10b949a0cca1c1b5c47d1afada70a6c7047a2901ddec4af999c825358f6e47623fa205070b35d0196a47f0dd0de3d6d46eabbe4cda377b81e820fb82e176c0121dd57bee30dbc357fc978fe0c8254da1adc1a41f60c89c54a456927e328fbaa35381c1b951732289b04b7156a5784161fa9f262818907cc99b75311d23b720676b1aa4f3b010439d1904691d1cc12dba9f873818d24d0df72cac4a1e45daaef0c8e1f6cebbd9a9ee86fe3df5574ab6d34240d5d49914afb795cf292a946846c1e4c37fd43bd2513c5c702430c3ff56153e489f9bac8c849fb72b231ab9296e32251e52f499192c647f63cb934a75b13c2b899bcdb5b34535fdf3bf652fcb4161f0a5810fca43451f20d2393ca10202c204e07ef1c3d4737cd6a0752a25a30b95e5b0de046035b99ef13acd3170f07ebab7845fdb3432ae5c80d69a81d0ab39d04548a7c2fe98389b73d7c16e796af8eaec5f6b2265e15c3aaf427b6723d4c90005d916e0d6fd00f7b2ed61a94a239af0f443fa55aceed1724f33f08c5af1247bfa99b8ad0a34ee4c99b6ff99c98b813593bce8847498a1d049b02c2b27bde8b09d367530fa040001ac553a8416335d3a4fc0b63dd6d63395e75a34589bc5a916587fa2856a9c9ba2b03f4f1bcdcfff239c8c5a365322e6291d4a673c730abd1ef69e67a26c98e44ca3c4ae17a22a4f02b36ab984030bd4fe43d5f8cbd9b4552c08dda0e3f5ab871295d89261632ad160d5753d65f7bfc0b3a06a9b39d72ad7a1a86f929602a985f1618cd187adf92769b361620e50943c3a83390ef87786eda5ab26ed80bcfb5ed11276d37da92e4565754c60843b4792f71c28b16e5f76f6d98eff379a94a48953ad7e3001eaecfa23a460569347e4e97a233a5885fa7e9f4857892859530035dc90fe3c0f57f2e54e877ef88f9860280a7e20687371d9fc1eea2110571b3d5fb4f4f4e4da539ab1731cc73220930de7b3e87122eecbffedd3cb53b3d730391a18ed16e32bda726c26a99b40f4e2695dda593d557b3689ba5d24b25aed510028d9ae0b5006750af18f1923f34e51c2f6b629006d2f7c602401ee25dcc37a3fd31838801b5f71229252427891536ef57747ee30821111de52a121ce67cf7ead9af6325988e10a326e7ef0baa162a10e97d242df8223463b924208a5fb770b6d8c0eafaed2dd1d024b21203d3d2ba6c3906c38d835a5a053b03d9773309b0e9bb5d13dc8c6605dd05be8fb9a12844708983c44fe215112f7541ad2d39aeb097323441077e105c5422dec868a1e1799b98c1ec307a5fa1e65764eac1446573896f538e1503c68165f3403a99266f6ea757d4241f390641caa39bf22e5880c40d480632e3b6036265b0dd9154f9af44cc0e829a263dab9dc6aeba09debfc2092b64e2e3e6546dd234c80dbeae449549939059e521bd530ce429f89193cfda85875c2609babb562d2217877b246f336703d1a85e223985ea28d0bb52f586f11aa9480a040cf1cd1364308b50cc23423b5a63f7e39ebb909be87735f4a3c3dc3a27c9f58ae6f2fed7a886a62c11d82f4635277553280dfdef54f90c16bf8cc51eb6b9ae3f7a059dd64460b6e02f06c5373fbc983f79f7649832e5a10ac3e1b2dbd97dbf72cd18bcf8ad9a135725c0c721b01ff27d2735af5683d52ae17248c811040f7122be0d57b62061c31faab069635c212cd63a9d257f97285c84b8043e52088435e671409b938d2260e3a50ee4f472ee6607ddc443d590bb518b66ba47744b0f1fb96d0219f39419e186ca5569a147336be35d29c16266cd608f82a51e24712261284dc5be64a4cfb260fd04105a77b8d18af05f2e6c3e5f67317c526256240165cf4338c9f7e1b0150a5c1110ed6a5b26f37e6d870b437c3626c93e48cdabe02691c536fcf7529ea1971c642be9e679a8e664d9f0276b836f9537263f108f421e18aeaaea55f37bf2bc2eb43c576cd482cbf116d1c798ac8a3a8e11edd3f8396749541a450f43c2635c873e7b1a1e876398174992ca8b3473a3478a8417427968bea59af8e26d6f87ccd0a4493bfcde74b471232c03a413009b9cc3b93333d757a4dc23339578de65f7e574ed2de2612214ea88f2194072ff3a61ddbd144221156bf8032026b9a323ef0e8593edddc963c7012176c265439c408b7409b4e5e49b8264b1c8593f72125a4302b872d75f2d19c83d9f5fa95789fc29d93a5320797c9b6b09d57a8db9dc0e87c00b6406c775a9f6bba5ba425ff8355419a6f53d2912151cca2e23354da61c893484ecc6856a1ef6772406b56c7719da565fb219bbcfc0f20ecbad6ca1c8d2481dd7c7a84e2594166c57f88488be088444bb3ed7a8402f290376467e04e2722c93be500ec1e38fcd46e4955eaf17ffc019f37ef6af21e4cd220c8214d5d0c6d080ebca8317acf1be3446ff708b5d22961c63c3cddeda0ac652bcb2fa7828f514b1aa34b1a394abd8f2d50eb32693212db451db58e4c5836e297cea2d8a8b874fd071401decb21ab991823171c03f1ec573ddaaf0b5d943c0f7b74c88b54222ef1ec77818ffd70297922a1840e4edb147e86d36e4afbe85cece10febf39e7a0a0f8f03335dc1e58c2fa7f5c6a0705b1cdb4c3f75f88f0443bfc5073ca15c418e63a6f676b559b58e8c6dfa455a227b7ad7e4cd2009f3e8c76229a6dc5c269a5af45c81194674062a3425dc74a127d409097dc92f6c3942f013e4967e1c3bde3342fc9bbe1ca1c6eb3742b85e38836e0f76879146ccc5b2df84e4ddd7cdf3ee129ef164aa45f822a783cd192e78d209cacca05afd6ad75a9ef2523f2f0bf07406144d2a8ebb72fffc8e0310f7399aeeec947aafa05f680dc25f268cef36a4dc8fb9086cc13fbbb03ab376234ac0ac4bbf1c6f1a8f2c4b9104663d6f6ffa809a27f8d5c18d8dde1bb35a066eaf4e66f27a632fcf3c12457257b0845bc315f4a227086b3847c6950378c0073d60b562991da62122cd56e555e82a68dfc83951634d05142a6c6eb7ce322eb3214078a78408d3a8e3e4a217249fb7a5c6347126178e7e8442ffdead31488d0680536c89ec77c04ffa2476616e1207e2650ad610b88d6beef67b38ea281ac90e162c745ead25e190f1bd801d9df7a43f6eb27224d22763f4d5da06a13316ee80a2750da701cf3ff2f7b5ec38ee079ed7fdcea3bea313842334a622f5cd9bcb66ed9348893f5acd14c321aa27dbad265512a239afcfda6747de665ffd61b4dd9ceec52f923228e33ec289cc8ef4ecde2ce33aa71eab9f02d3fae15ee753320741dd77fd1c47bf5a0490e406d727719dd8e9fcc7f44e5011b8d5e08d44f7b6da9a88bf77c888ef4ee7ca3b9e72e9beb35cf2ef7e55b9e8dd7a528d4827b8016e4ecfdebedc072da2b1e7f82202bea693a7bf60e241360adcabec5a8f553cfdeea38f287db782825cbd7ded93e867b29d15c86e4c1e1dcd2c85b90b07ea8553cb082568f3333bcf398e91b0d0b07333a772d58e9efd733b3349fd9bd3ce6245c3ced40749374f7cd7176e3ce7972ee31c108066861da169b8be025729514ad281ce8118495b2447295e17d586b0f44687b222da76bcb674055fa32cde6b9af259b2e728499a18f6faaf3736ee4d94b16adb80a66dc01c4f989967e1044befdaaf18591ed39d9652b794058f0163780231bdc73ac9d3a1db9ddfc6211ec36d20bd4705868495b2c03c619904e5041a6a86762dac5741e1f8e92f6c662d0d14597d30856c20a0fea06bd16d1d33ee2b4fbc67aa217d9c673012a228c091ec606d2e160e400ddbf391c6150d8c75603e10d24d166ac0656ede57c80a17609e18c933b49d0aa8bfde1fa1ff04fec7d55a8f80fafe0f6a748a19d4015bf2d8d1f757c4c6d2dfe942d097b25ec8e721177aa97e2cef111734d78265bfb6b9972f7bfd271deb26a152bf989b994ff894dc0ce0a73d3e4cf7308b7e9b7aed0c3b9ff424bd5cb1ad4dbdea5e67248bd2561a878a110faa8b2ae60347375b55afded32e37c0dda4888fa7754d1b50618eefa327b980dc0ca27d9d7749cb7490bc6937e307e46eb8ee41d4716973c1028a68156ead7661f5226f6968af871818818c98e01aa9904c140fbfac6a3295300650908a1ff0b82d9eea6de92d9986acaf00becee6c25d4e16671f218e277a1a935200d989b34e0809203e7b4c14b51a6f1f6583c8a26ba2915dc8b02b2933c672014fb44671ceab742b75a17d8a3976eeae09b2fb255a39d23d218ec82f085cc27f874d51c0174f2cfa832b276729f6e08ae4cc32795bed12ff09519fcc7d97c16edb8ed4eac36bfe3db3f804970faf4ef4f1366b08d4952ab318c2771877b2b4b5e9184444eb03c9ee5e963d2524c37d0338851736a6a4862c8a5209f50b4aff8c49ca8fb35039a8c88673863bf1bb9b52dd7821b62505d0ebf5dca9e66e3e5a0709fa8006ca3c9c2885f7e8ec5286bad85e34be578e81186789153eddf301805c6d160a222c3ba9d6aee86a9361c5b3c6adcaa562ce421f8d8eaf0d10966a5e5ae972b955b788a2f958f77d1c249a060f8c9e80ba4a6fd4845c4d04330ddaaa2a098f052ae739c93042f898a90aca068acf16b3cffc63250243646a8ac9cb93b6f182234b610bbaa8144619b90d8b79e3fc909f7f476236dd9625914d5d4cfb76c9939c2e281746d740e73dcf193abfdd77486d57329800ddad113fc5cba92d91d5e7b3641a6d2e546b54a31c26c48d662c5339586599c50945558ffc136dba8044838a9c79c80f426b385f9b17c60f9ac3a97246bf2f1f88b82bc1cfdc0c02110db4b7cb839b98656b370ab9a559e082f36dd141f4e113045e628fe1ff5767742bd7537787e39bfa1e92eaefcbe4347c57c2b81c777f660a933a523a3216140311fec2acce98033af7efecb0e464f7b6c67b2f169c209957c427c2a4354cdda86a6db1b38f38294e3457a4334bf3898ac6b17c42ec80a6db769ffbb6879698ce8ad31ba0f85e0a200da5abbfe10aa114c4d17ae449b464eaa2e87e39b01a3c9adb15d7a6f65266a6afdf912c46db29b81670ca48fb740daedaa52479aa1b0288e89d2beb79eee0cfc795cf3da9778bdbca3eefc0ceb6bc4f36a84b5e6700516b150bfc2740241cbcb74f448ee02c97d5c39d48db2fec4695e859be3423c1788334562bd6e697f8bbaf015f899f93be57dd5e322b17805d2db5eaa2383c08ae0e3a46488d1ff923e6860ad25e3d00d8d6282505d70b53c2f883f88919a86d007beb38f93ab6c059a6c323699288d5bcb91b0007e27c80e205798d0efef2e962a32c9a21397c858e63369dfe64be70384b25c33ab2b7b2c67bd895ccdb5de01dfb48cb6c0bdd43f9a93fbe3d2bec1d12f93a3ea5b54157795e582f3bdae84bae722ab21c090e44f4c25e9910e938e1cc192b398d9f1ffc328c3d005e64d4d769340f1f4ec81e249c0113235ddcb669864ca57005a843ebc80d031958b27846bd19d7b62326770a49031026a2b3d9bae312ebbae9026bb25854ce220a5ccd9c4a267025de0d38c1093211f13d2bc0693ef1391fcb556a66cde6a76bcb5f8502f2e4445e13b0a66066274be55845cf88fd6f75f10a0955e0ce0797c1fc6c950af71517a6410188b3104da8d5a8b79f8e6b586c1ee5bd536234b9869c39f486bdc143b3d7611af387dcc1c1db5ea6f5f11e8ed0b36d47d3403eb9b043a5750c53da8013dbf1afa15a602a19e04bde0ddb0500e16e8bb137e50cc2b5359fea6b6589a8d6c833ff8a051ce1e81524dcd393d2f4491fc4d027c70ad6b356ccef4a7e5d08a7839bd94422711fc0e8f3c3cf53fb04f2267de8630fc3ef7b66602b4c419497907ca66c4189000925afd91dff047cd8bbbc145905a3e232c948d734b148aedd079bcca0e1c704c8ccd6ef72aec8617fa82289248d7449942b64807ef0bc2b9f3610e9e604a48f81c1a8a18ffb16fb85991a65f1567699440d9b455b18016f18df6739b8b4bbf79dcfa9fcfe8c19c60d06e7952c55c1f9102dafe68a0704af2789cc1bec1625968e374f350e14fc49e89e55e4816291d33fd2e7142cd67dbc88294d50bc500b4dbfdd9d3a9b438fc21894425b605e0e76e2e5c0926823937d3fcba71bba52ed2e208324142d810ac45c75938f5f02ccfb3852c013e7b9a0b9ef4c37c37e5c3220b98108eb9b2bc198dbc12ed4961df727013e740d4266de73fb27028a97d173a6117eb7d3c308fee3d8ebcfa08b7a2c3c72e2ef44190431e0529f850ea85a3292d9f5be0bb69f200fc165d834fd69989d105f560dd11181602d48e8ecf7b6976b38481f062dd8d082e7efc3bc85e63b4b140846d86cf67ac8a465601a6eaa812a073845b02ad73df11f06672012a8a8846cc1cd1a0dc2903e1484ba14b50f9a96ab7d3ac36522758c1d99316e12295cce76c0054a647fb8d8086ed4e2cb17f986827d2322d060d127e092f88b70bf31d3b26473a8b34d2178eeb9584a7a238a3df3d6c059c0ca89ffe3c41bc3e1538968c02493b1a3ddac4a04b12da02aa7667db3fd6fb1c37cde2a26d75b83ea77841e25602992b78d7eacabbe1c3252ca87f48bdc63155bc0b8bb217e3b228a52edeae9f026e6f816558f1365f92bbe932bbe4e3af2d5642ae956bf88892424c5f537853c3cc2a9176a7c49d66d5e4718e066ddf15217dddb5a264a8226c9bee71c4a117db2c8c7c2ef5e0438d842540c028b1340b5113a479a8442182b5fa7a3e19c8c907cc6fd15ef1df43670374f13fc75ea3efca0ccc867d8910642e2584606e962a0908b266988e7b9eb32df58dc8bd6f3b9964e77dd19901c35c0173852c8bf8d6bbbf611e57c9a9a20066f06902ab9b59ada58982242a6d1e6b88dd57bc33dd61c4f1ca8dd471b371bac67de9ee581e8e155daf10e5b95a4e9b01c9c26506f960e4203a643571ec0401037375da1d9db6c20cf66b188732e497ded1cc7003ac7e02f9cee4ba58df129156ffd9f89b0b4f86f8472b34967f18d2feec598f3ebe544336b9802e297f261b407114548fa76028c85e0a6b654e0a38d1a0353c0b87f0d58d6a78c0c7e45494d5452cfe3bf9b07844275c6d6644b35385eac0492c09c200059505abffea9cc604dc8f47a41ea32d6777787ba07200a013eae2056667a395f4c146b7f6b34392cc53a4b6ef28a5f7a1d9f3b160042bcf97f7a6d1342c01de7b359f935014b9a803f024470f64a291ec1c023d3bbddee9dfdc5265a7b2b26c77d34a044408e3d7662741ed27f4d2a75b9a258ff43a06a464051a97f7321a4fb9b5505d2b5a7302219901fd722ff82c37d9062aa3fdfc9a980a8797135f8bf4a80531e3f9cad98ed343f914526eb79d9967a609a39ba9ab0cf204f7aaed886d80fde8d6561adee2cebdd472540010e7e73e73238af678558bcc047eb3c8b01cd914f41e0091e55a92a22417eadad138e99008569a7b8ccb8f9905e317e14565ea6eb00be64c961983b3f79ee0edf335df82441aaa12c34fe2dd841653a9b02ebc0003310ff44e1fd906101a84d95d8a776b98c4210ee30d6d50e2560cbf6ffccd12612cd935633362ecbfde5dbbbca002207d11eacb13a52a7863e317121530ef24a4bb18db2750238a7444437c9f1cbbf634ea7e5a8b59c4bc45b430931691d20ba2c6e2059144d25dca557e317685ac6385e6713bda3401cb2aa3074f03c4ff8d1172e8402f14999f6d52fc290202a2b94ff1071739842ba3e4c338b2ae8f2170e544cc522eb60cf86c1cf37c8f23b5e90b60e6d85daf803edc623c68069907af96638c5109ba2630d3f6ee452c6dd43a5f467288b74bd43bff2df3e04fdf2fb0c8f967dde3d8e514e217177577b10bbac6503fa88d78c13c96532a8f4868de4cc9ec591644b988b2c0018fa419229e99ba4669f40e61b0454166c807778e6fd3776b049bdcd87019a948f8ae4fa6f0c33ebe7b3f5c8b88b447f2f4f0e53d5883f128dc83ae402b8065418384459f9e8566d117d76b7474fe05fd293592b94205c8a19c8e82bec729ef85346c9a68b06c00fd4ad7888532261594ca7c2dc3b73443207156464d424ec36b51dce45a2575497f981915c54e3719f6bb7ccf49cee6c4819aef38143b49f2fe90e90ffe1cecc5e69d039158e00ed93b35f2a0554b1b162ae40d83223d0f94d3a5c105781274a183ca58ef074c4fe44b37f4fb3f8c66aea8df669239f61f5e3af5fab2b8678f821dbd94e2d118448c8cb1ec751d4b88faa00411bd53a682d430c947efb54aeee4627dbe44b8821669c0a89d0690a20a49bda1a02ec2619cc1a20c42403827fc422ef35c8422aeab772d9e825cd5048eb952a14c22ca2695c86d5ada7d01ea3a1b83b79916bc42a30edb84a941ecb376eed0e3c4fa47e0c09c01d41dbb7721c53fda6b7221e7d507b20f46fa69cd53f698692c812ca9b257ba21d29b905517174b72a3d7ecc0b673f8b9b901fc8497fefbbbb94d05dc3ddf90d313e69b74ddecadb1731c807bf886e47d9c372f9a4999c4eb036b4d7a221ee148b3d53cde79382d15466d248b6e2a867d2f5552ff3c93fdc38b6e49370f8e5aea0efd9eb459caf1e841642f852d25b18f7b181f49ab4ac96a949fd177f33d7f518dac72c13d0bce1b4ba61678ab9f03fc105462ece631699ef5fbf32e7e11816fb9b1ba4a36723738296b8945cc5cdbb8bf0033d4bc88904a9d7b55335f111232df45d9b3c512b7c545842b7b30d9350f34e8eae0b4b5701bca3351a04c8a12eb626bd3d626fbfa81d5a8ec03c6607bd9512408102ecd8e898744b89ffe02ec71b7f8848d3358a89031843d6a76004aa8c004c7d7164a29e2b5c9b054d64e7d103adfc6046f8e6a3c813ea8df23798d35e63b58e1afa0daa4811bc4eb028d0d9d4a9972dc812a0410e4d69c96b5e43fa57aadc5edc87b6e41f49d954f01c08b7686bbad52fa86794d67f61a7cf47e189265290d7e6fcb74d82af88abb1ca1b1db3ac427f7ac28039275b255b8998250b4a03b6fa4ad220e8fc931573ae26979f6039144c6fd5d239f0b7ebb387b35c37bd602858a878497b3a2663ae27d115bd5c87b345685d5029005e00d7a4ec9fd3398d3df0d1327e3b613c92ff7f37516d8c3c7ae4c514160b0393886914f66ab9fdb7b0218e40a375367d98d988011fbb93fc6cc55e72fb16ebaa0963893556d573891fd36a6a035be34e3e9897f1ed4e659a76c627f51dc7ebeb0f7ffd32443942b12f9c8a2c570dcbeedb75a30d895850a2b5894bae43aaaff8c502fd4846d2ba766c4821f812a4aa95a50ce3e1fc49848945051be56ce480a13e422757f4dbf3a98c712c69d424129b7c6bce3918c5cc018c6789638cd8f92299be21030a6854c01586c1863bc6da31bf7fbedaa946d7bca070afae13049e9145470eebccc574c6d06b57354dd825e69a370f2f4bbbe05be984291bb4dbe5ce8e08d06a91b69d8b57e6f103c1b87add64a2d6721da1d09cedd2266793571f56401c5cc3b24280e887d91cb0a347f785dec654ccc28125cc81c4612339f44fc6655adabe78ac621819043c21d5ae461b51473f03bed64cc3742d6ad9e2b046560057c387f366ba00061d817db9ea48902063924544b673f4109f41e29e1d3a855c1e9e734c3791918103a08deb5a6750fa338bc08406ec85aa630ee9898d22588d38a87e06d3592a45836eaf93342b46ee85e683e0d3a62e1095e09946800439e2dc10ac100a4d32e594f56f1b43e2704d4bd65b3362594ddb0b4d33846a8cb1edf72214a10621c68633224753c58033a5c50219a6bb24b7b002894b04510a1f5af5e2cbaf3c21bee9e3f4ff1a134e77ad553714222a1cd6d34187bbbfee4a84b77ed86be605876f52ef8fb5d43b0b0040670e89c88b9d1f3bf55f5f82d1c64fd8d32976e236a19d4c697e1fbbd835e15114bcb9232201c6e2874bb49d2c83a9eac8e20757ab4984c52d79457a477bdaecb98df9751d0a571675f39bce9edee78a50d9e10a440927938277c514758244d9507adf4d4aa68db56c0e302dfae268aeabe0d7791cdd225309ae8803fcb834eeffe158bf5221ca280979784f36aadf8a6dc42f2bbc6b472fafb497a2c3042c824b21e60527cbc524277b00869cc70ee279a5f2ec4be2c32da45e7c8ef71259eb2727ae470d46fb8ebbad66e1202381efe0efe7a76b867b612d822331437e53e37c3d79e3ab1aa814f6b3e7c404f6a4f29e9ade5d9295eb465141c9559d8c671e4103fa155f15d70cd6fa3a6119c29c637438c0529de6a83ba772c27ea243ea454b145266bde5fbe6623f905993dbbeea33015f7a93f940447cd75ca6030d3988132c5cf87cdabf4c82c9e2cd2a8fb9400c422c4ad31e40d215b6d58996890924979146fcfd0b2fda1ed5326a1980a1e88da4498f897b6afe32a8a3470412b393aa4ada2a68274eb148315b704c9a3939bbb7aab3a40c8093c8fb426872dd2bbe9862010e232d1b52eafe02500c250206fe2a5dc7fdc60bb8d50eac068557b05c46e28cd256527cd1f4b7ad70fc6f87dcfdc7df2fa79ddc35c4333e78880802c9c8cde4f43fa9145add924afca67d3441fbb51d278f15411894e169acdd3b2e4233b61434f4f052c0db9353429f07cbcb932c901f6b81afa36c80297bfe97b45da67722a1e5489540c2a6cdc26884c6738afbd8a781621e50a0f917663ae8dc3c9b3ca031892b4375b4946eb568f1d43a5c3e0c6433f6f4720555fba0aede4b025186ac630178ca9da2424a95a3c97127b9812769e325cb5fd463c7f1a9ed25661d52e5c3d075902b1397a7c53e3cf3ea24e04f90fd535f9797cfc267000ce3881a3e292b3bff07aef6c26166ae2b7f55814c967b96f86c2fe47ee55ce604c665f87bc31242a1116e9f7ebea3f2cf6f7ba07fcfec0954db2365d8a5cf17d2612057152a6029b55444e398a3f6c50f742ab158fd4ba39c9c97d9e233ef68cb668ca5aa368997c2ebb3d89ad7f1ce13397a2294341d6883390ebecbe4cecb6acc91cfb8b7279c2998da4a86fdda8ac43a1d13bbfa4dcefec7446ea62254095789b3feec8900896dbbcd04461d832d6639bf2397d456446057327a312126eb0de1200519dd16c8da344bb95452ca4bc053a2284f36ed20ffb3653db5a3af5e7b82d6e1f7c4bf914dbbdb50a29f07cc79e221c8ca83b855ad2886c59372dea0ca8b97f14db2f840a91effbd94af55bb0dd9677a1f468a51f35d79c79226ebe7c610c97469aee5afd29e892f176748ff7716e92bff839d832dda1939d1be5f3261b0a644ad2b5e397911101fd2be3a756c928966f26b32cd4a4aadf8b87d41c5d3ddb2877d7949ad8e4a70939cd4675524a8e342e38a6cfa8370fc58fc2ecaf5d5484788533f3b1452f5f3512fd69e715e38faf886d82cb3c18f9a545e3034b70a573a32a14cf5088da19892a7331d30ac315854c72abf7d6c3dd742d5d6c7314c50177c7164355d0c73bb7693cc5e7bfda8b39e35cbaab376026c439c6596b385441a12f64b8cc4c02133aac378b3b2f6aeb3827df8334b8fc9b2d8282e81b729896a57971a43b173df9f9b87bdf79c3af4026926209b6ede20138a3b0fbe1a3c745970598f9a9e3338256b90d8cdb9e23356640685605dd1f155ee95a9573b88ad9d9c22d3276dd6fcc1059b39969946415787292b4680f0399db65f03aa1389623d6fce26374270f545ff65bab30f97db0e9504832de0c10dc819f931e558d0d23472141cb95a6b38813a0a471296b32e6ec7e24c99b7ec8dae7d30a03f602d2846a921d37e9316260df88ef1e447bcf719b034b67a93d60fbd12261e7cab0cd48a444ac6dc7ac8c0fbe6c5036d01f8c93d0ce927be2258c8ae223fe3534652ea50b71804f988a2e8dba549f4d9169d0b38adbd0072920985d61f533239ec94c288d32754540dca2acd1d3c0ab6a7bc3981453f08349ed5add39a191887feaff42e1a470e261998b8f9c1988e3a2f04a51c1f8d8e8e098977f73f9f5139b2cdd2334c4bc3a0095d6764fd6d9dfd3c89f251a63537364549932e1ab977d8d996441b8ea4ae1c60fcd0a34d157439a25070495d3e9b61ccabe3ba32ffb71cfe2db1fe71282ffa968782e8fe1e57e9f859b6f5ca6f14ea4accce5d","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
