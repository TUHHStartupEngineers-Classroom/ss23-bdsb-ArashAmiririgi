<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"9b0844fc4ae848e4c8bda735c5df77554742c05a67493138a1da7197df1909e60f9985b67c9c9295f9ee9b474960f78ce25926ec2256cec494eeb7f5b21ecd3a6c08b724c879f760169e659fe314a524d891333dc5bf5dc15baac3ae8dbf2c795fcd372d4b425079f7cc56207558725fe405828798e21a75b66d04b65a8dfcaf7874e69cebdaf4377eab7e5db50250acaf49acb0698a786bc2e0da32cf264d8c2f23baa40e8f6791eef722700b1b0b59dc9e58ce6568d26e59081412d1fb98fb1606337bdf349d2e7a1b6e64eb3068334249d72f7d947be2cbcbd8738d4c8fcc73eeb7b12d270dccc193aa48f8a8b27fec8f653cc3542a6a5bfeadcf81907ac8b8902fb62e1cbb6ddb3b98286eacb0e1829146bc347502602b04b725dcc1e1e0d9a26e704c4ad71aadb40eaa53b309f132afc983569aff38503c7b1fb2b098dc624e5a7da34ec75e08b8b933c54260b6e7a2da1b11807269e16569b1d1fd624e72c4829fb844d40eb09bf89f0450ba75260149df0278167638c5873fe05ee673a1d9ca59acc075335bd64eb58c067fce8133795b6886a25ae0a622a50a3ff7e693efe7eeaeb12125f5ad911780ff545f60a64c41a00fb30c610d9ccf04493a766418ea4d2faa9b2345fe0e9b9b7a8ebc90726174d5217f0711729053005b5cad4b1936545074b04c59c160e57236cbdef62bccb327c262379424742c9dbce86919adc72af6842ddd93b70f1f58d6d118521c5d6e8cc85305aa1419869fc9e3f543ef9812edf0eb2dcf7d7142119dd584ec714d246d483b950b042ba327cab0f92d7907cd750f0c2b45061cc21aca5e529c8db675e84db31600021a67b5c7b6bccf089da801b978ac7b3423669330638f296f22c5cfa9c0d97436b80546e43351b2cf572ec4ebc77a77429f43ed1acc019226d397d04be1a65d05f29d2976f99244fa2aadabb09ec109a41ca236b88756f54f4f7b275d0331f64b5274e0337883fc91d8632f47f4e5bb6a9b0541374363f1a2f41871cf5f85d5caed80cd1310cf69a3300252fb12a169ee10b00ba237d56c15caffde660cee08e5e35746dfdc818cf8e2cd11f9ea555dab1bc1d0fc4340861aac31f864a95bd96d770dfc82286466d012bd963ba37eaf4513a93a5423be06b370665706adf06f0c69934d7f6ba2555a82c680d5629b2d8b29a0e017ff161309374732e44c3e01f899b19c5cbc58422ad02814eda6b497012dddfb24e6a5b0ad1dae3d6186878f5acf7b74d7c1180606c5dc000be59bfca0cf4bde0e5cac6af858a6fafee73085a26c49ae28b1af2b573cd578b382cacb8d7bd1789346ca7feeed9ea9597bae168e3b2d06c9819bbfb6bb3fe090cff327c855d59898dd395f25a2dfeb4ab42cecbad30b98cc726f4bcbefaa1ef474b37f08fb60170ae8c1f8b93972de6848f8612140090f285258e437e0c7d59813166c2c0ef3ce6d05330e2844a6992d81e6d70a5c357c309c6d35833144035c0ebd956cc72c3d361d4413e5ba90e97df2903d2e53073850f8fd53fff4aa94cba73e2dfb0e8f6c4b0a9f2ad1c5bbc030799db829261912363ede01332bbfd24b4fac7593a97ba2bafce12e4230d370dfd14db444bf2d7aa4e4261bec017716f29395cd951b6b5b30a850ff9c655fa55aacca8d8793c8bfa43fbc91fdaa77a5c8b9f406e922e14083c58fa4c897c3aed3ed9f21c3b5c21e7a427701f8ffe85f24723afe45bc4892fe03f332cd51f97000cdab5e44666829ae92f18e74ef0ee2e327d43a3a46c2fb9d8df1fc645cb02765472a0f334a345b4a51ff7757117fe182c4dd4a753735be6511d53b1e630f10e1164effee5875c061a0ac1d696bf45561591524a2b6b96b252f42ea040e15e113ff5b55ce44f0ad9651f09feacf1f6b54b8fe4b1ac8d8a80c3f25270f702d32133db26a13e48dcdd7477278bd60558bc9dbd1896c4b26d38aaade778a06ac41f48729038369413064ec84cc12ade33eb07a3569421f05dd168e51561058ae7e02588b2a3cac07bf8ea4bee3c8cd49ee96386730bdb6b3fb254ff607a5df10463f6d3a6f03e6d524f4a146e951e8c8e4999d83a9244ff6546b9abc45332fddf7671e7915f9aa18aceb8d111d8779675cff79ae380347189fa41094e2140cabbc6ae50c00d0f3dbf6b7685b0c7fb55e30218f60cfe31a892d44ffb9d533a3113f4483e5c85febc894282c9570b1f29ceea5a75dd4b2ebf11346a3d8a38af342cdbcb2234516bd3b9531e0fa7dfae308f243e5019c44ddc4fc0ba0cb9785449999c9fa786fe40ea44a2afa24118d9311b6cd5bb6e6f76c9bbac893dc7a212f79229d5c4440d22ec5f76fb9a0bb1819cdb800982fb95d49b871fcdc2c263736bdbe2c39bdba6457de7b9e85128f9a48ba97d4a88000e013b581cc0490be6af1cdb03b7fc9af0789d2c7b3e05c444ed7229f99794d2e09b7173eb1462b6b3b27ec275e1824206fad2552c4226faf868047c53de292d19ba0f00337fcac14e8c21e7c8b48df74df99df42b088aaeebba39388c4afb092f9f6d3125411c434e786f83ab7f6e7639ed85826ef6d70ad74d1a0e684dd01c02677f17c427d8eae01e1a8c9ef33a4e1273250c45fcae3433ebe0269d8962e3564fad078f552367bc91d8bf55762cd67d6e3fc2042f4ba63b002f20f3066a6b478be5bf6d85670fc897a05385deb39dddabe5aa2f3b786907f91224009b77fcd2a57b4d3ccf79172fa97634cece3dcc4f7d74abb737f1dd7f9c8d92e7e2d0cde30e97734a8ba5455d074bdd85891bdc9fef2f6458e25ce9b0894e6e529ea61541f68a43ec5b58b037e10394336e768ab97cd1e1eccff7e20e09bf19381d97a30c95875ea3432412b8657eea2ca687acd66ddaceedfb4af792394eb4834d8e04749a0fc4a80513be6fc5c42a82fa3f0b7f9f53e85e4375474fb36f7e45dd2e3e965867d4c66e854be6743d53cd39b9f67bb33d25aa21ff7e47bfeada673e9f5765d6b6a64be68766a7eb5283d781d49cf3d9a0b3b2c25e3959443790a4db819aad8083890c9addbd565a776373e887e8acdfa55ffef2045817049e404b427755afa14eac9ed693ca528397cdd2ba4b9ad8f37b599e8de1088f5fbf1cfa050931f561c1987dfd3dc9e526b26ebcfd55422e83a6d14c7e1d80eda73e1727fffccff4e2c02d4563c6b20712f9857f631fd7f8f0d759ff10e952d99220e6481a5d32aff35a852691474bb3abbfc686909e78ccd17074a4193e3d47921cf937cdd61e26aedc47f960a8ed292b27bce5727d408f812c7481b694c03850261cdc65a79644fe1f8857ec9fba6e866997fd1c65986360ca8be3b640bb08c544635095ac3620239e4dbccd229c76f6e129399c0c5573b948ab775a7d4ade11c41586a9859babba954962ee2d7587ac5534131bd6bf300683c0cf9578bcca83eeda952d52c2376a5df45d1ac0b614049e7fa9759ba884699f30dd4e036768b4e5862731030c4a70550acc7ba8f9383e814b932c4f29cc13c93c857db3b722612ba41ca46f3c344359af32f1f136e73d891d487b73460ded602a7e05a28b45f269946c261686b48971d09264494957da80c5ebf1870ad46c20fc0acfcf7a543a72865f33d512e6a80f0240cd0ff1eb94ba74296f3c3e1baff8243bd84f3da7602cd7580b61c40b8dfadefc64aac79d26d26f520944af9e575a0b97232f957844229d7b3938733330b6910e405c17b0a460f5361b0bf4165ca7c58df51174f89ba54605a95045f06c054aaa0c82825ac2d5fb41b719b87e5542cb00bc934a3c1ce725e2f55b3365fae070242c11261177016e747bf6a7411a3ceb399c83f295cf58127cedd6cccee76416f0b2ebd40789da0c3859b5909f10b1f2425306516065e4aa416c727ad8445351e1c5cf3d1f7d095958c7e2c738c80cf0ca3c2103784a9c6cb11ca9196224cdf8fb4ddd6f1ee5fefd33c56d39b1d576875cb907588b985c7c392475a37fa5f255c41a43348265354abbd7f49b70f3a53eabff34c04c5921f506ec4703e569f7ec7ddc21af1e2c00ba7ccc00d5df965c324177e502981a6bce18b4439aaf311c3a4314deadb4d4a5c010a76bea9227d647200420c0701d1d272875fa6ecb5dbe25b1110fbd8ec905e4a0a345190dcb036aa600bbe2ff0c4492a003c19acd8b2491d7b407af2b217febea09bb67d6168739d00ca548a74193a2b85d051e7cf9daa3fb35359d3e868aa36c6b2ba2e293641fcd09842bd2915c00b35d4687f0843da607ef9859d5fed3267be5965066f0e730f544f5bd4e58957f2ba68077456b9f9c9f6a7935ffcd0828e2bc4ba5892dad5f74be9794a2f07473a11402b0144ac0a62129a815d46f173bbc26d8c84027b3fd3a3ef5d6f93705a4c90b7cabb8d33b4c98810224f2047a6412f20d3dd3d28007b16414fba5747bd2a9637600575f77f9730a3cb205c56bb8a3b835da60c6771f27de236669091031ea6378502417e8e07509fe5af6aad63b1d899beebbcf529e21d04505cab5de6e9be631cf5f03f1f478b0f890f7a828923399358d8d76a22c5d1e55e18e009b4f2b0ad1475efdb35ea1e32bad489cb4f395ca83ffdd783e7997402c95e02eae25b3aeed74bc953778c9752b2c0b8b2d008995d592e4d6d7378b73a8d2becf8f08655927b2d98ce2b0175f9e28bca04df6ed4d231d3beaa026c4a87fa46bb5616027cdae21c9ab1a0925f98929a5c299865e16548208012b0513859959ebf490242b3a9703e7a59e0b3791d172894fa5ccd6b78c1ff499742c78f5967eb8967fa1668e00b931d49483af1751618615cf78b11e9a09f3a4feb5a629283dbdddc61fce0ad74805290751872066ac5c87ae3625bc2aedea537481f849d39642ffb50a8d10db8843da69f09c085cc80e3b59edf7ded04e74c6d605c5345e1cd05da7a225e6f7903ef7f9e929bbf32718410d1982553ccfb0d0cedb4051e7ec22fc8802e92f1993d812074d27514e5466936ef8a8bf93e7fb57dab0ddafe71ba7330e897594894b7eddbe2a36974ad47c93cb93a681cc002d5cd4d052959604d70723232d9f38b93b732937fa130e589343403ddad883c8851889f1790a8d865911de0f3c8fc91e86baf77f6a09ac96f357fbbd81cccb26e55a9a95fb1d0d68200772357187f1540fab3006ce7b38eef63e8f6fcd3ab7cbce3e32262c11476a0f1077c629729fb79bed31d9903496308f2f47126d3dc7338d139134cb60091cf0aa02a5c2915dbc49139cee129aba1dc11f9a5d305f00d905cca5b616e26eb8786fc97dfaf31c025d2de509657848e58f3c2a586240459b57a0d1bc8007ff15ae91df0e8511bd6836d2e8d30a06c7b0bed1b9a46a8cd8a5ede80653977c5c2d422a203ccb8d9620497f3689bbeb406fd10a1219075104d4ebdd062268fde7c137b70aab007abab7edc878c507ec59f51e2b82af800ec292a2595917da7fe471d71e28e0784f5508f9a52d7264601727bd87a6c4336779821ec7b047bb0481fcb02b772a858e617d5e7feaf5034545bca75c486194394e8c6126362d2d42262a2b2bb1fcbf675e3efa002817767426a02b50cee5f80d2561e532fd58b5a8b8bf540ad2add8a28d9de42daaf8f95216223d3c0ee947e18fc13e7176b51bbb32e6476927e445794ae6a9340a90a6a88a8dd2447b287222f23bee313d7181b6e2af9acbe4c47a15602a2d7c7a1020803f406098f69407f52086d41f87faeaf6a6cc8c6b62b7405b824e26bc912544a416b81865c53ec62e7bc2e35ac7a35545fae8cc874a5f9204251d99b84a3a439b8c9ff6e8579809285d83a2b8ecab0de32f28351b697ccd1708a0992e65bb9b9317853092d8a9ec070ca4030227b53b0fb4953dc8d9096121d19a0db13c382f21aa0e1110b07485f01707382470e821c0c8e2b936b1cba3c34f3169afdb1fb3003bc86935fc1e28fa383bd7e7f24d5b6a6797d445e98f5229f62a46909f578c0d227deca8b8e8fb993ee09a4af62ddd01d568cfc48dd569a9231cd8583843c2d3b290ebc1a5fdf225ceadd63d0e542386bf7ffc1d42bd9ca5918bededa8922f78c93ae985715dadc337c748b31147571f12e599575a42e2c2899c7a08aa0f05f0957f2799031ae1ba96b93c425124e21528a03cdf4ec40631ea257f57123ad3d3dc22ec875f5e951b841f0879feb9ac8136dccf117cb8c57266d6b77941053d45b33f7e89871a411d94e2e91d9fa6d88dee499a3f4d876086a648a0c277f2b32e25eead8c531cacde6ccb5c41e4abe0be74ddc38b11573f15f054d1abc710d24581bbe1258b5af150994373cd70de1bd61993e370724f89cdcb434132f37735cae7ca5926f992a4d3cb5dfd124634fc1f1c005780a037c2cafc7e02a94332bb6fe4d62eccbc7092f60532aba67cfaaf8cb92b4130e3776a47af0c11ca02e699e6488ea90479cea5062b7e76aa2befc7bce0fd5ae09a323c1e801fce2892e970b64d5a9cdc00ef5112f794f2d4b67fab06bdf3ee0943e8a77c6af57753ea4c4051814d9e2b87abaa84a47a3facb39694dbc300779b25a43a58a07fa1ab5eaed11282d018c61db4844d777838de8d3e561561dcf5ee981d82624293c8ea25fd7f02d8693ec9b53a1df0ee062720f3d78b71f38ea929b667291e6d34d7d671fd27a21dad3d46e928debca623ee979cd554c0e9bfc3a49badc18a69a3f519b8a50747a3d85345759b4046e54dc0ca6055583158248af5b7efef8387f751b5588602a8b12ab38aaecdb9431aebdfa2c104c41332b4ba271a29931319dba9a5e43078fe5898323c8ba756f4d466240d2b5f9f9c96c05504185f1118dc1c827815ef2448cb2d3e1b0447433ea0238437bb881096beabad8357aedce9a8906d2470d3df55ab46b847140174a09dd9a2aa091fca4100bfe99d5abd862d9f4b5ceac0c8e61aa6ba44e92cb604e9801a6cfcc52900d02626f1ab6c3c61c41fa5f5269870c3ea7d3bbda25cdfa5817cf3084525ac6bd0e0834feac87cc13c063ca62d391f84eb16a73c0cbc3bac2ec9721461db9b9c6e83c1806ed64a22d793c55fcedbcd7a01c5295a47ac3b16af3e4226e246d209d29e6106a2bce275331113e6e9f0c8a0df41e4a771caf2f129d16f8059dc3136fec75acfa583d6882d56a254eafeb72f3966a8f634eac33268910c87b89b4bc2e33b24359171e81ed37962a39475228b248f7a74b2f2cade832294c42f9f2c6b70def255584f755f3d05cf8b29aaf54fec61948de4d44c8314a0174085a38f8d4dca3441342ccaf1fc2240f32cee1f2bde20af2fcab895630fd85a41a418d23a010b57977465e670e628c2cc696516b151c2b6c83de0427823c260346e8af989f091090fc098ddb15941b91e08166d4b6d9ef554b7ec36e59f94532c5c2249338c23b6f855c37fb6551b9d242fd2503c9e690cfa615f247d20a5c2c5a8802ac3bc690bdaa80729325e406c1f0c84e5af728e1b3a3f6f15c358b470f50d7ffe6c7aab7ebb28a7f120612ef23a4d7b41437d4499ec3d06ee7c8c2f8d1f6c1dc01d14ac72894731f65842f2deaf5bb9e5fdf177f904ad52e898e532e89d11481b363940131fe46f8205b2275b58a87e75b3a9adfd71eca40d9ab661043f3b060b896c714039d6e631dfed5f46921940d32a5e23bedfddb71a5b5e1f7f5d667c0940bd184914418df6bcf98d9807b04fb16d4af8444f002b419ca96fafc046fe2220143a710e4dbe777798fe02630536e2494849bc33782b0888109dcd9a59ab82da2f39142d2794c11aeceefe9c7af2a6a0a648e87a6d4e9570ae49eb897efb03dcf6197b97d62505404e2d6d01ebd48496e991aad1516808fac32bbe32aefbeb09546a4cecbaca2b713716afab47d751e97201bc9fadaf9b3865b914b9c3edd36906a290fbe20eae3de40fdc1edc2e6725883c62b430defb91a6ef71e9a08bad23ccea340ff1b811d0e9fe8a10d29aec8b3545883ee03020e14472f66c1d7fdc248811da13068ae4c0c71ad45231dba2b4a5f7fab935c842f3673c600bf0df88099c9d0466869be2cd6bb468902a3f7ede3acf0c5be628e4479f8e49feff146c2ba8f67bc20e89b89cbad3cfd0989a2638efe19dbbd1fddde4183c8cf46ad243b3c6dfdc8cbb5f70499b5365754518dd7fc28a17d423390559ea7dabd4faa234b1b3fe661a73a870f6668d609c493a453f82d319ed1c01d2c7a5ab58bf91adbc9419e34f21587c1e7f0ba4571b961e6f43babd71e661f1a27c2b567535a85eb2113b86903d109e6ac2470d494fa79c3171d493321a3df06baf4faa783eed2accff032ae6886b6437dc9eeea78c117a3dcc286807f4a062b8ce7c3433f918bf44fb330e9502d4a649d3f4469817721d8a8b37053863eb3ab553ce96a70f1a397b24d34baae4685a8967b62e0f4d667f98ffe60fc37f2b71b81ebbe1969fe591f0d237d797bf629afc497d71850b1a071e9d5093b88dfebf9d99d68b5dd2d4d7dfcb757b2bcf2b92a6d10603813905db31e3f805279b4936aeda5da2e511ad6d74bb0b62b9c89a830c284f0f568dc7337838301cf34c3149f9b01176443242b1541d268388cc85476f3d1af3a36d1188ade7885d5f353c2c2173c33018f31868fea20dd4d0c62bfb75648726ca8fbb55afe4ddbda54803fa65a8d4759a1c741d755dc8f4f3ebeaa0f9543646011e632e3fab8377e1d1dc94b66278d6ea61743a0bbf02cfc3d4b1bf8077b1f83a60c25486a9160417bf1b45d1a746d464fdbe6b9b330aace2f1a028db34875627c70d78a37fddaf7e0642095879b1a5ee634252d4b66a3e40e41db02a87bd1d13424ca8e4be0eb1bffc3a2a78ffb41510b83e1fd5de52154ddc406ada5d300bfdd8b192a92de50662f02e4c2f63c1ca7e3f6d5359b504857895daf2b17d705fc0a3a22433e9ce8a387f925fa7cf9fe81f274bde596a87e9230b6e52a34c4b83c1d61d26f642f8778d0d96cf9d46189d93624f254a63a56974fbe0dde02c18708c59ae51152faf25e02352ba971d616155426de50dc59f0ac570dbd0b6069b240121bbc766e1b832a1384b83ba93d9ec338a0d38183cc2904fa30a2e7288d2ea56b7594a2accb92cb25c30f6e3e0dea62f35c3d0704d1a249b821ad258bc959200e3609613b568fa9920299dc3ad7b21315a17af7646eb984d9225ada602a31eff7451366d63ad0cad1ace37835087c8cda8a10fe50401e620e051b5dca008564a736501e448f51700ee4075d631800fcf1fb96f8f04128c7ba9cca5d47803985391413e36f0254896f5f7aa85dbcea6cb3575d196800b547b264b8bfd35b27ebd8afcff90f38ef641f9fb444e14c14be1a549e4a10b220a147dab506ac111e460111dda8e6bd076e5b49cf7970f41c1727f87defc1fe0a7184b89c61640e7b4bfc12e9d13ab86ea393994e3c0a15f96ba2d63f79a8d71bdae9773df1488c37b32b5ada05d54b40041578f24e3ea36eedaa887cf93da5d8462f9ed95ab60be53090287ec6ac178237595fe61a7f2e2c04163da2b8b805f01ee5b506710274fecd55cd6265ba781fe14768f5f40259f94189d6e48490f192bf0a9de9b0bf85c3388fe409f38cb6477459c2ad4a4ca65f1129aa744ea974635657cd1312eedb8551bbbc5d6e5894a623f01a530b51e8e4173f07cbc364ee1f6d2c5528e8a74c503bd8620b53e5336c813256eb63dcf9f68bf26d87091e828884287ece7781ebd7cbd03054eb9b04c3988cfd1d43982ce825dd79cb2695542cbf12fd28cba41ca1412b0997bc2bcd29cc608e087aacc7674dc412b7a84dedb736bf59fe516a2631bc1e2575b409e81ae261b6cb08b3e4656fad804874ec3a6c20631eb8b22c9f198fc133c53539bec078fc122e200df68d57afbeea1b5c71962302e8eb5f935eb44f215f08a0404dfe88800def8f27a2ff10ccd9148e24d68273819c8d9fdec83f3de71eeb394a643bdf18b558931233bf6f2597907fc69a35ce6d226c2624ccde8bf44c83fde985438b101a8907b8f42c329c46dbaaa438670b272359155f6009b86d2052fc8b594dc3579be40dcc5c2a1e96657999364ec37b67a920cbaf388256a923f43ac0d9b893a5733d5fa0369403c6d42fe7dcee387b872622f2be494d9d4846f6634b67c239c325acce06a1674fdc102a6386acb6be073c4a0ac889f3e87035f5accac2aab5f2d1f1deed0fe63269db16581a6d2a4a040b1adbd11106a38227171fd752441ff412973b488e44564024d268df66293aa2754395ac0194c3b7539952055120e78e3116450b54e970e4a2c1b114a8b2d46258dd76a6fb021aad3d41ec70dca1e8353e0feb979212659c55b42a21a823a328a173c74ae05ee111ffa423f42a506f29ae426e186f05ac91ce114a455cc275b24f13ea216627590d34f2a424bf21876335d770a0e05de1a53da346c427bd9be40e2dc5ad7da0b3d559fc653ed6ca10ae1a119ee3347fb24a153ee1c156912a1a86bf424573624fd6832f282fdba9d3f442c7d5bf0ff4db2f097ceac421de638569eb6b4d496f01213e8accf9a9addbcebc02528363473bffb82a419c9271ea22c6ea2b6889c9e629595e15d8c45e1cf60e2732541cfbaa1d53f957582504445606fc3742cad68eba0cca4ce59304309d481d193545666aeebd2c98e09cd4b08d7e7457cb6b6bcf11edeab37e2328326a44256a0d2d4f3f9a612fca1df20e1473f4024851e1fa81b650c61a47b4d1d46ec651e570a8014c69601d70736fbfc8969d31b4186169c7f22828532691da58838ad6b2025e9fc23f88142f9c5d577a19da16e9b3d1308a14776e8c33c6df9359b42e5517983cc24c066e4122b8e18457bdd140721b3a87bfbab56eff3bdada0929629896a951c0af0f75c0f8935975a43491af6e05ea19ba6e52e56c17fcc266c2e32608955405d5de654689871b7cde905563b99dd334a6f71d24ca5e2d697f445f8941a9601be367530ad5e19e105b07631c81c74975a30e547e56102045a4b195eb3a101919eea0e974fc6a0e3928d2c191a43320dd325882c8ae7203d19b2e87608152d550de3fdda4926382466094aa9284d5974c3ffe6d8e97c5b52564e4769cf816229cdd4d17edb201e3b79d979230074df97d13bb9a29a4babf6538aae0abcb2239bc0dbead5bf2d46f9a11e8f4539262c808f60005dafa35e603619aea6a41b37e8110f5273a4e41f7a7a0fdb22cf45f14fb9aefa46f0a0dbd8dd49defa6e285b51c59c9fd21b63cfcfd60d589800990f7953b5dd34cc464163403c3b9eebb6dae861acbee259adb87e8ea700a4f75de8f6c249d56fefe04d7e413f72819babcd7b1b869fa97405661e800029d52c68ce3a8cc57ff6a4f886b06313f518f0fc6931e7c614a943451bcb706816d3ea7ae006e7f01f64c7e5def615849fe92ef3fd8af97a650ef804c63e3eb1e14aa11e0980cf4052c907561da5819431c635bbc5602e2f469150ba825528506dbfc5fc1b8f948044e02c1dd4c652a9a5540afeaff844c1f701326b31a93fb0551c0a518b720193009166d290ec9182b9ea10f86e3629290b50005a52872893e696aa17cdb0195bab1dea7e6e6a6ac69ab93b5d0d2ab23af05fd1c4264a4c217bff28e25da578115989805a43af1b5153f4e86a524a4af785bb285abe2ac79b5b5b322fc892df35f1bbbb81c398af65ca9c0552f073bbfcae64607b4a7c834a2792ad42500d76a9bd4f07bb4b9c41fda0d7cb8e593d8a0296117e74c58a6cc98f00905fcccc6621928c000248c81e625746270fc6b7bf79d522cc57256b33a9e72aa0b2a7ab07b191585a56e065294adbfbd489b5670becf49030c962f35c88ca6da4d3f0058228bed968fc0022546b19252cd69ed8c68f49b4a35244b4a971ee4b3d426a0bdf2c533b9a7af9e5620eade594a7a12344a329f0f759fc925b02cadce2563f2302d44aebdf95e1aebdaf202cbaf11d76ce673bc9586f62f6f55ed62e21e2e88c8eab5eb604de7164dc52474aaacd30bbc115777377bff3e4f8ec568aa22c6e076fc91c9d1b93a442c3fa0aa6554fbb0af9a8ed9b1ba67022693e311f9d0d6adafc94ac5240d088c1528644e873c3c5fdd17166a123ae183e14dba0c63ff2fcd9593d915c28652e4aa3c581d122f28325d5b1381658f0ff5300217ab9e1616d89ec57119354b916315d56e9a042d5c3ae59b85c03089b658cc6f38fa72585a6e0477e86a55de2422aa9aee0d28fb18204d4dd65f63b1fef328cdb01ed022545a6d38834d9dd0662caa832d398bc31dd4012a7bc4547c1e358dce0b6889968089dcd5f60834b74ab5e650ec20014c52741dd99c0f31fcdc847e5065d1a491c23dc6eacb38ee320c5a8ef943885c862b117abe2d36a4862f52b9d0baaadd7e9639ae6e59712eafab277e56c7466749c3b5a27b0a8cc35388efe3111129a8fca4ac86b09d403224a05aa59581f30cfe26b3a205950f0c332cf724a425a8e416438ecf04b4c376c0207692760c52783f6f2e28489e226e74be6de25ad653b6e5c9bc4bcc299c24a4bf8bb67408a55347515c72265610323f8aebcbd264d43c33342c9c5365125fa52213f3e3d3a271758eef2edbc4462880a92e986ead82c2f108128e18c68e6ea42d55a6766769ed3fd7e94545327623983f38bc8edb526dc3818618258fe6bd79a794a3074ac031f511df16e6954c4058765948dc965d22f626f555744feb4a161ade909c7d0460ba8321156add88e6b9e941c6f05a67db42e1e141b291e66e2e1fde5d42dc8c0da4fabd65c236de9b77db47d0070a94bec25e2af6f08af28bb18b0e6dc77e4fafc0f4795485d507eb09e2e598041db28d1037391e1ee3621e6a010d05ea0d182f03fb0c86d3bd2df9a1688b2c0c5931982d7c602daf42cc7a26928619982248a4e76182bd46c51c6c83c462256cd3039cc7d423eeabbd9f0ec70f05df32d35c446dd32dd623d2f075e14290b6c23284f3ff533ceaea9e47a4552d8570f5f0dcd723212bd6a2dbc05f4984116854a004c05d788e6d65b5042a3659252b0f22f95548cb13b293ddb1b75b60df48b3f048fcac7c846ca40af40e3b1fb7d9a13f21a3cca73a8bcc3ba1007f21e982678f10313875fcfb08de5ad4967fe4d20bcd82aca2aa8cf85110645e90e1644e8d936425a88ce9b3da1da54f204afb69fa18a732b9db4026c6a332d8c48e53a6072c88f9b55880c25153d6bc923d782f52eed51a4514b042e44f447b2413c29b9656d75ea45948a15d7cd24e9b0281fefa42b2b0d5af0b4821bd2c81acab0d5120a2207aad71799ee9f55795215a4626a48cc271f72dc1b8fcdc7afea988ca60bcb9e0a16233bbd68b9689836de9748fe186c5fb343025006908be81b9d49ac03852fdecfed2d96572f31146d2c8635b668c2c6a12d4d035ac107bd5f73c45a0cf8ccef515936673793c43203b4fb8d86c6d5aeaceed9a162dea5e27d96145e1abd584008df30945e0dd12b4413bab35ce4178b31c4aef81fabde17df0c66d503a451588036c8594ed3cb12c0c84afdb0c7035de5b36ed762e05e2290938529ab9eddeb99d090a1bbad3f463096f151138283240f9bc4b9aa865d0400747df6cb4e688874b56a2c82d2d420a4e0c55678e869e8ccc6704761dfe60450bf86735d360ae47551749abbe6dfc6b5f6b7d40a3c5786a5ce61939705e41714a605d7dfd08dcdc272bd6463da40a7b513983332b2dee4b04b62239ea42823d4cfeaf00dad85379885b39f1f7c8d76984a099e9a880b2ab37ae441ad43c96bf74ed0299d35814e229d4dbc9caa5df988f83abf6dd56d841f1ff047c3cb45813a2cb98a63132272800166904f5006246b89b5b4bc4f8c8ed5081815f22dfbb6b11d1f4d8fc71d262ffc423c9ecefe5d8930368c25b35c8d3f7b1d6bcdc4eea092ba08b24b140efc41074f0ae118ee272f0fd85db7b14462ba768c4af638d4dee37504ba283752a027808229b95174ae45b3b0af8c3af182c5bbb36caccd3501dc5172ea96dd8a51fcbbc425d86c4b3ba3a16c971487c9233ac569edd1a67447babeae38bd56690cd6abdce75aeac8f3127aab2b2e963bcd5cd096d755761c4d59d821db3550a76f840a31b43466836d9d4068a6963bd116683473366bdb8dc2ce805b2e9207427ebb1021e10119c01a5f54dfa56b3af1807c84e4fa61d537b89f27317ce4699b761a0c027bc2e1e0cba3ca9506a57756a46665e7532eba989675591e88c3fd734101fe1ff0d6a46711043761fc330dbe6fdc622f49d30d7b77fd2637890e989040f3670034309b126c16a8b7e41ec99c3c14af3295802c38f228d9edc795cf633f3bdc66218265105ad51eb078ea60fb26ee618ee2bb3e75b20fae2f63b958483210aa6d48b56ef549e1407d4cf5fcc14900b16b900c82403f574879ddb0df3992e71cadc013700fe2f10ecbb2926ca2cdeb75be2b6559f2ac92843722b88fdadd20eb397e22f009fb045c2fd5688ee45a847849eb7a1687c125caacc8b5c8966c833ee2e0a93258f0c4c6ae1269729c5948fabb535187733a5daa5c80c352e02e8cbb3158adb8efa00d189402fa69cd15387c56c73c56a728cad3273da80eefa964103e5b8099eaf30964adf76160e1b0e5aaa96d278e4ef91ac7757a4257d849e1d7f9179ec0e7fe15a0c991b7a23658c4cbf5a64b9b49d6e3b683a22017bd4781ecc80ab1f9ccc8330e5ac7c2cb7035a970b84cf98ad2f49cb8daa6007bb4b831822c68f9f347391188543bd4dc3f1c0a238fd8ca99d9dd112acdee169c02ea0d1f6cd1f0b103634cf3cc5e6d73b736912d91eae19e7aebcdbf6f8fd09784f8b2d148602e94b7cfe9887adacbb8ea3f471094b84eb053cc138b8b8af19932c8e9aae891835d13e66678ade318332746dddb5919942e58ad71cf60ff2eea392517ba9b98ea63560a81080cbe504670c7687783f127c0098a527a0167c303778fceebd1c6cf5c67997ce6aee465184aac19ea3b2ec207627d9f8cefe54be7c9512fd1d920324da0b3c5722e4e1d2fbe744cc182f85d24b46a02a2f3c27a2c50136ac92aa7f897d53e610638a2cb46969ef71fee16ac7d7e19c3866c7b9ba5098ebd40f131f40989be7a686d25e0c3086c0b7240f547108d41250df2e5106884ed6c440759d89ffe98556bbfe10aad46f1605e79410f1aa98fb482d034c1e30f7117fb32b29f7e9494ac90a4f32c59ef6c2897a125e4dc5f608b39428c5d08a61a257a52f6df041a8c6a81a0fb1c369f4c5f1a2090da6cb885a57dde3192cce58de108351eb8bfb65774e9071f5d94327b76cc922e9225210852d53840aded88088ba15d5619df9b7acc673794f241bea0b7ccf897d75f0313f456a5f084abe06420f2440944047c53c4ee5fe64c7c1ed78101edf4719b6a06422e950376451d853e84c19f7da84330cde3c0c3fad68572cd64b131fde33fa4682547e3c056d82e61cc7ecdad9459f3f58a70231f176dd588bbc9bf1a704e90b3c6dbb34417425b179faf506794b39773e1140ffab3c7d994923bddf2ab812d6455b4d499e20e7e377331f6f8e4b68cb3acbb3bf5a6f84815ed43c86e190631dbed8866561dd67281a624e318468f48ccee0f6a3e468437ae1e50c88317e9b62713cecf8f9ae0eb50f9c4e3d9eb97cade4ea6255828e6fa117b3fdd88dcd9e0f507ad43da40acb6257abe35fbe8b4fb66752038153b26090d9186ce4ccc442d860af5779b753955615eb257adbb6198d7d937dea7fd7552f77307179db76811f9b391a169400cc785c0b049398ea2798b33d8c44d448cc78ed53dc0152356c26cc43697ac6a6a493ba6cee68bba01688e3e3788fa7fb833c5c3ed36b2287d5db55d9840f20dab788e3401d3452a2ba4a9e92f4e7f7cbce75401a39f00b0afe1f4b2fe0cfe2c32fb425ea7f3c0960620a14001a27cd46caed46544fde3299d2276fabac1e17e4b9a51659a3ea9a0704206bb84e790f6d9bc088748690b3fca0fd1a97e4fc7b5b964e268a94ad3f65a5d6a796c17777f49d4c34f982ce83a89c79a26b3a800c90609c9a7795b68c2628bff812ef711b2ad90a2d0f1bef4e64985d26de80bd3fd51b44fb52ed2fc03ead793bc33b447404c5957a9e571b8892d09ad5f50789527be1fcb41ca22dbf1541e2c743db743450c965bdcb490597daa07edf8f6302b9977b6ab6ca846079f3b021d0a7f204c39bfe4c1be8af0f50d2c5f1219d89d20599d31f67c7ee19a1f60bfa277633e4772549093187aab652b6325970c6ff2ccdfa9f77b08f59e537042e1116d61d94d5e0c55e41b955fca1b443d0c552d4f6159b9db1eaa1d1711c9c317797a02c9cd6302586815bec53c5c3bb34e9326b0666e7344f69fe19854384c57325d038da4463162126b96546c4c52d621bf3c5260b0ddbb7db4075277cf1da6016d13fa19212085d09acbc12d8b26a1e9cb1fe42bfb11018efcf4ee70e7d48b7d6b3b4f3c65dfe55a1530988a56820a7bd0caefbabf28f90588015ee0e0166a5b2ec78e057751adc2a12d5f3f0bb7b6c7d95b277a7515faf0455ba7a18dd2542bb458f5b5d466a3887ad378c00b1dea46a87dceed41f3620093078ce9d9ceaa6255f4dd83b4b19e2d3d409adc25ae01b638d7a056da745dadabec6f0d224be481d3c93fcb3c457144960b72460d4efd238d3e11aed3c43896cce8bd651579b6ef36b9aeb32088cae9ec0bad4300e40b1bfc5d28f16b87ea31d2370bafd7ef6b4b26668e442781e60e48549c37f0ff2cc708285f7355db3a94353bb99a34a61d1035f38fd58791107c4c6265bc54962844b0e8424f9396c23d4c21bbdbdcb454324f5118621c4d08740f69196ccf45ed8180a2b5dd60c5ae9b13d0a5e0927cf791e21bd23c94d2146f04c323fe274193e02d32b71d1dd0eb8567d70b26e3f5bae8a357354afdd657c875674d4aee11c0ad369579ac994770c350bd3839a7385c98f42f07f9aba10206a5e1b0591c9abca97d2cdb2fb44157c1047ede45c4195b6037a74a34098c1c8728db1c9e0d97e5410d4ee26d75a920ba033132bd3ba8b1621c2ebf781588fe285ca6657855410f95cf3717ea93e44242c6bf8ee8d593f9dc490afece179467cf000066bc0fa07de2af3eb1b770d81fd08a71e78ba380c1063b3d4d09b0451d90fc7aa055fd1a6a38251d585e1a3e69553e8cd921e5f605ba2171051e67792efe679b92a5835061498b7577493609fa7880870c2177b1c48363dba1a693fb6140540478c5628f84c9430336afa09cf1005a6b077feb6e91e1c17b5fb8511f69ab9d7dfee835105c18d127825f149ee772da118602ad321e48ea61e7163335d353604cf74829396984705b47044d5bde4e79468ce694fe7a8d37d04d5476b27c1f0c558d2b6b15f9fd0ce847180ddb84e04dc2a6eff3e3e8bcf951fec4aef0b9286912c7550a9749ed3ff713b341098b0e288f2b8000a14732cd73df06881c1267261ba23d6c01c10d892f426143628b087917698a2c0f77db17a6f66d92bd0ba3f6b360f20ff8bc4db2cd7ea9551f765927b329797a27e0794fd143edb9614ad0b2d7e7ccb9349490e3b39b7c0cbc7d15351b7f1432114dc5392f8a49cfdd629f5b330d294b317db0f064b02ec2ad82b35328bdf4a226aa03c013882645842426012cb06fe24b0f8ca35867ca24e90c09c617a862ae6dc2eb98a3040e454bcc132a0643e6107bfcc45ddd8015fcf17117436d4a344f64896f2dcb044910c0f966d0ded0a5230bcb44ce56defd41230a86bd5528becab19ccda012eac45968325f26a1ef83d1e6c556022cd2b175b47b90659fe9b1959e08b452af464345cb03713a4037e7de5c4b7df86a3ea4eb6664af945d6e1bad1b3a0530845a444add6da751770cc92edeba8d88ecd8a1e51af8d1dcbbb858a1095f522286ec5c871585d24b92cc56986db68cf9037d664dc36b61b0c9189dbf10c2a55390570ad2f9ab40df0a0a2aa6b82af7da374e48c8dced8796047a6630f1fa0cc8ac3059fe3b1ae1d3d86a912c62bf120d1a0015b071947ff9c4d66b6ae8ca8e8828f7e2822e7d027aa8f4c7284313ac10d6cbc36b85c7b949b14b27c641eeb64a221fafef7cd3893e36b7ddb1848d276491849de7e6e2f456c512e2c0fcbeb3a68146771720094d86848e261c6cc93aeabb172612e87cde119700bc4286d6a51d162a8eb94f7a5a19a7da462e06e89c829170efb3e7e4850f176023b88ee1fb856f87dd63c8bc619c746ca0e289e01eb13e712c4a32b4f0157353478ed6558dc391c6d3d3a8cc3e0718310ab1e787141e12e08c2349ccc5da97e26c8313458310d6c8398cbbb95da21f5cba800cf9c7fbb0031daf65b0dd19c119ab87efd7f490996e3eae0777bfceee8ec591667132c95946d4b180b244b4a4922e37ad70dc620b93f43001c1566e325344870b7cfdb28e9802bc0871a2abebd407cab7b3d9550818f6fdc63ded5ff473c2fe2748c5576456dd904fafdbfddc03c4f18a8cd88e01ef4b4191053c9dfc71fe7ddc92a55384903eb3afdcb63bf27701224cad822cbafc856d3da64c3fde8caead5dbb52747f161d7eaddbd1079b83899cab0d182266e432287a83b1cef6f1539bee04781ed7b54d311f4eeeb69e7156e38d29a337e585b0f9e872021f617345961972cbe0cb79f85968134de4af1ab20ad636766118748f06b2226e979a0c88602ff58cc9430b5a658b203ce51af6b57a88b6b576c1a09c893b9fbd5e28c5b2b33e72ba0147ce5a73c5c1799a559ef6207eee34259b26e33b136d2a4d0f79a5d56478d61e5583764f51ee0b3506cb822bf91850af063870270dd8d093b139911ed62905255bd5c73a6ada143f82490f0ed60234d6410871a9859e9f5cec9fb66a799fc04f0c8ac11fe90ceed80c80da2e066736298c96486f4d44d1b53cd000b4a638465160a44870f98452aa9ab1b41641e48464bc3569dba69471836285e57ca5cbf105eeef7ca8b2d1cfdfd307a421cafb3be74b032c660aadf2598a8c9a527148b1886994a44e4adea9892a27a2a5c8b347cea9ba134a374129a39a8b0d315f83358f497fb26dd2d115f9e12a5cbe473bf7d7b73b08f1ceb2d85ed72119d53da3e4a9dcdb263d76e3de93f464950edcc3cd3fb34a98cf4c0b8ed4d0f3cd30a679555de33917703a750bd97111af2c95f1810dcb9f76ac7eac3fda947f23448545ec8f73601935a460653e915770778e0b6ab855e34f5200cf976e4a757000ba6072d70eaa9ae66244b2f141f263275b8c3c0a13cf944c156b13613280965a62b2e8b306f1a712b26ea02c794ed90c082d7043240325bcbeab47d576c069b41f00706065bb849570a66c63c968253fe8676bee98ed6dac2b0790c3a34e74192404b79c1b514b8f6b5529b9f3f610cd9ce884a78d6717c979b8a66a1a54c67ad521f77688f43ea199ef0f06a55e9bed3ae448be1edc75850e14749b0ebf298c171e4fff6400c498015c64dc2c6eb3ac96eb5700a379d069bc8b836bf1e7676457676b89f8e0055278c4139d36dc54aa46d448ea46617d279ae238b586313674cfa50dc9e5b0a8112e606a9a8a7a70d7d879a8587c9d290c95f1b3d5cfdcf771fa77aa40d5ae845fb489cfdc092b94db86760e6e31f443d802ca585adc367e098e8d3138544a858d75222d7f5739db6f6fa5741ea84543ae7cac4097faf77a0136172abd5a6f132006c8b9e1a26fb6255f1320bd6cb993af4aeb05d9d0ccff59078997a958c621b7b471ad68ade9e84721886f61464d1995167f636ba2809f1ad9b33af9db216ced0d3c55ddc5b91c73c41c7c58efd6f9f0ad18c317c0aa2a1607924cb660decc1b223d5d859d32a173d8cd82b5e732270292545753fa3366cd1d52521ab1895d7844ad588900102cae2f976b5df3d29d1926e0bef4a7d5a92c9a8e5e99461dca7fb0aa581e8a91d1b50770abf24a189709badc39b356c540d360953e95507813419bf99aa4f225319f9588291c44d5eaa6785ceabdc419c46c55826b43e5e3cc907be95c1bd894f9ba6ef44943ba279ef3de8d43501fd67d1a08917a96e6bdae95a9769b7322788df31f10b3b3f4fe30297a64e36fd2e9100b2cb43c5871f974c77bbb323fce7b233eb13d2c2a6c7c5dcaeed55e96956e861799281a2c53f280e1550bb493c37db6e589ac65399a88c04d4eabedc15505d42bdcf1d3ae51d0594b6236822ef2e5d47fead1a3781522442f46f6d2f8db087e23d493e7dfec5dddcfef76e7741e2622673d988cdae3edee3215132f3724fa1f9e6adeeaf4ffbfd38670d6dbdb9cd12ee407af59da99a15f7887eeb061f5342a4f0a5f2e5baaa1866231df799d60e453228c35bd20b39f42ac684da292b7945194eacfae3dbcd98e13361c46138e4e89bb7adb47004b58bf0bba32d323f77d35f7347c599593a7253bd075be53094becd89e25d7822b51a403f75f23db0480bb06999d559759933c418acfd12b26720f419ffa37f38da1ce788726a8bfe7619f060930eb1ee3b9c19774ab8b6b7376cb340c363e8aff006794a6dac5735495081315e7663fdbb4c4a470d65509e9cfb78c78bf749c1e98566999f0ab47ff596d5afc8eaafec8177829e86f7356539af75e9e1298baa1594b63fd36f19fc4a4112d6f43ea28e7b59b78c08ce083842918cd2297bb16b70b3365e33b13685ad75080fb63850832ea7ea0bbe36242db8227585215cad7266ae361e46cd2d4912115927350598f59eb377fdbaa1d869c8f02d8aa15520ec887f26799c3cccdcefb0e057762d919fef08dd997d24d878c32b74a62c0ee06254b72f22f26b238cda44ffc9e7cb2749fe9ddd2a447009611d2dc75405f0ce4c692b803331e84e008a58c01c81a765668c63271cd5fb8444921bde7790119a37cd8a000f95e58e473bd05784a36f4047abb1dda7598e134a85d18c3dbe96b6d65b952f13948468e590cb8d81f98c34fecf933af13236b470f46a9a8e631f0a1cbdb54c0be4b931bcf92f1dced53b28922c1930377f6809281e44f6eaf6e578e9fa584aabe0e9faece44c1845a364e48221c0ffe5cae5bdd8c97dec5d0e1968f549fb7a608d23fafdc5b6fdf4d774fa203f3e8619d53120b397b93cbd02a061c5d599e5671f53f1911b9b7c163a65f942abc8752d966f916099193fc9631480123092a4e1751cc0f0d9fdd444b565fd855770e42456e11fbbc24f0cad400b0c1a6c494eb290ffb09ccb8b90bf272266f541bde5ff54e55444024eaadbbf952da93d0b0530a69ab7a0941ca8cda5a9bc072df413996d107ac23da8b3c3f6b69e9d7bf0e9a60c4a5e41aa73849a8c874640b4b402470e786c61ffa0ad6bae98930d3bb91dff8687c492a5858c5aa1cc8c2e2dca152378510b58946174a4970e8af46eb30c95ac89bbc4a8b985cb3aa8cd1190ea3cca10c43eaedee59fcc07dbd876271b","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
