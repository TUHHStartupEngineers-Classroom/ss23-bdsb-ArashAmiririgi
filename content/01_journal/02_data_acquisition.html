<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"7781ee45779745a359223a24512ee1f91191ca9b4376c774e2502bfcc4196e5a7aefaa7307318ea06312e3ea1fdc189db600709b5563738387353552ca0c34dbd68cf8f881aef25bae62a6b708803af26f47d025b2067c0467794d0c4172863d1bfd32797311ec10a39f550b20ba7ecd3c73d0197b7f45d895049237abeeba4eb6234f90a72da2af14e4f7c3584e3236cff09c95c4028024c046ee25d00e4a1552fa2ba071f699db7e81cadd949a54a8b1206c612bc99ebfff653eeebd52b3818ea2dab1991c593b60fa23cc74a21a3d5e549fa32f7c0f260ddefd208b41648f9229348c2d0bd62872c200353e21ce46fa348893df5a319ca0b1b9e6247e888253884c0f8062fe5b92c50dbfb4447cdf7af5e6b9ffc65e030339f1d3531254b99e791ce33106be17d1c376ff40c388ce2c0f362fc884cfb7e5ce06abb89cfd2eb3b3cdad6060e724f5825b4e855ca1d42e8a1c5724503b78c9632c6e5273efbd97819981173dac3107440207f55c7164c8607049496387c13958f79ef8d28364941721586c28e4607f4b75f48966e1102dd4c4f8419d07d874d50a103e550f2b5009f48ab7514d9473442b4201d96c2bbe2d19e5020bbd14ace6bf12f9a8be6373d8927289bfc7aede124b59cf2cd8faf87f11038fb37147a9665b46a5f3b797dd80275fc3c2e7ff2955c2c337d1acab8196faaa82869d8fcefca53360800d965ff34f1b88e4e82d607c9e7521893259103f856714d7a08a4178cfe46200b537bc8f325b080632ed53fec82bc869ed59440a50392b468b0aa2ebf60aff1a0bea8b1d8b7d473b6b68f68af371f7e6d2635ac2a7847888e1b5f0cf3352862593e7b908c653e0079c302a9c0ca0bf9cf6d328db3c46e576147fea6a35227d98f5cdc1564026b12fc83223c21b634d6f2a8c157afccea95e31fc0e42e6a5abe20c0445d05e71d5dcc82cac1915255420443df9488c8789482566a76fede3a6717386635ca3cd640a7052aa5f7e31e7c42f0cec81c4cb1127cbf079eb7ff5353f4712fd625d07948b235653726a127d160db19d0eda0cd3ac2bceecee7de8f9902021af7e9e437e7ef705717b10da9018e5d7afa43d2b61046c840b67b916fc9934b741225dda80575a42fdef97bac98c2e4d77ee86c72983382118e06e296a0b838a95f6977d2c19ea4e6a673f173a1cb378887009305c5a672b0e8176b26cecec7493cf7fe269e4eacaf5a893e7ccf99f550410befb48e97ff7e95408d6fdb0e556421ee7ea4b1ac9f0c1a3fe0ed4daa81f5f49c17aaaa6fd1327fc8f217e346174a10f739650c54eedd97f319dc5c942bcd1caac266fc3f84c9a44cb3c439153a910fbbef6451bd331ead2076372ae0485abb6fb4ad8e712d3c4863a260573d16be35afffa9fb07e0d59114f12de069e03d3e08e6ed11c8898fb04aeec48a72a1879aa4aec6c4df4ff1c050550b513190c6137d11d485d921cc80e3018944cc6b7f0df8964be86038e336a3b46fb7f606fb4151a924bd56205a0fce13d6f01f194838de36e13c6167e63b77286857f698da7f22e766239bb5423ce758628c8751e1677cbc2695a88852fdcbc00d5a56d16ec137bd81f6a535313a6ec0b0333f92e8bb827d18b73229b2afcd541117afc8e7c900db323a35d4e11b1073287b541fcfdbb99d211c71f5e9558ab35ddc51f369d9274409e7c0483e7d9d16cdb2554138fbfdf59958693b2bca4e8b08ba8774f095eebc7c6771657f4c12c45a615b8cbbf580bc456369a3e6e3fed2739ced3fb0942dd9406164414a08e8c0d3caf32db80a375ab143e6d2fcdf4b96d8e2e9621c08eaa4283dc117e4ed93f3e0077e708d23137d6dc90996299e08e22b5017304090c7a074553282335f498328ebb24957d01077c821736f8f09400a517f13b76061c79a00e24c349f9ebd7edf04de254aac396e07e445d6466c42a2e36491c619a775e8b967438774542b132a3baae449dc4f70f935df3ec4834977929142d4afdf9d3cc7b636fe4cbedba6cbb84264c4ce893d3b340624e7afa4e99e6c6d7eca6ab923e5e4aac90033161e2f50f2095ebe5f624c2df5b61bacf9da2615d8ce78ad0d806a69c7528612d4f4d11f558c5aa5ff229aa8917c4f3db2116f8aada892e167957de502131f349aefa48d2ce96b3ef5f0788a709e4caccb1cc0edfbbb94206322d9cbf51b8339904f5c6ffd3ba07656436fa0260dfd6bb0178152da2f2dc21fe1d9e2bb80da1895684554cbd2d447c55a26abbbb47a6e58eb9d7ef3dbd4310e45b946df517f0bcb248099f220fae1410e535a659d189ed8315aa036662a13ab263e0ccfc91dbb9556966923fa0690213a785b5fc2d9d0a0b2c5f4c5b3d90839dca8695b64e874cde65a0b43f33b202dcaf3aaec7be66c9fd17c7f2d62a5481664e3e4b25b3d0fdb2f4c519b76f324e2294b003c5442eeadc098647e2d42bffdfeb2320f6995d6155e63f053d062ca4182db477b52224b6fb5b1bd1c04a98cc7da58806e59b5231783cedf79cc3e41a7936093f73b163c8c96da13a1d9e2a539eb8f201aab61311c22b3c0c0cc89ee7d6ffd489bf744aa6a7f317a6ee75ce5f08205f62d7553597fdf4eae26d55feedb105512e34840f8997bd257bdabfba6c0edcf608558cd35b5ab97a098b132fbd75b5587fd1677dfc27b436d4abb5e7b39f9c884785651d0774f1127e13edcbbf20d84a52b2c809efbb923cf0641d5bf6576f11e06f8fa2c9bad041c15d88519b859419cc48fc3a4a21a4327744aadbb88f483f37c2bf439b476c728bc632f30eb5c2d722d8dd46cf4af9e1c93fa07a13cdaa59d5d100cb4df719b08854ef3894377b36d320c8c8583322ea7b553acee6c794fa6d489701aaf9f713a6d0ed0b4ab194787ba646e67e86b0412614a2553b62b8c7d7ebd715ef413f3b12dbd6a6e1ce451e8b8c547c8fc9dd97955c95ea1891b82af2035e34b31e6ac0673c34e84139068afe8c2a554be2b099024b9a3e9ec94d3dc788340ed3db2c5be1322e10880732a7cb86d85577aefd5ea667a1c9cf22e3bc8b42946adc17c639f0fdb2aeffdf770b1d1c0407f8ab7cca950f67e6b1f272cbedabaafc5dc975657bddcd0dfc74c1cf930f47897dc25a7dfd13cf8e5218f8af784c526ab5dfda0c11719770540d1182a7cf74f6e7e9d3051da001a0fb7c95b556916f11b93d1fed7295b68507f8d8918ba87d81862d5262dec354478e7ffe2d202f16d39554f39e29dc0998caf427abb19b29871ef5cfb79b7e55a78f253a3aa34230628d78466fc7e155df4bbb1439feb6088a31313277d72d0b48b2474f912f913df7178341f057c1f28c68c3bf4cad1af95bb3ea3df0eea1f5115bb4e4d2eece4608fd1da3cfe1d38a41f8c12f744ec568f8aff7bc2b3ac8a101493dbb6a272ccd439d5717aa56b4905a514045fc53fa9ab0c21af32e71cfe3d5a0e81e0e1f8229c16a4d84f6e6c847dded1909004eaf4fb803500852239bbff15f2cffce87b66a262d5e11b4ec9d4bac80a44c69e91716c2c64010cab8401195748564ed716ac99e0aa53e6d3e627df2ac92ac9147d1598603c9ff1d6eb0e842cfc83cdb8e883b6d2f039090692ae8c9fd34881159e22f7fe81b6b04d4e8df6137deb9b0710cd16edfdd850fae81a6301c52d793a49054054423c8471920f1a416e6725b13bcb7102e746b7ae2db740bed6f3cf6b2d56893b14de26ddcdbf6e9ab9b70d19819bf21339dcb598bbdcebafb5df4a2c68aa3e7a4aea021078f1014f2b89d43d87fca651c8f8c15e468d9c7f4ddc08b5b4a265e1bc10c23fcf42488f1694d3878d3dc3b5b402713e40d99cdb435fa1f6fefc9fb382e7c7afbac9b8b8ce608af150492325497ed331e89b31975b60bcffd6a60657fcdd66bb57ecf27132007097d2fcf0b26cdff55554eb5604fe0025baaeb5b449eaff806f0460164e5f9e701f4e1bc8f635f087f5bee188ab90d8948af5ca0971800c4f00c3b0b997b6c94f7184edb7fb17619df8ba8a6c7b51fc21cf5326e8e5a33ba99d56e45b74304262b2ab180bb9308a682699f94dd104a0e8d254553799ed380f36863e3a633f4d86d7cd9c45415a9db74f49ebeeb5cc08851969dcd38c98b73d57079c41ef73cb18a1fe04930e2dddbfe58319a62445b0445a7fd6ea255564e282dd346cd0f78be544e20bfba4d4b301efaf8bfb9193acc65f452290c1a7949e94074c59cb2fe0096c1545d6bceb6232bed7c6651e84658f3e9172e362ebce4d6ed57ee40b68bb518e24722d90eee716bea3caa524e11bc22d83a9405817e6deec854a000f80f8c001524743e566f5763501dd2b1d1b075d25a04d7b106c829805279616559fcf94cfc87035de4bef82c97bcfcbeb0f20a7d2833f9d232312713bacff975465acde7e6a3e759c84fc4b253a135291b1e071f4a60a466843e09868ef3b9ca73380eca1f7e2d29ef5f1cd5196792214613a4e4f2e8ac91f329830a4989df1814f2a44fa4a17ebe208e362e6ce3fd075dae4950b03f5f59ebc152fa52b24cbf658c3e0d65ea5839e052e01d015de87bfb104416dde6c6cae514fe90b9da5f4391b4e6a04307050bfce2a8fad2e8c472efd8d6c89f05baac52e1c8ebb2d1341542899bef845d39311344742f3d5ec80147ed8628bb082ff12b7581f5349e6ff155a632083a73f82eec263297ae6a2ea45fdd0f161d6503798d0cfeacaf69a87acd975f95a989249adb729e13193033c33b6cb41c3bd662fb57c456c9fcce6bbd0bc0c02a285c7a8875b6c14b67deba0f79f0079cbc68f0eaaad6fd563502cc403012dd494565050e66bab7bffc53ec306b9cbcee5fa99980e91af404d5b35ce7697d344b6eefdc2629311849f6a2ef9b7737a12c2917b157f5559d29412d40b8b4dd353615a80795c834810ae190a20dfbc50dedc246de0662d1bf9cbf079dab1501ea659ab1f7eb0c1e8fd001090393b2e69cbfe3c41c37f1b47b8551bb047d899f50bc08c1e90526cfdeb1179f97ac37183a1fda473a28c3aa3fd6ce09c92c0a6005634596f28dfbb6db7acb00d12a62b750f2368b9f2d57d2a8da00aea0dfc14fc25420891e91206d348dc2aab29db7439ef90196e14d466ab95fc80b33f6ea6240b611e610c3fc548539989c9b2cbdecbc7c2e6cd1c7b583e4d59e87f3de6b0f9fa1ef581974180d8af261433afb241ecd43a6f468658f6870b830a9d5b6a8da9794f7a845b95b302d1d07cbdfe9d29d90eace7f6e5463e9186789fae3c0e0e91c729ba84c8614efa4ad24db6a049399bc2d77982b0cac49db11d361f91aeab01def9efac6bd9c988bae984bd930441a1244e97b7c15e29336aa82bf272dafad62809b2b65f73479a41f78632a26a500ddae0f2d74c53cbf703705a8a544e0f53c64a01575c5f119747749096f643473a3a190a7c9046cbd36dfbf78d6e1fdb22d090e3da5d761cbe9895dac1bf315817a9985c730c7483f401bbd3bfe01d5288ed33f71ab77774fa1e1fae8e411b5c2bd91fb5d3b5de0eaf5064df5ef5850f9f514d650c987bafe0eb564954237631834204491d985b196be67349e9f1a9d350f83c2aecd758b32cf0545ef1bdec3fd32d5cacc091c2fa644f96b378f16324cd70af6fa60d509f2a5850dfbdbaa8aec9a27a27d5ba1df1fbdb49f657fd14ccd6fca1eedbca86c68668a314bb7925463a6085b89c03f9231243d15139c6a931b779dbc04a07ca0aa305742416563233d297ac60d71bfaa26d93eca965ee4b7d9d892659736b0f2621c803892cc06b2fe8040be0e5c13da17f49d70e155e02df58f4b40102f64758013a9269f528292d572c1354844e6657a55d55df61958b9e3f93c918188d9b11bf13247507e2663d1fc48601c665bac289fb47b0b4ade79e0b785add79bced5e60d71d7e0c33e2b761fd984f9265ecc664fca9f88379722d92ce9b848e7206fdeea95a2449d67d428932957cd8ae7e4f737126a2b3457babdab8523d6d92b92b97a80b5f9a395fb26b860228b5220da79c3d8e1ae054859137fa29dbe1c07fdb4ddb4d047c368736c68acc4025ddff4ede495a848e09d16dabc179c4cfa69f75dc23591833592c494d55490c78a866e40c95b1bd23c5d5df05b9e9fca91d7d7cc34c88e1ec4ae796fa667f56fa8f3bb3709d3e0adc889cc29ce9a48884fe84801e3b98ba3ab0b75b624f7166b63f98535415ce68f0398995ed7ea4d721d9e36c9a48d31388a371942bbb1281126072605cf80bc0ef252177a8d3b8a6b0f3b8bd0e66a8459b97381a0447056ee11f8a674045fccf4270465a96a83cff1e826b7538f29e4ebfd4616383c418f54be2ddc652bea8f3ce356dd7961ae936be4dcfb5b30910138a84116b2ed96b4c875488b6ec1afa06c63b30c4b15ebfccec7bd316acb2af84158dd85a9ad3b02cc445af1fc32be0d9f5e83ec3efd291efce458bd21be68e3ca91ded708af60554dfcd78624c6c8d2bddf5f918470e4174bcdc1f06ce2a3a4bc51b402ecad5e939e3f4dcb9d1b026c7504adff1d6ff1a15080b06107f54877a761ba3efd03ea0947dffc34cd9f9e2163a54b1ff25001ab718ab951838e20e9cc9868e2d868d841b7ff41f70d7e3ff6e94709e410b10020e17237c2a042e61024cb5b05b84e64731d964f746ce942d4d829b30a408e248a64d20061553ea2c61b583dc41793e46533dcf444c268817085f2bb8f50639b06e31ecab4b9edddd4d61a81c921bd9bb7ceb50f365d155802159baef2428253fc8be83d767d48c765c7027b8188f47553b5a4ac37a18742c6f0ffba1b150937fdb5f005a64e912b1e64dc481596bce0a926ef283c915e024a8b15de6f146e74bd0a35d12a9a0addfa7130df9a6daf8746ac101810611c3b26c802933260dc52c2127d86e39bb7219c7f66881f020f304a1ebb2f347fb827522e8285d13948b710b48f4f8ab9154fc912d9b75dd69c095e3e7f8a9bcae9d663d44d72b2c52cd0e5e376d3f9b4b221a76969695c8a4624b9a389db5197a67dc205f61b72e4c07df905a6573d900c0db0727ab135692cc79bd10f06a02d225369b93df6ed6e262245d4e51352ed3898fae7ca625fc107b51a3ee3caea35c04816a73301498d34f74d83545a695f57a7ec0d32b7a36841cdb99efe0757960ac9a4741c56f2de8a53ebccc15670e8055ab68ba3bf62be0686c94bf1a832385ebad35ae5390077472ea7909d81aefee906b8c58378656c4a05e5870bc136c0940f656646797d9bb88378c631acd529eceaaadf7d94f9978a3b10736ef689fa9c8bd70929927ff35c8e94efd95becd5949f6f687f0b1fe6495154d47d9a5bc70bba864a3bacf8276ea82e3a83c846026c7230e5041c2813986e5fc4b8d745fd05af3f96820e9702a3d8f727fccc318ac06312fc5760a530998c1b90ea45a06d96e2045225e28ce9c8b59c644075981e81bdbce19c2ee524a286f2ff018694f3b4d1027534ca4458a9af34821e8de7f239a014ffc6f9d75acd2fa25968f103892d4be78874c012e2efeb42048090f58711260a2a96502a96e860a527d4fb27a7d67e8b3f1f88ca8cb6fc2d1b61c71b7ef5f3c4889415ee1356be48da8911359bf2dc1bc6f080b9a8bf66ffe5af33827fe7bda7f23de110c3acc378e10588def38a75d79ed092ee2c2b4012036665f5de04c1b8c400402efd4b064c01c1f3a6105706de9a93099796e06ec074c512485266af616b66c958272622292831beed22265172335002d1fa670dd554ed0c3463f18bce8099d6497987f65171c8ab92d65b3193f0c93279020e45b6e6614ca12f677245ecf91b1f5fc5971430f17d0cdcf242fd472b4bf73e0ef0d0e479191e95a922c49379697069d5b89ec1408b135e16d4435f683e8bf141370b817177b727667b71281a29c3d1faa4ff0bdb7cf77d55b2685172b71f1ab1c593c476628aa9638154877e3b40667dc8d8e0a06684671e97a8747d3eaab6732aa00e6b9bb175210ebafadfd003812a29add060436f216435525caece0c683422fda47e06435ec6ad8d2b1a364f0e0dd07135a0f2412ebef535d847642131ed451e3c0dbc0452b87aaf3407fbddd47ba5935ab9b428c8ba4039099253189d92750e41a257d81af7699eb2215d6375075566a5573ee905547ffa3ab568aefafddad9f81553d905fe35b65e9a6298d0e4b55be71860f149b447d91febddd1daf1c5195b3b7d44f635d4974857353d678eb6ebe6a16b6cc450eb8e7a788d4b90c164015bcb33ff2c5d9a5a77ffda68a7c15be82ba2be2ffd592db681165ba36a6b58f1d99f4370470a64dc3505394b21c45cba331919dc70c561e96af049b7d060f904e6437ae3ca6db53e8bf6b3ad0c5c155403977f726b5f40d0fb01ca2e4b02afad0848a4e184b05ad045ce04fc311457f116694e791fd14a32fefce3195e875b5c6bceef0a72f63c43cc2e0a8b794ae7f2f59160a29d0bf7c57a1e796dc49726b421941f408e73b3885a44b97e0d6e6e4188559ea5068e7bb6350bb97d4715eb59d83541059f4107bf20ea69aed376401774cbc32395b27367c2c1e5d0694cb245f39cc079b8ef5a4d612940f56e45fa88f38f92a73c230334e9f9af4bac5d4c5925b2c923110f2da93621924bcb074d2387ce408d8de9afc201b03168393781a4f2b59bed3602004edfe088fccc74781902b2c5640586246df0eec43e0f5667496f9625023056fd4f2ae7919eef9b3aad6942f5ad2b89510f7d3bb5c4224fa50eff7f9cc1ecd867c2186b3c89eb3b9f56b83557add5bc7bc0055cafef7e29e031081cc4c0f82958f8384bee6b4a89858f3bfb2618fd3cb70a61cdb2b1a097b01cdd8d94282afcd2574bf8dd7675ceeeb7eb0e91620c238a14e3375ea6882526a13787eebf80a7e743e0118ed292fcb15e3f276aee4f42e64cf996c459b8b2dd2f3555ccfef123fdcdf006bf9e0201413ff0474d53da55e964831f4e958ca4f40e706d0c96dd5964606bfe4acacdaf5b179285414ff3cdf4a2b6e609fd4fe38e76feee1a06b3d268dcad2a7bec009da026ef200a889fdc402922ba700b5066237840f78415c14fbc54498be24564518e3fc0f70ee3361fc43d88680d18c0bdfee87f40dea208b4a5b5c0a181fa03de48ec1dda32befa61d1d85cd92e50ff70a463b8db88979f1e9ef49176a07f6c00f1b23b6c631b020ebae96c9c1f0833e74ca007f96f894471bd1ef11ebeef98c1ce85aea5ddecbdb918827c4b1a1bb3b203e92fd8b57d6cf5eed9fe25344a7cf96156848f267cf9cddcc4aab49f41444236219801ffb7dd08f49a0d211566112f4d296bfed5ed5ec77bd0309dfcf9dc87e77ceda2a8ce5cdbdafcf2903dcfe74e06d8d757d226070608955befa933f6089314253ac019be64fdb9fa3ee71ab283c0a619364902fd6b790b2c65782bc00273e69bccf49d63d574c3d58ce30f37ff3c7daca1ae0716aae2b991a8839f81d2d282b74e06439f7a21e35056f95dd8f7910f219183dce4c6593376265e6bbf4ea4778adf8c2014966b1973ac683a89cebc0da8d2c51d0c5e97a24979a221b947c42f9cd19a73dbc01d9f03d7586410c8c8a8059a013887a2c55b935e03252b746e078f1dd79504cf806f04fe6202d1070ad9ed0df8e1e10d7661461f6205e8486bf5eaacfb7bdc96233318bd0d2df815c48d4ce7f5e26d55af466cf47f7e966cc5a99ec8028b544c4318fa0bc93dd2821c382d2ddad969e0225afa33bc189579032b7ea6bf78697900ec23372193bce022d08df1ee6e397aeb44226b9a27273cb0d722c9470c8e94f09adbb04ef089be1f41fb17a9c668634900436fd377cfebfa9db0fea6ce862342a97529955afb6b751162b85319b525c84a6b501ba1c0ec0c0ad8739f4be69ce568acf76e0d2014ef805edb61ce38d3fd9e7b88a61c9a02524fc47a69aca6c123791eb98480bedbdea45c552e73ef5e59e43ad7663bbce16c1354025a63adebe607e61e490bbd10ea132b1ba2f8776f31486b29d131f530655e5896f27edd7f6b7fa1edf50ed2dca3463b4a0a2bd3edd2dde1222522c986cdab54cc7021bb7eff30bbc1e1b772bebfc9c0746b0e71c6b9009adc04fb75b6c834e5f3ad9d9f929d7d01262d246524cec6cabf82283c9c70091a91fe114f59f00f80bfc4b5416e5ed6cc39b105c1e10c78e560becf5508be07c305162d0b5515bbaed9ca7f9ce0651b52f1a02d1e74439497632be826ca409a8f28f1f9f102b04dc56988d5a87334cd7aa18435570d261e6eb90940b467763790a30eca10bdbdf16a3fb45bee42b2a25938e299c7ed58acf41b9008fa2fc6ce3ce7f62fefe3b84a1097cd3280efb3dc4efc53c5f7d27f135b283d937f4863c3c099d437764d741f94b4554e86087cbad72bfafc0cbd81ba487f8476164350b9a8b79c9c5d988d69bd5801bdfff9c203166c588cb5a54cc5ba063f720164bd6c22efda8d573a002e98490c3dc0e90adb6daa0e5ce50dc03389d3132ac5120053ed61b164067ddd352c4a9d49618f77aa249102726e6a29233dd2d5ae49a18cacf8cdbd710cc70cb23339a663e1754139ac9a524e9df863cbc57269d1db3003e0eb1453451d8596294cd25233e21992a8d98ab3d36feaa082f3183e9c15bb386b311217ad70d79212800c6f38271c48394e93b86cfb4a97bd05fdcc32aa7415c413cdc88237f7e9301f624da5b4d071535a9dda9e658e23b0128bb246b9d58b6d026e677d7ce09c0a79e70dcd4fa7c2291f498afc2ffba927d4b526b9a17fdadba8475b43275aa807ed4f71ab1c1c330e0046aaa6bc9f7d771eb9a18d146d072731e577d5f7bc796b0d44b2453cbfac1c8f0992cb58abf7975e9699a120b701c6d4600e0f297067116411ddf74157b722f97234acc4d40675697643402bf0ec2943b442d43c8400a3ec98fdd7c4c4a2aefbc6d217fbce563bf0b088112da89949580aa9dabec331abc80c041dcf8e0d447f7b507c64e148dd1d16c892160a49a7395b7e214d26301ab1ce547d68730b566d64bf24cd0e3901a897e0e9407c9c907e9ae278fedfb7db2c3f424feb68516643df4419fa883499e8ae65ecde3c5fe67ab4438c42d6e00d0c1a60a2d6d8c4a5150b195417247f474b96f07717c48b148919bbb1ace8db6fd030ead1378ea50eb0a2b4a9f36041c1c77c1f68727e0ab92f87260c35897400531e66a5c02890ad0cecf7bc76b3fb1a09f795d4dc5429d1407632089943e17eacf9dd4d37b97a8342bb62c356f9b400d15d6d5858793c83f2156f4852aaa258876f086c8f3ded816477e231386f53efe6e2e7989482bd290c932ebac43ca95b03bdef6216339d6c96c1216ad933299d0e7141f5d09073edb862cc1d6cf063586bf310604299d68f417b170cbfc64aa2d7d309e7534a2aa0a6c7703e561fa7181ed03b1f911955a5a03cbf46c486a90ba0c4fa968a80cecc0f26e786099ccb6ef373380ea342e9989b242425f4b3fee0b73bf3a722d0bbc5fe28cd198f57d80d7127f2288f434dcd2d0638b79ee28560a1cb53d562d813ff0c9ec6c9127cb6b8fa4d411d1beecee6d7181ce773ff680b048330e51cbfaa75825e9536717bb610e1cf4ff4dc4e5ce114157896489a35cc67bb1df7b6d79ffeee8f82ead8fa64a7be965032efa483601a1fc4c40656966ec46a24828b133271d45bfcad6d1a93ed4130197a1d4db7b4785add5a7b3ebb3b1d5232e839d2f1f2e91bbeaa791bed0df39d291d3104e9e4e7705ba09f0db75e7edfce5d77d5714cf4924feab2106a741c9956c1c30afae6450f24bad145c9d1e71c9f65ddada6bcb32f242ae8c3fc6ebe981339e5498ed6cab6b1dba970395547d57297f97b93945da6556fc1c2f044e0f6e4d344494fb8846850dfd04fc5efcd7d87c3f0684debbb5072db40e15ce6300a03676e93adad3d761f42ee8502c055461939e538b7621b780a54c062c0d6377fe098149a20ad2bb1d26076a193dbd3b88270487e1e9d1943f9c5df9502d2d47b10183a8b8da26fd4db89a3ba085a53d5f6a6c37c1b87b3df99b239d09c3eb36cb9462ca7d2487d872ab7d0b5065713d8c50504c237dd6bd564a8c43c7900df4465f9866ae716df7eaa98e45050e42934df1f0a9730f711b3def621b6cc1665c47c2ad55c3c17a070d8850d8998ba87eb18e986de9412e7098cf4d20eda59f3672d4bc54b0c58a2528b37c65dcbcd46b7747785f3aa2100d6ac2e5198a12721037288692bc5a7ee2ca41bb11b29f8f6df6de95fc2bbb776fd94b0ba041429552d09412cff1d353c828085bc73ed0466143fe5d8bda2b93d99040123b90c49f93e1663576023bd7bcd74a17c179f12fde81e62b854e8fcbb170e0f5bc2ae1b34deb67743ea135e9af82f85d17fbd8b5be835bfc68e6c780fb60033e1e84a5dee606387b51f5670a1489f1c568f23919f1ff28533509bc806188f70eed015d9cd709a482bc1b2f46584e9a13a71a7db4b1dfcf77f37cfb719bf6f41a1a3bef9cb88a1f02888e756c33d187b88bba78c667c25b3956c3f354301c80b09a0f45e035a3dff7261735962435787e8331fee38d061d21b3cc5b623e7494095c63b3743888f2b2fa4f6b278bb2f149dc2f1672409bb82b4270b8f3dae237c69debf18cc487087446598e28e628dc305caa65cea8f692c3bbe3d7f0946df4cdf44bedaffbcaab5133795e894c02c1fe40564b355dfc229481201a9a14bb8e2b6e62cda02763f56d061101892a4fee8704774485ad744142909f29e66a94aa0e5425e9a6639b5c0ba0e8f41b4d9cb2f892c8067031a412f48f83ee7315b1a959e5db90ccc0a0caa83b1f245c9ab54dd3717a6fb92642eee8ea990f9a1f6e9c3beac84e357e03d4ad5fca1cf4beeba847e1a41d893dc438ef3dd5ca13ec17f17ac97dffb7485201ce64e6bb3a25c442e99098d6ad1ea0daa0d6364db6b950d84b797eb26c511538c32337cae04e0d36f19035cd55797376c731ad67e7d99bcc0ed77477015c02aa1a8477770e9c76a3cd0aa4a412d51e5cc7b19f31ce6ed5cf8007ba15ff9336a22bf7f2e89c2355400d4879b36ead08701d1cebea876e51ee57d590a18f1597e427d624ac8ffaad322953cd8e6092205f74a60c552a76ec37adf92466b35cffa01b0bfb032e487973820c21980f0d75b4e531a781a83b033563d4d226a85bfe3d957d4dd6a14aebdd85164197694c4c0887fbb911e836baf0760e91f217c59a348d150a9d0ec8ff1dc81d34c5cf0e0f3d37cc9d6b9f5e19ea586ed975760cccb91700e2b5b40138452937b4f8e0e5e4fd3a7b4a4a1d873d78c2e3219bdf964d37c48ea9887d975c76a62c360479607575811b46c8c8e99f6b75bd83797411904261a372670ef9b845470af6b417fa3ef695ae755e3526f9d3ea1539826e003c70399a0a16f6e5591d231d04aecc5cbb3df80e7aa914cf3e9fa561441f76afdd7a2c58611de57bfbb98dd28afc137173ae85e49ca5de892c31e0985c57b7a2bd9e5e0e3151b4bef9f3bc1894f87eebca1a9f68b1d7c3232eea8d7ea1d42864749f77b94241b0169740f7e09ee15d13fc7735c09b7dfa661899b087cb1168d055c426916390c70f0124c0d93d0d990d0cb9b7fdd258818bfc1a9aa8537f694051a1aca85264624d21cc42e30104dc9b250e46e88ac8ac8c877fcc2140403f13225f97232b985f54a9ec0ac4e6bd7e3bc8ec24f3467e15a0b9d3221c6527caf7af8817b87aae1891ab0c0e412008ee1fd2476337db0dedfb43e043603982f6a4070513e93553011d0129e11d6b13621e7e3f41539952064cce9c2447e6661a40fc1daa12b9cc9936e2e771eb5278d838fb30f8fec1d7f3512be5248eb113f0575797f2d3a95dcac6805a5ce835cd5c43af688d96b710786c698115fbd375c3c3b56eba205745815bb8f259e4ba65cc5e89cb459d2a6ea97145a23a0e4bd71aa79e549179cf5d52c74636daaec798820e0239d7d2a11304966db70b9d1c3db2f5aba12aab4cd93cd8a8390dc3625c25e8cfc945391fed0c545de47c2c62420963fb07cdd4795c75796bf80b9429e097d2fa4fa992eede2cb68e1699fb3d9f3625890b64848a046f59b68af3065846f08432a8e63588e579e4c4a3367ff4a8c2e3428fbb4502b47c71038459f051287f71657fdf78537e2ed1b71825f26815115abb02e865edd2d607b8dbf07bd9d077cb92f8b8b7870eaf6b2a4e06f8fef62feccd186ab910a8253a613afd92f01fe804b9eaf87a553e9f09dc3b1dfb49bfb7bc8a9af479f0d2f2576cc9ae855f215f4698e56f543dbe9be7effee0953cda2dccbc17e7e6241478fec9e56fc388c70c7da3f16651f12974a231463ebab1b7ad83988eeaa5c46c133e2903cdc19ace96f01e3db9ca11367bbd1a9b107008364288c7a0c9541359e46820280b348352bca437e848f706bffb22e6a8d70f206230b3ed392591eb23b81b6b56f95b9b69ed97461215bd89853aea86b752c2f01446b397192f80127f60f859f8b24dbea8c7821d3dbd4477d663320ac8eca5a577eb4be2ef16a251230fafaea63476a8c4fd2cff4d2cd6748a17a4b890bd12d7f5fa2c8892694bcc051b844893d0009783af2ac6a203e7833dcbf0fa20f2f0983e633db55a14bf620c4a72aa8c32a5dc6bd2a923948ea7c0bdedf2e7c115d602f49e2962317b121f9cf8e76974d88a84a27c91da29a2b48689ad95ed0519c58eb74c9c066df4bb579ac912794b6aac457db59768f6bc1a7ccb2658f33d496690780e3ed3f7748f61af16020629a4acad5ed3cf23a16acf3486487b8e452099c0e5c700b8502f398407fa745ecafef21ccc136636bf26714eac74ca879293397adf9c235b00677c8acdd0936dc9950caf95ce769bae66571c16fb9968670442dd98cae41e85090e4416c1d3b761deebe16ba01093043148315df2e797b91247815ec4d7959973a3d8dec47a28c75ce90401a7b0c4af23dbb87c472354474c8392569b5688967010ede837bbba38fea34f2521a8497edb8be4f72021b4de8e1b398945ebdd4d8661d38e132e07973c13cee0de2328270080de278d5f2fc6ee0989708c12527a9f22524411bc567e2aae6a9e5a817fcf08267cbaed899a88a789cbef1d5cefa6ba14edb2717bbc0a4e6b9b367bbc76eac18297949ca9a626ce365148ca8d7b6629a04883ca81c6d5df1228330e55b8cd68e584ced2d84e6bf0edf81688c7e7f5938e573b8ebd7d08a5148113a18d58219e7a74659af2a2bb4c49698d6daff07ec2d63fae45f6e560de0cf778270dee336a6f4d6d42f6227caef0627340e01eeb3ebc048fe498b4968e69056443ab92b1a8d58b544dec6a6c833382214ef4a6a1f67d85536b9bfcea0c18f26190681956aef6548baff0d024a29fbd9d3ae2eaabd1e67ddde8907087b9e22bca29f55389face96bca21c97e9d129f860ac843a797eb0abe522def2fbf80d027b18ffa694d443ffba4e190a7e00acd2f40192a330e5f680d5913f9d4f892ee311a2735735cc51ee526ee60d36a9d5245ab400f9c350cc984596c22e3ef5bbf23ee8592aaac9769dd827b40985054a5f987abc8f4997b9e278b79542ed141214c7708e5ae76ab56444ba68b2d261338223e65cffbb24395d7ef6b51b8cb4b060a25c1da7a6ca7fc52ed11fdee22443bb044c16e4e7ee179800bed315bd706adc48eb49878e03edc05b3c51f4aeba9acac3fc6468233bb952c14b48fe540cf92c16ddd978a38fec0546c845a1aaf222ee21d5a56eedfd9ad32e70d45556bc1de9d5ec7b2b3b398b75d92719141cca0574b077f4171e66f30d878c97815b0f92e20ab4cc2aff738e92acac2cfff890315b96e0b510188bff1873628323bea85e77928bee9fb0e4c2239c50c3e7f7129aedb735fad37b379c1a62f0e4f8eb1395a4bc9524f1ba4449a1cbf60d20e980d32df94b07991d36b10de528ef834724c92d437c6f40b5d46c9ea394b71d4238b877d4a0a69dff774c1ce35dadc984efe659687b87003d9816ab0637b4a47d3a42ebeaf96a2c4b4bfc0caa835c58287e6920fc7e6ae6e07db5f7c7b824ee73092d116c77f217cd895d3019284a226e1861706cf17fe50ffb979aece3c1e1cd6f3fef324b6577f95f163fe251d0e49b901d7bd643e2f801709c89aab4d482d946aa32f14ad6a4df5f7629e6b675e8c536a5373579d732e382899cf7a198e73360f81729c04066495e508be375505cfd5bf4649808cfd3a8ae6de6530c902ff74d35351df37cccb5bd340b8c01709c681cf58d86f651c37991573a952a3ac1296aed47bd4ef0b5056efef9029c5d3f5cf2bea45f9e5a26210ce2f60ebefb47adb6d924adcb623346c8de50ad75f4ec13588b0dd6ec265830496f1584b0d17f305d1436321ed5f52c7a0e93f455ad876eafe96b158461e412b163d9b103284e3f3505188ec9a21bfdcff5aef4b7c54dbec681827d0c6794e43122b418e467d206a49042faf4b83e0bd762de543b48309e23ef37069a5bace0fdcae704fc834959044e23621af8035704a9e1a81ac3a33a229f81ae4c4cd43a2e7567725d102970061cc119238f79a9ff876cbbca3631c3f50880daa93d989daf6687768365036e53d1153978f0ee2e5016c4a671e5f742382526fbfd7f6694facca1076cb3a2a22f8fca3ba0be0f9e82b868ce59736d5e271f13c3f5c039ea551894ed7fabc7365804f0e21d6c7c982137d22ff42aa7ce92cbf26bc478c7e1a7c4aa0f10c6cfa0362c9be32408522e9738f81a4f941d88f1c266794e7e7ee2704d5853b396c8f3313185f395303c0f44a6ac43d2f5a2ed12292033ae278e22161f69b89a88b2ef8714d9217737d22fdd9da1bc89b4cdf823e5368ec33a55b79cdbee28fabb1fb342f388b07050cf9c1e1cdfa1d5dcb942279158d8d996f2a709484e0a779f6d95b0412645b6340f7442f718a79a86b46c995741d60eaf76c701209aa515bcb399b1695a96248de1cc43765e4a99869a710ad9484f155c7091b1888aeb7998bb2a16ab1ac8a70980b4960c310769679e4357592db5284d148e9701b9343853900a22f836ab5d6f5ed5a7eafeb0fe0834794401812bd14c2a53b2b4bb2f1792cb42be2bf570b0da5bd7aade6a05e6d5a0f4d0324d8c20337c64c4f6f8b2ac15c45cfa3e0eb9793d41ccd2023b5071c34aee248319f8370a4e6c2c404ce564ff8ce960284996aa30f37542592993c6e2fcbe0c3e9686715d55f577dc4bebeeab65e0464cd923b4457086a89bf0abacfa36a41303bbf842adc03701fde729a43c40056817a53534c8566a8e8c4069ff5862fc9d20305dc52f01dd3609f7132aa705571047999acc7ff91984124b15ae1cdf5abd74c89c6360de24479a39a6074646f5fd8839fdcd3d3eececdc69f65ffcc471aa2e7dc66f812f7a9ccca61501ec9f34763a01cd7384c604579637b0eec6d215bd9895b5dddd5e2ceb7f54f128e3a95d0b572e65eb7e16df0637ba848a3f3318335de2eae9a41c67620d93e82b706672270d274167e1a5273edf63a450cffa19ac5d20fea88ed44f63f9ac98f60fdf9f5f1eb438cf9bb8008b0883f8baf40b23417e410f658f07a2b001eafd7cd00f5882d3ee97a73f441f24a446d9f347c6dcb2fae00846ae2154d0c150879f5f6fb083fd9c2beab25e89a249e2cdcf402a1b326fd926c89fb2c75c1d0b4adb75025c8d790eb57251eb0fec1036f48ba30746bb362cfc1ab51b73b7b0abc8c12840fbe68ae2aab0a7d23feb4517cc6f958cde85c5b2749049ad21a5d5a7324e89f01141a06b4ad6b08178edc84bae31ff76c8b750a6a081567aadc2a2a44a5c66612a457d439b084cd81c47f9d16ab68663dfcccbacd45ed75551160a0994fc66f30d5d82d0a225dcf65809243ab8101569f9bafd2440ee2b37995c8745515f813949998ea698a4d50c0d4513132754e9dd73f098883e22909c63b182dd277d0169e614d8c58e4d94bfb3a83f09e0f221c89da96b5ad11a0f65e3a66649e92ff36337e465a061ed06ebfa18099a28374ae3ec0d2754c3bba40ee732b19e394f5ccd59a07849d8f41e7b9bd5982019d299f0f5c2cb0ecc1716a912d6a74e5a4535560696bdd02040c3c0fad94664948ae746e7cccdc891e6c4aca550964c583a910ad3320add1dad95ee08bdad3bf55fc9e7dc83fdb6d9be7c79c9f34ce7ac551363768b92e632857c02ce15e26b2eafd9b60b146770c12f0e46ef94624e241baf2e5e6fdbea38ad1387c2e5807ba5c3d1cc12e18b9167de73e3923c3f7651f012db9f10d291c7e978c7933eb5927715e3ba08a1f8d8d161e5424b26b41aa879e06a148e8b93f059c87727dcaf99845d33015e8812ecc5a4bc2a4fc8f02c9858b618bd19a2dd29c2f568aea7aa563abc17829d5617ea93dd96a6543cb877628f31c09059a771715788ca3cfa583ce0820ccb45b59ef999ab05ea0fd409bbf69ffae6ed115635f085739d53e4ea6de783c69e563be8a5ed3e77faf12b516a0627a897a424d4773b69be992447da6cfa6d96e0730577190108d79088108fda81b6d61bbe600a891a5959a6b8ea8bf6a382471895ddf6398976e917441d9cc9c86a9775464c0505f555658aeb62a30411985a5130d99fe3768ec6e1dcd8109b8ca6a796ec40cddde9f1f39d96269542145ab769348181b393c49bf73d712a4675ab69d9310a79817a2b10a1e6ca8c48e1806dfbdb94180542f4d5c62ae64307d47c8d7521683781f91a7c80d517df40f3c7d8e61cfb7a1e87094cc6f7d79731110a5f44cad1597c5d140ce01d92a2bf09f7a8c753d53beb051a9aa02f2ba03cd6c5f66cf0a60dfa5c163751d3983e8289f0387356b146e8169eba49372c329cf838afddebea6797db7b4c4dd6c37233d0afc07e82c0ba0284b14eecc7c2512533072d94a8ab3fe1b61f2bfb2cd9786fa666112299174552c54cdcb194c3bf7d92a15c36989aa79d9fcb3e5a6fa6295fa33460d24efa7ea4899c79e9227e0b4babbec455d041fa09274611c2f0100f8b53a698a29bb047596e3c4ddbe5614f4edffae726ef2ca9bd0696eb47f016be029c929de3c42622e792648e010b568b3adc4ab0268419f298d62d9027f6e34e67ff186602900c786d56580e7f1e567439bc5caec72debfd8278cb59f6e51ca6e7d4ad0b42ec2892ffd64da5b17f9cb09daf082bb41c301616f68e45080671d6cdbca31feef2e88f5ce6245896a0e1051875420ccafd94431ae5ac22ae94051ce2a9a01c2000b32d6fe02923e09a6d4b0d15f11c30e2b71dce1e93ea9cde550a1346cbbffad08ef088fcdc7001a58ec3266ad822b961844b738b8495e9c2ba350fb46d0ce4a081dffac046e33e5adef4b4196f4db8814ae7cba419915cc62dc04cef6d97569558be72f04024f8e2adf58dd6a872050645424398d7b433c2e87af3cb8474c16728b500c1724cb625b24a85b20728836eb2d244a6aa1b3d1456ea0b530b1bcc153fe6d0d1b5823a94d4a66dcb3d45f7813b1829f002906615cd5ddc69a6f858840313d2810b3db4176b9d222e0a96f39c746415ee0a89d3e62a1f9fee7b4e5d53c65ac3789b592a962b69af00d1cd1ba1b94a30958566537f8f3d200299c54dde96603b3f8816a48dd9c90244db23b78c140378ae36f72f0c33859303678ae04deec76a20f98cd9eef8b60d6d8475e5539def6ffadecc5c5a4a613b201e7c5246288fdd37cc63795671f969b71635010bd987c02d788a182336ebce945bf5cd66eb3d410c87689bf326a44f8bd8a58b36ab069358fcc3918807c914cf982de1bd9c9198863c07ec15ea1aa2da23f159c20e281e9a4498aae61d4e15ed54186ebed0796cbebfd7227c8a21b7293bfe16ca2af4151a67b79f3432501b47acadb8b36478135878d51a96c66edcc5ddc04d7ff89b6a44fef78fef70b5b4367f2e106395379e0e35a15f1bc90e8f63f263137e79a16c2bd38023e2bbe5ad6afd18946cfc8feff33e7ff52ddf754f5f824fff2f621ccc0ca98bf0d5e0bc489a51d21dec1b5568108ae288fa0044def08b545895b80ca2d5370380ddeae40ec1759016b7264d59f43720c95d8db64226e0052e918fe49f573f39a3ef989ed211762cad716affd339c8eb1753cb410b12d81137625caf1abe55596d3168345b4a63fcab6ce7d152acf112e0a17488ca20474e12eee69d9a96e2625e0d70fe665b89f3dc084b8e9673ff55a17333f7dbea649e14a0ead27243aa5ee461866e5f270dae9242252f32209fe1813acf85afd06ff0f4b5eb01189ce5da16eaec1d855937bb26fbb2748d1ff85c02c4dfc342f27409df759a4f4ba2b5b604982cfa5f3b64eec00f5a3a7a96227b05445d12a9589d3670c0a9eaf70537b183707fd6ce3fb083f2dcbd0b5331ac6d9f69ae1ee5dce8eba58c499210a0fb7bbbbf6cf628bbcf932a09243aa082e88ebbb71265a42ead9a2288180a6c07a61fdca789bc375da4a4016072e7ea429c5ce405b6767c47f7c531cea6142339a37806138288ab4656803948321477a0c20403da9a80fd4c638ccc2086e7f580d8cb75b78c6f5be2e4b91a34bea4e9495fc165a4565b343f9b0a4f5497d928e7551a864091347caf313c326b3bfac91583a2d054d68e1c4c78948c7157987ccfb4907fcf11d5403cb33bc0c9db951b3f3ff1d1371b7def36cf12294acf97ebc6e01b2de0c7605c45d00ce5d8830585b100aa15a83fac5508214356bc49045dca27cd3593f92e5c1cd7a7028b16cbdc41aed167f2ef2a3931df9f3faa245ca23d5b729c2e5aba121dea3ed60bfd91092601b879483ea0fe51dc0c971514d8a0c4723c1788f4b82dcdab754bd80a8f83165846c5dc2c48a86f5b4c237bb08d73cdacc5c32326c021dc35eaec15e1a21139907c57cff7c320d11657a2e341c71987c795135fb9f67f48f19abc85cfec73de2c0c421029d422034cca7cc755629057cfa024ae30a4b6eed36b9d4f0c432c68aa5370cda33674af98de3c36b15444c3c3326f3a340a3f43f6c85c56fb996e55422d905d2d04aaa8300ba0a2e711c8189fd20d44288cd3d25113ace9a793042e2f7c64979625d2c69573762519ca8d892f43e7a6301361890a3d18b16a23423f8e863552ef122387860d6bb2a81976d1076985b069c08446c845265737a7dcea1f016c8fc0fb577e7d7168c5ce3aa3a51b24fe74d07e0f131ec4d3438d3d95d67bc5410c7ebf55e556e7c35240b77ed125abff6c12546a6efc3455c162ec6c3cd552eef11064d0ac949d86eef2c8f01897a2ca15085bfcd3321e7bfdbcba2392d13f0047c03e2575691131d9e488d5b8df080996846311cf40f0d22cdbd05f203025b726e986cfea4cbd7c31e1c43c57e7027e4efb39a6e3d41ed66b9b218e317b50e5fef7db9024b1ed120a40fa169492eefa41da87fb504eff40a27756e1e9c0ece169a1e97acb72849","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
