<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"87089f0b5d4cb1596b0f7775542bf98a90ceaedca174cf082da163699997dfde4958cc6cc05c1615ff02d59180d5de3541c9b7cfba173d496f4fd76d47afd8419aef59ff83c44c9529b5322a3218a7aa1f24011b38934a3d4539da1961a03a6fa91b005dc4e58225dfcd76b61b18685d767887833154e7fc9910b5026fdd4b8ea610d5cf6e5f331b9d3e77be90fb188601f039bc8ce3c7b367b7ba11dcdae9c1a1ec7bd7347e2efcb8ab06f2f2f0717fd049630ad6d83951527ce3b3ed8e1f6fbdf00ef986514f370fa4ed4049377854e73ab26410e2e66fe1d9056a06b057e3f2103b6861477b3c020d57ba8aa023efcdb55a3459adb4f4e688f4d5b520bc212e3b9f9981fbeaf4e9e41665bd71dec1694542f889b374177b2564c83f0f7e3748f9b3cf0aace5aaa0835b9d0731157d8741b2a1e7efd35423d37574557f3591afc47115707f5216dcaeb897acde38f778f6a28f0de7a987e76a414123167ce5f317547f1ad7eda41766e824728711dec6bb1958ed998f881e4165f0bd9ba6bf3226c059ae96a7ea636500be590624313a2e34ee50784dbd69eb4eadf69c5fca71761161bb9165225ee445365c29cb73f77d957f2467afd9722e131e48ef9aaf40615471db4dc9ed05647c0abbe5a2082b092861eaaaac7709b85ce0ab51764e096ec8715b98ef21c638a72663128ab7d5d894e77ece7b952833600e32f5b15084239d2ab3568ac96b965a7d233a07d695e6e3b773026f7756bbe7a1e01a66d16683830781a5dc580326834c721f9c30ba3aff9aaa5594595c22c3d5b0169fa2f41729c9ca3f7cce477cec8fed19051a787b74440773ef5d80f9351e0b3b5ba5e588efdd1fcb617e961eb5eb4614f4147113aad6c92172909341bb2890328db640c6fae760b4b13fa4ce2e80c8687122e56a836bc0ae80cf8efe9644c204d97b9d87341591b960730d5c5624d2c0b3d4bd6983c77e617223e728f1cca677b5a428b3833458816f21d9e781a3727d0604640df0741917571f27cfbcbac11a0604b27de88189ab0534a5596784d7fb728c8df591f657ed8446e83811233b5a12ac9618f108e27d4e4cf0a6a47553fab2da4d6f55dd7e5f52228be4adbdbcf1a1c1db7a8784885c240dbd4d23bd5e4698ba50b81272d9f2dd1f6dc9e64900e414e31d62a0ce67003b3c65bdab5392e9756ec8e03818abcf09e58192e87c835682ed494214482046ed47f0d4b7ad99890b88eb0fb2a4b0a517c0038bea0e82a7c72bd59618a1221e37d57d82001f788802e14ff4baa34fd18bf2ec5ca175578e1a5dcc8db851da0a7239520e6b2f026714d6285759f1bceecb4fdd38ca0c015e82acfdf2f81834625c81a58a53259d59582579c80a2efb0eb2767cb45acbeef7540d432f6171f4b232df30ee03197bba7284272a93337512568cbbab28290dbb66650da96d819a4246e5b3e6e36102138ccbeaecfe6c823a3f670da13c8baeb760e0e7d66e9a4eeccc8190f8a34d645c51c63a4d6799b332046fce627d73551e668d61dc226c5765239e1c14fea45dfb3c66de386be6f166e6f10145ef52bf5f8ceccb99a25fd74d3001533b65b0e0d4ee585579cf7458ec1ffd99cf6de75fbea24654ead57068f464845be598c3beb033054b182546e10eafbf1d6e8d4d7f977955a3b2ae0d47c7eaaf5730b1e87b12eef3a15ea51543fc16cf49997e61c93bb502698b3299ef4f4704723b7c60d06fd20ebba74e64a601f363f86f67070a5281bed7f9557a8ee701c8a33b2a0401700fa6a1bfbdc9722bf0818855fcc83c73b90f7a3d09585ccb942408dde68b6ccd23740f0740ba5b579d0712da7aa7d7809d67213afbd04deaee72e5d917d87f692924b907dab4388525f6db9a97e9005880a0d9c8e720df34c11bfb0637adae08acca0a59e9f31c76afb1d6d82b4090afcf78e0e868f14a8e81674b2d8d44923f2690c710e75fdf790f2c9422c511367cf89fdc8cd4d3bc7d7d68afb3fc18ed913a8c2f40b026bcaff2b3510cef712d6c529aa763fabfdd1a1359829755ed7c604ffc5cb66138d82b5ffaa50c46702f48fe416a7a616d6a4cd076947334b11e7a09b9be836aea97c3d5d3f6eb6f474a84abff03eab4e80625292084a84ce4bc0484cd9b16f5dd282cf2a9d639134f780cf1ec32709362d3350b2e4efe640427e7822db3247805bd9ffac16e4c39c82eea06c9bea18cde03a9145d12921de108816803d160a727badc3204d40b7fda10b8d0677a8b05821fef8ca4effde7325f8c0bcaa46844d6250966cb86454850edbdacfbbde55cbefa4af89890d51881507755c88b776d7e33e5bbdae6f9b73b78b62e1e5de17b6374d203b1bd685d384e38d2d4648e4f9ddd26caa2be2eb37c429eb2eba3740c7f8b0d25694998a3ce4687893bed612afd5a0b4b8e2c1a9d24e119a654e4a267dad310f679d3d7900d42f794c32ea8af708d8115da23ec025bb14e1b98fd294410c0be9ddf2efdea980e3a00b05adf4241765c5b994c5dabb8486352f4d937c9286a32bd8693433f3c7fb2f5656bdb02219fd840c76e51cbdfcc879a1750e86d1632ebcc3bd995ca1597a61e1ff090c59dd7756fc19c9a7e86a1e2c5db495ca6863acef71d8da6c49ddef7f27a4d2e194b29d3e75b2a89393afb6f51daf15ab9221df2d30c3dfb56d5272fe6ee298be75836a9aedb7a81c63fd2bb6a6b666dbdbce9e5a281f73851567a1b212044d8dae9d6f4e0497fd5f63c0ce87a6a9b17703f88ca25e324fbe0cf75c5b6d4cb6f75330665fd3666592ccd3043f42b0a7cb7ecc91bc76cdded965447e7b6c7886d3cf621286e0f365690a37e434c4f4ff9c902f750e0d30ed0edc1365c4fe015635c0c04aae3fa34f491c00d9858e0bc90205f99b9ee52a65fad80b1c84e6a0df3fdceda5b9f652c4b20dc56e7ec1ba778bb71a44911f75552e83c741d5467611bdd1a7497a81e87706e1b0545cd37e91c3892bd2770c40af082078d038ccfa44cbe26fca6fe66c50920fe5eb34575f7fe2d5866901e87b199fd2784c5e09f1b9c22cbc63c86733508ff28d84818b27f58f95bc87514fd6cf52f0a32f9615a134d1b5b49a22225216ba641bec5875612fc1d083fc9884122dd7f2222167fbd6a59de8157ed5ba67c88b426f6b53d149479fdadf9c8b8b79e5edc6622079507eea6fc70dd76ca000b61c4e7295dfa9c873f3644ae101b56e4c5ee473138c0d0603a7523e699d6c494cf3e6cf7d2aa0f06c4f854afe26fb65dd09846caf67d3eaad7b88107aa9a6c379a4e8265bbd71736a28764fb9813c6017d0d1f0b20814f8ac077ed0a6fbb005b307d068d078da0487166281e1a8dfccf98013ded3af0826ab562bf0e81d106faec30d8be0584c812739f75ed3207e809dd1aa8e20001374c98fd44b0b53761c20855bbe617223f58f384a917c5f3c9f4cbf1cfbd833e3c49b08128176cb293e2c8f89008c23b7157df59194ff86c72e80900b97691ac2797abdf0c742b9ba82facf0e459053455e23b5b547dbe249eec8c93b831c72adeaca0ab8e6ae35155c7af320cb7e06a78788d11c83e0dbfb327a555ab85b8c04b1536c2ed56ffe08d7ab96eb2fa7f4c14853fe4c96ed1571b02bc6a1ad1f720577cf69a7cd2ba49c6f2328d15de3c98f4878ecd89420c3dbc4ef216bb24143d3cafd65d09a33531f116d7df2b9d2f3a368fa5c9d0be177c9fe4be718463955123446b08baccb5e94b83e3e5f6df714759e10beb9ef9d1ecdba7eab2789fa38c99f0bbd609f9a534c3c496924c6b32dc46d7a21747dc9edabfe312f00d6ec65735ece262bd5d67102c757cb608b74d5ebf44037d5d39bde567aa4278d337717642e92c6de648c291d4d5fb925f7ac87e6257f031eea2b136c171cb0e2f352c203b2e719de3089c6cb3e6e41539b5a066f854708604cd787b1c42692344bd8c31f05875c95c7c904e825381496b1aa703bbbff430c966e41f5b6e4b5e9ae1cbc0d82037db7c9c5eab78eb5bdd8b28310609df4a641a308d61a487b3677fb919018ff3a1d96f91d01f197d007908396015e910a721e97e065744821e1fa4f15bb4ff4462fd3c08c4267d2558d309ad8b0a760eeef8d44b91f3e2743307b597a72a7ef94bd439f71208759e462f2185b6b033dd9a97160f627b2f20c15d33298a1f2b6628436d492214afbcd6bb36ec9f6cf522cb9e95de9605a2c0701fd1ca5b7785e912d5affd6cb41c2257b1db45fafa9adfe71f85f2db37f723cf200a4d77fec48baca78331eac8672f384efa424868c648dd4657dc76ab9db5e5f8347522d891d0b5e8ad33c93d80b8ed131705a5dd67e0813905cb5746cf0e6b4e3f8f6019bfe1bf65439ee65329d06dc3e4a62f8cd7337f34758c9999e1706721ad581dda8aae39cc6d84a948ce8691e30bd5531964354ad84466c3afa63026b9e1e449ea6a0796d90bd9ddda77f7e2d431026bb5a3058bffd3363d9bb3f6f05f19c35a2bd2ad9a07d2d2a9aa206ca7fda6f298889ffd49c4cb7274c71f8a7f5a19d517eb9159cbe9a1733acdea51c87df1d1d929ee244c40642c8a3b2312363d6d5fd39a70202e763148fb5be131c4a666dbd904e7985814a59088e4dfbe5ffd332d0787a2ab094096f4b6c1cad7d49f7374d70d2538dfb16ffb9a08826d82af58453e93eaa17a6d6ef9433f3354c3271f4db2b0399551e05dcfb62dac23c9fa0b216b1c1bbf83d28600ebef7f6b9c33688e3df5ab6f2e9f6aa60834109d3511cc48956dd720f6029527ef4c7e2405896302021ce9ec6006f2e23853de950880db643521bff7fd417a23104d2d03cb3d2e546ce7767aa08b6128e218d7d2bd58641d56eeb90c4f5072759a6af297e0d83e7bdbbd600341efa3549bcca971330e3d77eb5a1f165ad83bb755a2404fe6ee82c63c95e593edc7c0fa03d4d4c097b98899d9587a23b6d56d8b7627459cb4c5093dc5f17c4e544aca3a37cbb27b32d12962ae94e76f53e26c6858768125de78c4fa35fd86d96803f980fc2934244595bff53ce0c8215eb94613f56c8a736514fbc56d68a3a5dca5564f0bae6ab9a3f7e57a5e7378a1b824d6793985135be8f825d72d5a8ea0da335cb1593bee696eaed1e68ac8dd881af410efe0d2f82d2fb3cd540cff26cad3f55bfab0ebe9f7b0c03793a9b61f562b010714bfeec55e04905307d87db63800598c3d370dfdc346e9cdc62cf1589d711df69e5b5cb6bb2a83d85204e7d4bcd4d75f116fe3f358e258053cec797d5b9c1983de1e2cb634260f9aefbdea13bd0c0792e7cd991b7896de46731915839ede03b10fefe48a784671d59c89e7307450b237b65f6c8ca69cc98727b99c2b8cad537427731847a664a4275f66ec9d91a726171604f2843ccff1f3090eaafbef0236f4709bf06d3061f924cd0009cad4c30aa13773e0263c5f59f711e7c42fbe774b7388cd276fa688a041a0e2bb50b2f0f9b0d6ea1a1ad1c763563ea45c072d9673ccfba4bdd6b2f2ee9b96fe99f0d0430a1aa1f904deaaea664433fe3bc6140498dccef10958609b38c9bb3d293bc20dc2b19fcd1a1f8451c370a8f17ac9aefa4d15ef72a6c7f1ff99ea709a0a46cd450cc88cd50ac443560e5de571a2c4094fe97da93dc97e6c8cd628587c81e64ea470092f4aec810bad639634316d7d14683d9a18360b04b6bed0eecaacc0462c916a4c1b8fdd3c48b14525e3ff4de2ba28d6c80b95d2333cfb48c0d01aba1122a836f9b83c7d8a7f03d392b4b0558e70d0eae375cc14f01638d0c9a99768d7b83c74167f00801124a54a5f646bdbed7d4f8068336f03f0c089202fb0775ac74a8a2aa522fb311ddfd72f2383b22b5481688e1efb5bfe8d56e47a279ae443555e67e6e02f5447720316bea3df1be775f3b22fb635c17cf92c944611eba1e8fd62a398d919b54f1d0d93bd8d6e5cb4c99ce65b72d50bd267cf5c437560bf1110aaaa9ae9e52af63ceedfde660def962b5dd4ec94ecbaee7a6e551f22142326c5aaf137f3299ae9ae2b1180f75d59f0820b57568ee73385cb5ba7d547b2c8325949697024e787773a73611794d4d9dcc6738aff15451949193b1eb7ddf12229f7bbb3fc5ff18efc616f138097d68ca37562a07683f7af40dee983be9bbe81ed070999b372ee9bc44567e738e64bcb9ef38797d386f78d64d8e78a9bd7c84031931536fe8b230570b00f8b6866d75ac1d61e9d88ea3a9fbbb0977592e8e896da2a913030b8b2ccb73438efdde8dc62ac613e58925426290bfb729744c7804b1e5e978133e232448f474fb0ce7095e9c1ca0d85e6dac5da3b7ef7cdbcb3e09f362dabec36c972b593ca9be6ba525843973d0c9e454624b0f7daff6c4bd01458052820fdfd293e0b20f7f1b5dc4c519cd61c284b02b8c670612ea82c0b695f997a5623f9a03a1459b2e86094e9710d647d03a7eb2826178992f2289a76148c40c4c95451effca22e265debc9b888faa0676d5ae6ae8e2306a43fc01caef65c591b367000c0eef55b1d8f57bd7ab853c73ea36a38ba773305364a324428773cc56c555103fe6e52e36ae4b69d0200d7ca5dc8af8a7c152b798b6bdee13f8eb2888621f678f70940119b4bb5e551156b8bbcd5f76742fcd3e164308b4b21da78aa3ff512f234e4cdca1da0f44e7ca2da919c41af712cf9560533c730289614760e4f78259b2aec6eda05ec15e81674d9283d49b4b4b7e0abc4a5554b0e1e5ce15804bf9d6f0197716993b32e97e43bc2173c7b51afe10d3d2283df80ead955ef836ad1d198c5b0ef304814517ddeb25e1e28f506625ed3c7f7cd92b561b570d375e3f56fc3899fce01528467151ca7ebf42b2af5efeba6c3e9d99e1ae12e11da66c848512ff357dddff7022e2e69b0fec9e175add508fcceb621f8946bd79030f0f8f7ca9a381bed0a3ce4704738bf68a8b051adbe42fc7c5836cbe7a1d2fe488fe6607be2eb25cb39523f1f8dd2f6ada47dff3e171b18d1ca71428cf91ab43c708b6b5b9c774277376973fd7f77a6d5b98f73ab1c04ae0c4f49e14f22453c8db6d2f6df10ab2d49623c4f8153f4641d976cb91fc51e9deec690951a8a51e2631ec411be88cf0987e904b927fc1c61ef91c7bad0be5ce02e7d38909770c8af101b07b8329ca64997248154cdf9336fabfa74e395f164fd23b827359d596506a23b8f4aeab8de898dd3a046a7cb8e401eb83c711f1d59eaa7b7c2d465d6257cb43f3bd2d2d98dbd3f1b97c0b3f7dd4339b65a71e5e883426614bf6d256b04bedfd9454970e11652e519b455c677b6f3a9e4dc2eef718cfca7fd0494f0f68ebe1f9087314eab9406a697f5e586fb7d89b366bcc6aae34cbe2c2032f480a6428ac532e6404836e191262d89ebb333fc8f1b818e528d397f45d884c34ef1fd1991e6b5bc942b42922d69d2de60e26a2327739f1413670376aac3b71e74531b09d1354ac298ca8957c4dbc915bdecde2b9854e657fd4256eeda5cb1a227531215dbd04e418e21eed551b96582cdabc12739778c246ddb3f36afd312f2c3ca1c1a9cb9293c2bd0d99cd1f6af326207093a56ff0cf10ff493f6c2e3766d06f7233509b8fb3ecebe954c8f1b7120e805b2335c9efd0ffa6c823f1dc9acf50e7d94474ef1e79f98bd3b8e686f1b65eb95476a67c778ebfd264be9291c08692069c2899420f0b443325372d460824067c08bc6a816e6e7ab319f51cfa0dd46a6bd0e2b1e137da055fc21761afbf8a94b8a2ddca8db67206a76d955c44601413727f861f0400180a02d0beb181ec043ced0d7a4d1af8d54af60ba453bf1387585a72e2def6a6372d6613293c0f10cea30a6b1cd07201fecc4bb85f509b863a1918e6a3c142363cea749dcb8a72a5e766d60f2b6c9379ab42fb8ff4e24a296d9ae018b5d8d26c46f88341f1940f299dc9905672d2493039d5443eb008ef9c310d5c0d007242dc463191f065edcae0a0ebb73833b176e8b53574b2a9c5b4d2d4fbf7a55ce0e195cbc2db03f913d3e2086642a2c41eeee032a6e9dcd95c32a38a05217ab6f19181cf42cf3ae4494245f1ecb8ee86feee4e336e28b25ed0cb7cd50554d6f007e471776e96b0927cc9b4aafe4d4fbf47e0182977e0f8ee52e2803c5ca73d136d6cd6eb5c8110d30fd8efdbad7caa46625ee8dedd7ae5917439f3185abbcda6faa6dbdc3ca104ee915969535d52f88b64a0722df7de7ceefd07cee720b36d0dcad42b1b5efd323a5e7f444f70b6433382f8aa2b61d0a0cb570b66237b649a5df653a76e6925c47d7471b73ae1f42012fc33567d49323397e2b6c56b87dabafd0d21c6e42b57058ee732148d839ece61bebfe3b0c39619852cb3154cb444aa34e0f14c9868be11a65770a5ebdb961197b1d488c8afb2b4160dfb23b9b2772d4a4607e4e3c8509cef8e64454b916fd4d55f57fa11652fc1ebbca7ebfca31088b0c952cb4266b757841f95520f83de71ffcaab27745e7f8372b7365556bd4043551e4faedaff17c789f98d4d49451e7b2dc93ba51607e9d4849d07792c38bce7c89d28e419e92fe9512adf57256500766a578c5a12479dcbc3051b9e80a38f0b16277b2eb38e11e96c04592d02382d3d48b0a847302e21d0c8bfec14e40c0994cf540d168d96a701ed0d0ef45827430637d469eab33b5041d134f855299336b2779bff6e0f71686d9bfdf98101ba8d9aa773ad2e7b8437647075bbfb8ca9b6de2c4befe31f921f9bbc36de1266dee247c6ae443ae07c6259aa67d378c77007fadb229fd3d8b7f2625540144349d42551578ec8f7959bb99882de7fbee4b04628b1c5fe0388fc6b040ff10f7bc9fdd1d09f76c040ca20f1fab206bc55eea4cf198f3a03741e48c713456d1500a63c5d9044fd0d48c2aa5ddf658119d39ebefac25e903c090e77b8de2297225a26dcd6b75ed91d1e529e9e9d446571402750e4810e826c6abe240fa3606dfbee437f832334b39068a1b55e0411b4e7db7922ec0d2e52a33b20b0f992b392d687beb6c173306dcdf1eacf1b2bded4564fddc0cadca8c56e936794fee3ad5aacfe3a9c32727dff0685d861ca5d38d22cdd8adb53ae4f8340353ad398e2cdf34c01417f8978ba5ef5b9d640bfe2a335e174a5e740b5565af129d63075ea3cbb5c87c9a9b233f65014b9d61bc8ca2750f321b8c60b5bb37298745e99aeb979a81431aee5c8df308280f355cbbca4519b9b8cb98cdf42333ef8f97ed2a3f177093800e072a6a478144c3539c4a2703210c108c05999e9c020344d828ca85240143c667ce7cb06d0fe74693d64a21a363905520f24ba671163d896dcce0685acd8f29041673b062c9261ccb8e47689fc36f41434efa31422b23356e1a7d2d013a4590f2a0c1804ad0e9a30ba1026618c10f643e2ca59fd813818ca6850b6f3a744cd5478761fd69cbb9b9a497c57922ede0cd69a9ea7df5165a4c70cdedeb843f9484db3bb915bd9f6e6303f2966b10ba5f22f329acb24604fa9e975f3048e3759b7da9920656f99a8d909e95a51af3ff5346f35ad1462a0f17067bcf08490e23b2ed85b605f921bd7e6036c1b608afe2d1b52fa5342fa5142c733222025a6f774c42bf1ca42f9b765e6b674d592252e301e0067eb8a55df24d53548a3b7fbd67b978878f851dec070cbae711af67c11737aae09d99a734361a12eaa0a2781543909d009bc6c07ec8d82b538decc74656c9f8441a6cce60ca37216cf72a7ebcde78443b69bef132b7afb9e6a0f766bc5975da995bc7e5b3de3e1e70b741b551fc61c59cd5f3ef3a89876803d0fce03ecd21f5250e5ec61dea9e6ae548be27337f6721aff63d5383a7b1a95dae207618b5b3258802f094207e267e22c10316a3e92dfbddb4f8d31550b971473f40e1d8de3f7fa2c485355ce0fe4ed50df11454a69d03f9a9574529e90260daf1858de15c2e98fc15c649e1689f3ac47b3292723b8cbeeb204aa25c2858c50aa2304ac9975fbd03c64c6ed3b76568be89014a163b78cf6c97ce9f7c502ca9288b908ad89c421ecb999d2a23ec9ba5e7e9a41b50672d97d2c54c645006fb53e90dbb188fc6bf6517987bc78b249d9df4cc0220ece693604df93ea5aa87b4c807078ad8990f03802289a38a0c528c890a629839a217f00a8cb72421d3c918dd8d093d980ef7f8027ff71d75d1454f6d534af78d708d22ec8b05571f82380a49f083b628defbe4cc9f36b4123b2a3222482cad2c69c324170be3c32d3695dcd370f378d1fc20272f9d36162f34fea3dcb48efafed8ac6cf53d727df10edc26f0c92387f0e9be7542c75e2f21c079e3d0c20468802a8d80ecde383e48a79bf198cfb27141d506a038e2a0490aa247de3db65859317fc59895ea6218735c94fbd988107f3e33744cb099cf4df80784e4336357bcf1fc8680f2430c796aa730af5b2e929df5ff85020efb61e10cc7b78ae498800d78d23b1e67dcc289aae54b3f1f238f371226ac6bc827d966ee5fcd2ea5e3d5fdc17662fd6fe302006577899822248799ec141b16b3b39ee05b3a3a745d940b43897e80fdfbb8f80ff9fba3a3d358b0cf9b2ef0869c9a37f68e2993b97e1c9a1f57ad24e32be2d06dcf65e1932d71b7b12a03398b428e8ab61759b63466aa5301e30504bcd0f9769fd853e932d4d88477cf71ec3c5cc4e0f070dea1579b4bbc3c0a6955daca5d19e221c01b9616571e8eeff22248a76dc960a6b887a29274f61e34cc4b30ae8ed7507b8125459f84de6a074b584975b8acf4524dbb6f5589fa613f47ffd6fcca3da8588198f0004756437a7f55dbdbd0bf6845fa1bb99f90e76b9e733dc506f2062d0f22b41c472454184195d43519a0d3460811fecaad370a2cfe8d031f782572d87c32d424e2c567033b991a7ca1531da64cf9fda112ae3cb1b163a0f7be4e8550012cd627b0a4dd84626e3093c666d1ab091d5822efb358df713a941afa1a20db0f74afcb62382326ba53d9fcf0bacbf7b1b789e7298934802165fcc6cc35c800997247f9925b1e11767437e82db2e80aa94c8d699a3e4e055bfad5a902d6b14c6f94f09a35170dc8e09047e73acc0deb90b46cb3a23c865215d22e98d9ae0ff4f2eaec3712b62ccba756ba9f9ff1c358066fb5e58630a0cb2c2dc014b1c8cf8b66230b365b8c2fa8efaf4901b2c67f144172e718d8982f6975c4b69618129130d1e0b2c5a83f2f74361661aaa7c98c2fd0b23c90747a4130f71c9fd43de7f7ccfbd1fc3c89db3eb19e158fc967aa15102fcb2e88c564da223570fcab60f719dff68ad685bb2257a99e1e809d00e43b8402fd125182fa667df97efcb2dde99f8b650dedcb9ec9dcbf327fe5add16a2a7f5eaebf3515d5066b440881f8f0e68948457465b5a645f96bbec8b8b7d1d22136e055de6b3beb443511beeab3f486eee0e70191d940e27e4fe9583b0027490d6ed674cc744f1dd7a3bde1e538b7db85750f27635faca41db56b22136f2721e4c927ae8b7aa191de273e9fb88e8a352b0e589bc90061f06cf0d98ff325bf107a5b0ed5022720bb829a86e47ae2f4838dfcea95a2d592b80fecb9f55ab92a9ae581bb646be85db078d5b1a7486e8768d5924a5b96eb419d42deffd2e8077aaf04df88dd216d9c75020b5854195e31e6756d31522bb3bbbf16f0f9f27369edb75781dadb5f6695d4ca1dbacbc9257e066c5e820805a4ac506769f0feac559a2702429b319fe4031258123b839ca8e2b11e8888c900579e708408474e5f579b4f294e3cf6366c125894f09d3aaa0ed7f2c036e7e9c9250f6ff9d067b593121f05189ba62573ce3c0b1d769a73b95c9599d359907383b446a21cbfbf7f49372a2ca624b90b96e5854da9f16e588d24330f1aff2f65d03e072c2106626c4183ec3948a18261d8635bea05b8f3f9dfade0cac827a74ef1135f237880896e8e21e9a22e6077bf45c5e3306743589d02cd5875784bb1b92562bd902c457a4e388da59b86ea8a39479d1e7a2aceaa423b4380a24b01f89ff348525257c188c3c650ebfc04ae0b0545218fed6dff7933e3118244bd0283e8ad031a22bdba1aace4d2f369d43930aa9b2838c42dddc682617132bfdfbef0a6e4338055879074b99049ac0d841ffdfe22683fcc30299006b042d14d511e18f94d03ba4847d659287084f57710a8779a279a5c7deb2614d8de874fde408a49f384bfd4ca722f94f285301419bb5b32dad8afc4ee80ebb55fccf91d277a6eba5d2f5b76e1663b0053bb4af3ce5464897150dafb4170044c28a81baab2fd88491f27f514b148111b965ee9828c84a777ec6703ee0c57e01973ef29145f116a4c439884711daa83a3335d4bde4dbdc0c55b60489e7aa698be823c2089e5ebb316fbf819b7ec5b33c74f336f9009b35e831cd68312d5a7675c75f10cab66cf3061b34ed021207fadf0b5e1f1eaf7c646a123b3ec9d92a71675c97033e4bccb2bfd5ac611a5010ecb5593fe7f9a7671d850a132360c58c4033efa3986e64847ccb38c61db3055f17b2dadb04d2e5388f3e2b986b1e147e337bc9bad4f987e62a24e1c4f0c5af648e165ab8579ca46c1fed7e211f11ded60b97a886122844790714e233a75a5826a1b671462d8afd236acbdb4e3f7aadf31c3b3b461fc7bbc06095457da2bb41aee36d8b62c99fd4d6afe95aff284b38f382f6e1a07e0d24132734c61c5608ff1554daa5631dab85470123119e006eb69535e1514a804e96e86ec6bb1977a0d1312c7c3daf5f8d76744c186270e5063075e655557322ee382e8e4646f035a1f525e9a0ff226c8f997d51f77b7d1f902b6c9de612b2dba961e08ed7ceb3ed7d09cdf2089d2bf4b2b1307a160a07eab72b8b536da74eda713901ab568fb88aafb53c4ac46844b0304bcd858246b36bbd69cbbaa31853eb5527eb14091485964af922e7f66d70eca9827179768e2c7dfe59474dfaa47798f78e06f21545704e4823634eb8146654ce3228d89eaf4737cfc708b0c968800e7d8f0733e416e98956ab34ff1b2244bdba930b5369e0dde9ca623a7aa4c16cb3986a9c4ca89876d589acbcb97b5ffb8b1a24a2344a8802f5a7d2d16b1e610a0d25c56e3d224c392c754922d37396ea904aa36ec40c90df994095dc839003c1c9e8cb001a546c9bdd4d5cb08deb191181556e46e88422e034f671d200f067fc31e553fd511bbd73321a538f9099a818e13a5b40da2808abb4d04125d8f8e88132ed30b6bbeee14c044eb7780263a506bda13a302dc741a496efafbb396d4cdd7aaa9c2c918956674f5baca9e13eacefa96f1f4325ee482f523d87969ae11372bdf1aab4d58898b26362d3685f362a8d6ec11760f020384f95255ce7e49a463444ee30694bc5e358b07cf6deee5394d0d6e8f9594a643c763a29a0a30a80e84e122d39e5399b1b5d920b1750744754eec80d0235476d792bce0a9fd44f5a7b2c17c26577f4208124928a94d20562c2563df9925321be59e0dc6dca7f63686c72bd0d0b7978672439781e1d2833357a75ecee647d73baddb91822869ef2bfa3c4c5d6caca899a189622c1a7017f0ef1982f5c6b484c296c3fd7109a34fd2dbba7b27afe76e4f18b7a7eb5a51d2376a37d2afb3a29db062072488ed16255ab7e8abb13c412cb3bfd9f2834b33571840f78aa2a3a1e7e0d12232bb3b7a7c58d9e45abc8d2e684a373440805319988005ba9cd1215eec0f2fb319cd4b3c77d3f5c5eb40a159833327706b6117ebc4e3468c3b9500f8bc4c915d3a6291f329c1957a36980219540dd44c9f3c5e6371c7b0d906ca532733050ce721db21b98f3d7ffdbd395c7300c8446e787766f750c59aa7d0c3b9dceedcb9bde6a2b29af826396068310fc6d12fdb233c44c6b3f44593045ed9ffb822e2869c2952896352ca7250bd1833b83184e0ea38427d72c8ed65dc2bff471ad74a562cf3f10a90b6337a663b5230f02af928f69d2313dbb3034bc58ed465ce417247b1747a3e035819501fe96b330c945f2a540e67a49c5a7dfeeff98173a94fb915e6e577602536b2b63b1c4ee38ded167293947affd1d4b7f374a4c06188ab359e215d78052dc6a5c866f8b31fd03e32b28103c6f17f5b81bed99b63b7337c90f03f5e4448cd35668941dc9f4e1e38485477138e09330380ed2b46a9cc4f609644cfc61bcda89c0b0024dbd19130ca8df2bb478eaa9019ba518763ef34d4e54ea3dd2ade9abb77629e1c347dcb40d87f4c2ad29fecccc0b42500f1054eeeb18f87bfeb71d99618302983f3bb8265546d4822b4277502130e776e081dbb04e8a4dac77406324932d39bed91965b952fbdbabc79f1208a495ad416e5012299dd00930cbcd1e0d764255a645eec35414fc7ea0d7d71bdd555973f7ad008a782436fd58aa7219b5d575d7ec9dcd29163f9c6be6a0247fd58b569a73ea86b4653a5f5acb989de812b20628a9cea6e24c852f3a66a2b5fa526ded70e7e9b011a518b01003ce4071b587d4f3583ee449bf12de9950577e1f1ba7e20a0897b4191a5aafd64aaf33946206167b90855ecea748904a3cd0e29ff1da726148530f49a561ce20cbe19e11ce242d84012ce0984c6f8e5acd409524c0273d9200ae55ece52c8116093eace6108eaf7a4ed1285a8f9fe008cc53808810e7424c3d14f40cf2a64acb02245d0b771cf1e256e577f9daccbee6837b30975654e0e8cda712681111534a715ccac877874f1e00aa8b66f1cd65566bcd4c2b733baaad5f17a1091f41e287eb27a88e78a5ecc81920c2d172fb2d109736f75b3b4421151392431b02743a2d16c9960f3dd44e2822f9134de5a50b7c771e1d19382ff52c093f832ab7a893cf5b7ccd07a10d89474f2a356543c3866f35f672586bc989d9ea3b0b60efe345600b14d5a8fcbeba1103e6524ff4f22a9c265f7313ea5fd3809be76dd4290c61f84bd373ea7ce0a7f29303de03b493976ea6fafec888f03b6d518036b85e91e5bcadd6fd2d40e02a3cde69b55a614da0d1599ce1615546c9ed5d0aa6fa6345b91566bf867b2bd93d5dec9c0ce472978028996eeda37c3d820eda101887fcf2fc1da457dc1d7ffbbf4efa7fc694b90f5d0fd91e1432a7ea50d5b9785cb8c6e9f85cb0c7a05eadbda9c5b5544c1a3ce5f9a02e1e6ae392e36cb439f6c468b5fd2d3e23711330b3658dce64c4bd6602877ae4a977e4143cba215abade07b306a3a8669119230c3442f88c9c5d4a7bc1c35abfe8e71f69c32e505eb425fa1ad70efee5577b0eab87c7b80d9dad2a97873ab22694bb9a8348dc420d485981fd94d4b7d7540ec7c0f513c2c11c7e3faab05e3acf0808e85e793c8b2f1df0a82dd967208fece321b262c18c68fa967511cc4aa9cd45671e6adb6bdc0343259203c02a2321689168a4ef1509ccb0a155c7cb137353fe3e7f56e2315a478f918287f39d615fa44082054913293099d9d4a79059b4dd2e39fa0555d92f691394ad4cc0c8388fb00b7469df02cc77c679f4b5befd2496a99265c1f7d317421769f3c85980f7771ad78b07010c6da3cb9aaf2a8b9b8730b1dc75f30625f796cca12f915ca989b13b49713bc10fdcf69e4b5f75dd92c3bec48233905435805886002067a911902a894028ce9e7b5b075ecc09791091813f417cc27d158282f77b5f7036a1e993799162bbc819557f39121a2e806fabfaf44c6f24a1f3c5b28d0ada8fe88eedd989f65d7b5254f771bf835cbacc7a22fe69df32a59737e1d08017e355fa6fe31ac4bb095f051a39e4e1a0dd94425a208afee3069ef8969bbeeb4c9f2b4992be93a2c518455c2305a9c580920e769da8e62a0c208278b4c798af60e02d38815c636c19309ec00207c5b9edf036deeee18de511914f716cade772f0034eb2abc1a6f02de6378d2cd0c4533ada75746af3976711b928d10df3a7edf5b68c27d0050b5abbfe2eefd0274b301df52fd644a3f1b365011d45c77a012b327126ad831c07fd7b21410a09d0018e1d8c029eb668d7f9fc8448e8b7fc5808e31d748b45b74c2f47fc51af70a4e5d2f8c16d4d4cc6729951fae9fb352fc0aceb78aee1fbf20ecbb36ba56e1b27a915f74f37cd10369028c7f17d39e66db149f88c1820688e3d237206167f45c473ee50cda4f1cfad9d72f07b4174f902254ebd94c90267801d362ba4c68a077aa702fa1ee64252cc6653e24b81be36546df3271ac58d3c9681793ebd9fc2edc584125869e21d4180a49f94e157adea9dcb20813fa51fc411285dcc2ca52fdec12009cd5758754c0ea39c1c40073df51507424bbaa071c03bfe9e0dfbc546105fba11b2b4d23f1669d896bda293a950fc60bbc701a59e5e2783a28d9ad99b1445ae08fec950f40bc00ed0628c2fd85843ee0b07e7708da37594bd6d9b0d7494f279138dafb310a486d969a330bbefcc45f7e9b3e1000db8c2eb959a873955cad5a3e3e8464515bcff991390801a4b0300c21bd527e116321e7cdb276469c95729c2e828b2d68384518898a4b7ea0f963a0c41ebcf5acaeee6652c12a03d4474d12b2e9a7a66da97c8c57e3ae76b0a6c1d58674e877c10d122984436ed358e67f207f335284cc6105bb2da45fa3970a1ead096939f7db54c4404593cc99d3b9e40db2077d162adfc2b55af973c920b7ad4896fbe8475c2fa5340a741567a07dcbdea2d5b3c3d1d4273c5ff0425d01faa077b0c4bffccf8792d52cc0297f3d72a4db428bd2bb95be5ee2c11e9053734477dbdb8154c1b07f835470a121baab108098e9bc9913fbf2fcaf78c744916f4961752fcb40546c093d81fbfa821cf9c3b68b4b9030bef54186d74ca854864df9e51444e6da7e7a8dd78cd69c6fa46dbc943c97de8dbb147cc32a7405de584384d60adda6064c3cd8c08cf00f8839d6ee57f7a5b0678a61c8f3642794b3d827e64016c7f2130df13266d75383c5c769d54d96b83f0c82421d5c962cc529cb2d48f30731b363b82098c1a43856870ef904d982e0483bbc46f320658edf64290801382f002dd406a2756b789a12b0122e86d7f8f9402b9b4121bf98fee58bec3dfd608bb98dffe04f4ae618abd73ac0bb30add27bef070783fa05523e6df385ac905c97ab591e3095270429f6ef62f161d4b2290ecdf5ad5ee4e428328fb3db0f1586ee7e1a31e4d46a2b51515dc21f0b98ea9c4e5cf46af0e6c385fe420ba950e45642a0accd5993d7847ac5b0428c82a5bb8ec66799761f5673220630c05f56cc7343afcba40f8b6926efb263a3c02a3bdd389d04b4ee376c4210b539ad8bd9f7485bfba3e03e1563de9ab2393f9b1f3c5f8e621a35e9048e8c1be93e6fa02958db2684359db50ec0d009a7781fb50ebcfbdce9717e77f58107dc57bcb2fd44a52ab295a1e372997cb5ca8de8c3e688fb979beec77ea94f55b639a341eb3748a9e12379a7cbed9303ae1e0494b386439f524eeefe43482819b79481398e9a0f91257578c6de7e617aa269d2f11967a6795cdfb87bdf14a4da99083617102de50de93e106db4840d0b7011f8d1be6bd4c546062705d0ce97e5da6563075688eab25024491b12a029bef5614a5b0b2b6b7594c77acfe3e3abd1be0c005b6f7a29b88ac9a79964641aa4709f869d6469efde781bdb21f7e321d6aefd0e7523de58fa7215363f11fc3d4d8d6b5f3a30211dd40af80bc5b0051adb9b5c0c4ce0f0afda250174c6cf37e2da81f357508e68db269d41bb4265697b276aa43b8d52830d2a524d73dfdf32ea3ece78936946b46311680e00bcbacd8ce32c72c737c3655cf3c98073782202f4702127d2a17a5598e3057173eff8380bdd8ffd483d950ab309d820587e48c7fa5a3b9ea4226366e3ea54c44abe15680dcb69e79035e6bb1c1d17bfef0ab689a5579aa702581294a35373fee4a1f46e38788e2953119a1dd140430c9d37a19c5735948c46818d76bc4509447f4355d9a4f8d7d957e02fd612c36bb359e8325d5a7cf9dd9c8789d21f6adff79a4dfed4f3ac9265d827b3c3e1ff273b4346441ec21740d64e63fa7a0684736a7be584c4e74c13485bc4893f40408ed58981fd4c42c69a3a7493d459852b3171e3ae94c89d6c0d7dde0bc1477e12672b08f29633642921cfde6820ffabf69507a194eab191751112c66f8a94bae1d37e15baec9ee4570f778f65af2ee09ac99bf3e8d81fa2a97e4a75f43eb6d85f156ae20df94eec0a836d6fb379892ab60e7486185803b9d14c94ddacb9e13bb0272b6112ddcae944fd5c22e9ff80edcc6b44abd17bc976c76ca4eb8db0b2def8407e7a63b4f26bd7cdc94990b36e05d1c0bfaccb53f54632d599bdb32b9c14729a09f82d95778e1d9a6c163e73bfa2e0d66326f831606eaaeb3f867d0867d24265b1480e08e94bd7b3f0a4d68e267200b5f2931f1b8b5941f44e767b72e5c884815f239ed4ca2997df02952ca1ee8f558353fcb6931dbc39401a27372ab963bc8fcd9cef3683da5d0150e1b7b96a407346343aba97b1c486c43785660b644093ea7d86ae82428e7800e9d6a1f6141e86e060593344bba6d691c01b0e6e4624b42b2ce6a320b29ca522029526590830f314f87e4eb7d96ae6996725a8adbdeda4f673af591ceb40c82cbeda5bafc1e830c4039ac54cc73773dbd4b93712871aa9481d345f4afa7e30c0f6d51cc9a0e8489a70f95d0d8a2466d5d9716636a752c8710f6a04d05d3778b0d501f08da5d12ede147bdb4b208e89c9bf961f1b1a74d6f00cd92ce1ea931aa9cdc9c82d8fb5eb3d3e20818c2acef4772912a165ebd5aa213f69d0cd035ab359b494281887acf1abb3c4f8d188bfb2babf22700184b04958d0903d6f9be098b7b3a14c35c053a8e78b5c3eae03dc3e8a89cf007a49000566bc0e00f8d22a656c751e32fb60fba923cbef8d7bd09a43d0272676902007a4148705d214784b3849b53fd1c7e7efe4940abedd296ab433780b7f28d6db738aaf6a6d2b1f9f5d66a514d0fb32396cd9dade5fead861f951c973c4f61184c28afd1e86cb1636b9474327195d5f2b54b9e3417661ccdf44d6833cfe4edd02894d4221dbd830de5084b257dc8862ae6db580bd42abd1bcca25bdbf7dfc23737c943210fc94759b026ebbcf6a601df2aa1fa4141ee5f2e452bd7934379584e03019bcf4cb08f0dc764f15aaec304fadcd35e2514d782b25feaa7e7c46e32e8538667f571e97355777c8deef782063c445f31cdfacc6b9d03795de28e4023a100e664dc222453764bb58bc956dd283bfd34a82b1c503917f4e5c8af440dfadbcff991d60e1a6cd4555f1b40d22cc835055506b82fa5ec858719227958dc787d3cd08166faa53913ec5f9a67b6339d0ee1686bf49b44fdc734e30aa413d091d204d5139f27a35834d7e7d97ddafeae184e5d558253b0c003fb53656027c196539ca099f708873f336c56d24e26275c3f7965efdc60e008e64b55c82a634482cd0a0e86d355eb651851c730b718507596d91c70346b8ddc2ee11f8cbff40d4b763994889d6aa3ad9ee4083be1b66b44a496c4c73311c442458b9aaea10cb97e90dfbd071093361fd9f899037345846d1bf1bbb3f79718dac57b870fb3d1b6dd598aac72a6e3660f26266ab540512e5f946476658c59e46668cb3e18b121de3a52caafc8e0342d5b8fbd53409e2930aec441d938911fc56e1e10412464be5c3fbb64a80df0e8a118dacc8b2774e4c47c255f119fef4f8a30737ba2baba92e5bdb8e7b4eb8d70a296c777e3127d08e35e1ef4429c2591598c2d05e76877967c6580afbb9b486a82aee731bd1f1f64897a663b7fb17a692560582e719fd8b86176154d548f079158bb15dde9086ef9b506111c1c9d0fc2648e3c145405c557dae50439bbc5cc95fa861c0878e32ba41bf33031948df914cb2f97d9b861bf09c9714ffd0ac26bc5a1598d183d586b3b41c138e0e539dc8ea4c3c91374a64d6f9b04c57d58492fbfd65a063c6d0486c4a542648f47f2decb7a01506e40e291fb585108ab2d447a7029728c1259c1a6ea1b480118945b26d8ec0543cd5859a0aff05be938db043779546d946036853cf59bc28db62ed21973b9285d626ed167ec55b38ef3a969b0e18ccd9ccb0955f7de1dd29b41bd81bacbedba915151dc720816ed5ff43070c5c87e992a480a26846140b2fe1e1891d6be8740dc5d8fbbe134439cb285ff48c7f4c219f62c6cffacfaa2ab1dd6db9e795494d7c39c8c827b55146a56f5adedc64499479dc7dd9144072107fff0cb84074ce9d5abe90e7b072dc0294c27cf65525257b79085e3e0624eff46cb18ce5edcdb560eb0a7dfc282b7ee2a0ae79feb4573f159e8ef27718e245467b71ab160de98862b75faa7b3c6dcf3c90ca8f84dfd3f4df0a261686a496346e50b657416673bdcd72a3d3cf89d5dd3be591d47b252e40ed0c10d62d9af325b3d5003974db3c03a7bd4e10f1365dd0bf44b0e65a6941ae6b3d6ea86ba6d777f768c2a902d9125ec9c86f3e5ce946345515c2390bb9cf3c4f1ecbcd5f812f55ba9e1868d2d701982350b5c44ee0d1d5726b523870f27ea4b1916ffbacd52df8e937831eb25bfd7bfd8ec132962a269596ddbf1f111c0b356c4aef2213fa4643b8d9d793c914224974fea5878357265cd0f0c776676743efbf6e65de8a263f8c667f032b32cdb83d50a81b62cad0fa5e09daf0e5003047a00e2526a9c251610a6c008c9a73d9495e387bbeb8779d7acb8a8bde6e530b325dfe93678a851587be44c7c3e356687be2564788fe96b618158968cdad946b90303ee2d46d5ed4db2c77b663679381828769a96ef897624f697e713d2362fbdb6f238b4519a90739f2978d53351f01f830175960076c7e0a2556dcb763672004642f367707cd7adbd0ce6c26b596547d63e947b77c4cfa9d976c48a8820ed235a00c65d5a7251ec07d108e5a022dd285fef36a55a19f55fbd99882b01229c48e3cd0443994e92d25fc2ad8d371585a768bca0d710a37e8187a5ac3ae4165661de44e584e77c2c5556f893d0f66ccc1ecd0e510a5b647310d1e0e838e480c8a53d61b79aa2a4587734704686e9c5d99a5332fc72df00a4b4c6ebbc460ebf40e8e1eac4cf343ad62ecd8520cd50ce48a63f851cc7b05810c7bbf4f11cefee105873978167fa913e2ae364f797790e070ac963b67806913a7c15491186f9490bc7e23576f2d04f53b52aae99016e837e351f02d13f33e1848e9a1e7a371c0e18948c995ce2a94248910b46ae37bdfc949e75c3f57d03b65cb398a0f1217e4be6ee992a28f538ce9bcee0d2af6f7c0eabf290357889c467b53e4e5f43eb19de179fd2519ffabeeb0d50c67377fde6ab6768ed9b4d5ae0c1c8244d353935921363e2af74b854393835e0925ff5760065a391f9b744ed73872e5421c2357d796887a25df8927da85095f31730459acd11d1994244c95462f7701c29f568e1fb02499f2ff9b8649708dc4e85580aefa4d119f3e91b26c8eb17bbd53c2469eb904a7f1ec5e","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
