<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"2a9ea191c2dad160bdfbdc07e2009ff5650e6f42cba1ca6aa3166a36d919fce7c46b3e256781585e17194d3ed17fd840d18171a077a4bd15554abb20d581e7e7126ceac99a061373db765f7dfc9f0accdb30c494082e546fd092b409c7127052b45ff26cf550fd356e5cc03ed787bc5ee794b79378ed95cc572261b3b920fc3cfc3ce110753e85ce4e0ad9dd77e4850f5246ded12c9e8be0e231fc813ea05890289bc11053306843aa7ec0705e4256346b41a5f109b3b561e65f1c2abdd2ecd26ff99de3008d66e7833e5e352c1373f3e9258da10db67519ea15056d5afa2f53e215e0d5c0394459e5fbcd3e6e21c2567da6c9be47020eee262f2b56cfcfa2919b4fb2e35a107761b1738d08e4fa74ce167c630ec32626ba2d99d436e99ae23abc2846759ebecb4e459b35e0d2389087cf3bebd3fbdd8969ddd21920e3ce3bbeae4bae51bb6c054854b32df95829c95916a19f135e1cfa83f5afb556fbe36c0d1cfaa25c95973502fb9ac8a519356794d48763d6543243066e740a734bf96f930560ce624385473d9c1730ac2a6c65b5f447446f9dc811c584fb4086a0e0b2b0e260d5d21e2bf4a4c2e3593b71a3521e7ebbe0c37d241976b8d01002bc44818850f5c9499659f93b188613095768dc2dc4e8f94ac278296463da3b6248871ded5fcdc52d471117f834bf0ac010b2793991dfdb24fb06d30d49c90101a2d46d28ed288410cd9d5081efbcdc0fa9db3ee948b16df4c75de1cffd831421fcfe8be3ade1b3a81cd7a3e90f58261cfb24573289934a1b04f7d105f07b0f2950bbaac504b840e72fcc5b01ec72cfb3cfdf96abea99d04f346a53bcfb09ca67a8f5a73a5c6cbe903fbe52878c806da7badb69921d796f41e6fb5e777f0458541609ec76447b1aacd1d7d2cbaf96f2ab813c895395d67a9b381597b5845bc2a362ffecb140c6f0685aa2092dba05638a05e77e28bc171c320ff2ff59ded0a1854f7fb0d5ddc98b8742dc983aa730110705e73bc7ababa056b6e4a47bed31d9163b31770db90c31fdd8da305771f0234e879d5c63eeb3c1c4023709ac0ada517449c1f7372e7add0953a9256ed23df9d4280d3fc58294b70def5d1d227ba9c43e7286091cebca67c9d1be8090c17756af5f7e860522989260025c33286cd0806b3c4c48a7e07a188ee0ea9a513aab3b9a3a1d44d9caa7b7102cbc73f0740d33a88d0b661af5be9b5712275d905877f67cab94f38b8446ed0bbae342f52a2bbe917718eea320a62cf1fb1d3a62e26f02f1c09b8076cfd8b4c0bd085dc6ed20ef1f55b02bd4e27b4303335a4c3109e92a38eb56fa513949306e407de03d786371fcd052ac7605bca10a103c2cadb488fa5318d94238abbb7bf8ffdcfaf30b3ee0bba054da8fdc35e45250db9059bd562e618434c54bfdb79724aa84df72e4a6d64901f85a37a650fcde913fe87f6db9371023ed00f5f98dc5045db136af018d8fd758451acfe4c4f551ad1040dbe53572d675e0a3123d5844c64d91cb8e86e1a72823442e55b77a4035043b31230900224c0a161832b28ad6400a7463f551bee87953c2d13eacae254457fcb753e6d4d2eb04a7102c2a6fbb8adeff12ddc3d404e24a8918491d5c6a1e11978784162849647dec05d12a3f6c41fe09df01d0a00a2060c9078ce0c3e726a928f4dd4e7f10132ac0275bda6ede5bf145d45d289d7b9db5f30b54091591256a8ad7e666b2efe6eab5dff34abc4492c406d929fc29136067e352c3b095bb138973558e3de99bd57abcc8ba08146c0b60ca99aa793d5c6d461ddb0195194fde201df74baad52d1bc32b76ec1cdb0039ec88baff69fa9f344d5a63aed2b9a5b73a21a74256701fe31bf26dd4e122e06f27e6a06f2ba0c53af7538f2c07a65b265b03a14e329098c809cc96458d1914a1cdf60affb172ff90a94dc0175b0ca1df3a0a407ca35d5406c4ca75ee0fb1755ca4e9c7012910f3da77d3ba3312b25e48c629601f2279872e74bd4d151881c2f44018489132399db387708e4e4f6c92c5897d6356ea0adc8eacb60505c6e0b141b01d1912f760e1324b2089ec151a9587d428d60df85c02241ad46e443794fb6137521d1e91a48be81467a4e2efb578133fc5a7ae3c6bfbb6828fe63617160c7144248a43720a33df8f6c366d50663e7e725e3d8b6136b768416252d8e5f41f20a50667ced04f433b8d07193ba720d7fa90be1536c197192f00a2e585c433b611bd0a60f7d512ba40b26fde19ad96ea75e85147ee856d2a98029b22a351573cbe4fbd5f61d119e9602762e9341bc02a96cf0e82f43f96685b32194c3ba63df0259e2dd6e70c66acc40d0043d9edc81530f2d81faafd0e964931cc1d115226461f147dbf89d4682e02755a8dd041db28792a96058e2f5b2043154581343777d6bc62d261d02e5b628a22407d99050e51d21434628b0f23159ba409ff2ef86738d2a1f15cbc643839506aa13b17ded5877e4cd1bcdf77baa35497c16bfc7e9d4c82bc8e6e025442b6b0cc814b4f79299b1755d2de6b9a17d5715112a817a9c3edf166035b2e343471a6678218ca865f6ce92a93640080171de650295e72513aa78be152a43c107271d92ed21ee75fe67b9cfb18186d0ada1a9a44c385aeb42d8eb83488f225d29558b7cb53d8083c926469b70fc7cd917bc18c2c6eda4ff0c146ceefa40ddc457771f00f27860299fc70edf6c19bad8bd3afef7278007ced70cdd810fbf9fc11b0d6cd04c953e47ab410741a921615c5146c3f19c2ee8c064007965b71286c7c00bb2af889b45cf0a5928aa2ace0323fb58e511e52643ba3bb28b8b7183b301330d146d67ca506ee66d334bc6e2a79bf4527d71442e3b9fb084244614c65c30cb74ac9cd2e1ba47fd7abaaece86c9aeceb321efb3aaa2f2a8af0bfdec68462778214b91d42f6025d664c068bc8a7211323bc003183cbfd68c4efb267c8f86e7819a6c8f58c987276a93481b1ef102f50fd2282a5b0acd970716a28d22964d4aa4ccfdc050930ddc08bf72d1e2bb1b8ce6362b963d0a6315293e9d2e8135eeacaeb5f588a980e66544582384616c4c4a93cb62db9a2dfd2c551815b146191038d71894c2627a16418bdabe4188f31e4fe8f93830f63ea86c664387d11ad96f11a22845bda14badeef79934cf258f27c8b2035c0d57bd01fcbe3c74ea81b0cfde3ba2d7870f97dc155d6ae7ef25db7995bd145791e1930404324e0626842774897a6a5bca0b829513d0d8ad3535ac6e141b979ec0a968e99060a7eac2199265257399cf27b9690ecad66163a44e1868d030598aa421167e8f2d0bfb6d8f7baee2ac243886537f2aa0d706f7368476e473eb3130fab92e61a06439a1bd1448e62ba346f7a5bb6735ed829efd7b5c8fd67f966f201de5cb0ae0b401bc16ead788371aa649b97d6fe66c9b43121acbd76eb5105d530172accc2e074e9f2273d0053aa1f5fe840f2e843fdef3841dcdee17deb2d2fe6278612daea12b4e326f843fe4bfe622d1dfe0cd9de156293407aebdb524f2c96222cfe9844db95524ec367e653be8e6b157ea5d5352ecb55fce9a7aa1cc098f5a21a7148fe71d9ebafcd44b455716a4a67b461561b654f19b634ccd1823b7eacc192a6a2ff6eece330c2d183802d800a7235b2fbff802df625af3695544f97cafb3112a206ee01eedb92476e18dbc5a86e3aaa682e8e9132f09fa64532de0b3804e2286d4277248bb2aa6464b79cc9cd1702f0bd869a25670b71d0c0a9a79850246586f4dbaaeff6a5206e6927fb05c561b4d8f871b653cb8d35a0546bc9760b9cdaffe389c678b34b5da1cf8bafe117ae54868dfa46909fc2447b3b654221d5e5abca66f2a51fff6dd56e2893ebff82dae798986d746ea2cec28ae6da8dff02133fa9a95c9bd3af7d167e2dabf4beeb50bbee2f394d98d8b41a110f3253280e605e80a50c612a1d16b7cc1d9b3bf79001bd7b54a93bccf91faa3900492169f86eb9902f6bd8489172f004e5dfc6e609a6b6f6b3c5d512e6b5647ad99ea5d05d61a3f5462fe13c86b90e4500ac036b2ad7d9b8145b05723c2cf8499d8af86ec752796ee33fea0507511ab31c77180bc770c6f32b69c9d8c0c91c0bab6e8ca72775a9db3277a7d6dceab5d30a495e5ebabcb93789d53f25bc4493ecf805d6ba751470a1924d48a8abfec819b4d0fbb76fc97b61604b9a7159e827af6a562532c9adfb5c2a5639afe2df152da51af450ee350ae047a287de298ed01192ede7da1f6a4ba20bd7317611da85e4d02fb40cadf49eb94704f83655191c8e29afe3da988a827257370fb60e4ccbac8be8c3018f58d0db319a1861a94425e89c7acba335eee39aa8adac4ae827b962d70c6dc09d63d3fc99037c0426a92cfcb552c57f48334df3774ffa85c67c427d86c8a865998af2607dd2cdc1f94c7c8ea17a09242e14de4613b2339c9ae1b0e19559da02dbacb0ab9c18d9556a425cf3a270a25e132f50bf3ba2a28bfa2a96129aee67036c9605d8e3365bf09cacc334d61fa473ee99ae4a2884787e7ad4c714f89f90d54c93e68dd9750832f681319c32a4511c02dd0ca04ce669109bef2b6a0e0655c206edafede859edd5c8fb206ae02c30e155648f3e13abca16a9cef1387b346b3c2100b809bb75bdf24527559e23bae1f0fa4cd8cd6481ce5609077121bf6a7a77564c44bffc6480b558776c0c1121a5f50422004e74e5f9bf1967d2880a851d1af74a1352e93a99abcc2d87beea430dc5a5b19a14c852972f7d055444dd5833654b685b514f1f4ce8a7a5e2e852267d4b07564e2f7bf0fa32ffdf445d3d4350dde30c33d12a548ea3b951a7ff6087be1872a75729e52c7168fbc016f4bc8879c2b49b41116862406c95a7588072a4448b7cdb0811ec0e666df5b77f7c470b8fbed895c4aba1158e9561b9e8d0efe08c363b7b381e07e4e7ce3831ff7f518acf0b31b5325d85dc7b86c7e7575d6142c94465cee98267753851a65a644fd14843fb6ada77c5e1f64d77595771b03f37f184a704dea37b4263cd5d53c6c42f6141e59de0cd5ca00eeceecd66c5ae53a480c9d971195932c647e9ec038b39eacbba9828aa0a703ffcb33e1cd2ec423028c455bb406f0974277e9a12edd64d77f2836e829033401841c6c35bf069c4a38a5d97ca165eebe3a8468036ae1d2609c21210c98c3f211c2e2d975f8ab1b0478174fcf0346919b20fa0859603adcc203cc7fa3cf5871ba9d277690e690c2aa7ce4afbd92a40539602c6fd7e2ad560099848f4fde9a0fb03b9d08f8f2023e33876b8b5c16836b850083af6d6f089ae587ad4b59ede79a48c30d237ac354439c3c5df52be7484990315c2d192d5b2bcdc22432f9cca376350223bbe3378b2d234a81e699921a3243c2f3b2e4ea2ac1911c9ea4c189e33f22bd29e2247e2de9e25d73079ea00b0d8b8952dd613d3b862bddba424d98be22c36a15b8178311436c3d2a007297d80f1e65082fee2b9a126d7db9a12bea7e08fc5e12e83517deccc80f4269d9d775e6ca1178534bb3736a2d2f5bc8f4a1c76ad19ab5617f2c7d6351446a2a10cdf6e496e9a061411821072a0c4c4e5c24d6dba423d8a0379d598a7b648620701f76ed17d359c100e10191d1a35fdcee9789c0335c16e440cbb1f016aa71abe15dabcc04be3dbc031dd3b85575ce725abd613e798253d4783665a00703ce5deb75157c9dd39339ce9702f6da75d7a4bafba1d4e69432ce91348003308049d2e36e976ec5e717a8c0c5774c3fe010103a927bce4cfc7a445a34df91792e510201128ba74412295db34105b17ba663efded7cdbecc565988f4804d345ed9b4079d5d62f49c274c3b08bbd5426adacf28ea815f2d6edbd31fd3ea3072df267df5a2efde07f44f1bcb5d3d8deaa4d1b1e7c1eeaa8174d53cfdaed1359cdb9d4efc51f67d43254d8d99d9f99aa4a6de8d3075bda0953e83780718828fa5de384ddb90a2a62f2dcd1013a65b71dee579bf18a78f20c79ef91026ee53cb16368698d7ce7075cf519477df1b5f83087e519edaeb9a56e66f179178df650d61d49ca94edbf60c6d5e9ef8988ddbf4405c17b1084ba3280d912b54e935761662fe0874d01b375368c80c7d7c7735321b8bc0d34b6a8250c6ef8d1ed20874f1f7f77967e7886e9812838887eb49b8b1a0a9c97b2e7480c88f7c4f044ef04fdd3255acc0e23419b3ce43f3d9b660c8e349cc3bb39a5eb101a32681572b58ca43ba34daf12276826bd44d8a2013d4c1b426b73005fdb5e8378b643b2032f550e57e9a084dd1b2f4fb58758a05e1acb52f62cde3cc95909aa72d5d3bc3847911e471103f14dd7ec9a4332722c5b8d644a3cb8ecbfb225e57d0f824454abd2c4a2c65dc7d0005842161a12136dc17e67eeabf791386ea841d6054a4c9ccecd842e3029c7f7f7b8bc975fefe7466b2728a6826bfdf390349b032aa30b22c4aaaa3a40d52ef40ccf24add0e06b8c8749201b9b9c18312728fd3c343586cbd5123446701808178fbb0b941933597cdffe4415e4883d63df807500d86d9d510382eef9c7acada40b87aa766eaf6f88e0eb864de316de13e334cd090c2d35caeb0c38408845e61604b3f7221f69b87e590a39fdd853883afb47de41a85f2d16f1dac19d553d8e3fc1a98961d5290a1d0784a62c86470f5dfc743bff5cb8e3edf1ec765e039e7059719eca71a2a500aa0c80604f6790eda9ee47fa167849a5941a8fc1c88bc701357127a527c7b2a7cea407c960eb12dc7b2f3e8c4f11833de71e57875553bc490bf1c635e7e469a8766d6fc8387087b0abcb137b7364712b187fd6d18027253c3a0dc50533979df8bc78850cb07eef564e359cc9a6af63feb4de8447ed734a2edae38de2aee6e56c0babd44193cdc6896a957cce7b5eb669790ba561e42bca1956306bca07cff99e6c574fcd757b76bc18d1942976eccf98ff125c5abe4bb15671a9327317446a9cda1d97d541e5757f7aba612661f19405cda879d842d3289453fab69da06c5aae6c84a0778047121ace65ba943fb26c18ff6b494c5afa3d594cb11b3b97d5762d079fc34bae79b35233e66386a5a3de58009036b85e3e112a3bd15b9d5dad69dcd8e9771b122f7765916f8f18d1f0bd1081f7e82f5a4f17376d71c5686c4fd31e8818921e6f534c2b3af10e0837dddd0fbb1379adc7e4b17f5b4178efc64c01f0a3d72899f29adbdc8b5252d553142bfffd67fdcf33fc986422fa8a171cf7d3983ca129645f2fb9d4c0b261d76ea7c9bfbff74cb020941f5dbd4f5c05581d171aee6f93d22bb894e2d1b7d273d0ddeb72ec00af45cbce94a61af90b73b6678c9514c29c567f5d27848134d8c5b46d2e575d369770e8ac3265ffa9553304b3591168cff3a82e72e57677c58e427d81fcbfca9527b50443ab234b7ac8ab84adbb0111da556b2d53d232298eea40010f6349dbbff53f72f4a3276be275049104bd191eaae06ccfae1aac3f5dd93bf316d0cee8070a71f290f26489a8c92d0927b3e69bdea330eeacc2329061b2e3c002b3d51c8c556a21f1098683abd34e2e47f3a9ee2a515eb6e73877f482843130c391fa4ec3538313c7790b527a8461164ac03dbd224eba67a8abfdb6167a6e45af23bade274dd180d6f453b71ecacce54553e57133abe882ff74047dad3137e72f242a2a4de3c15b0def968f740057caad90d38abcdcbec2c07c667395accb60a9e371ee29791006f70550459c98327c420f203d280e79d036a84beabbb50c91983f8d9162daf9871ce6b666303917b48f38ac3787fbe5caa975c6cedb9929ae025b6a0edc45a8ebfc29b45ad5668c0af7057e3bdcf2cd019cb9a2819b3d0a6b528bda61258c6417b76620c9afd98fe57c4670dd2e86277442357b4fe68d8cea2cca9bc8335e1505b8fea74597be9df1e2036a6548918157f63c5751d82a1778703f4499295bb72c5ca5a5fcac2bf32dd2b4da9b4c903b6fbd24ac273770893c0507ed86c5e56b3a8cd73747e190beccca8f32c9b0b2f409645476e7472b30de3f94087f4844748ca7a5ff0fec972d6a56f9d585bd5dcbb6100abc1def857b3ef05a3dde2bfc680e50b9af88a4cd0de1d6d999bab717ab6c6545f22cdcdfa076974fe6e729575f8624f734b32711fee9611edd44d5bce6c6ebbc4c21bdf58b9a186704fb9790870e21f1bd14550aface5108b21c8d041cff40f3931ae4ee74f169e6d5dc73515080bacaa9daf4d1a34b623d8e06e44c8b97b50face472f1532a9078472be996e6b66b946d388a0b31ac913767dda935c3a5c586c03932e996b70e0f3d21e1766348082456341df29e4fa3a9ad72261da7dace25939ab2a165637091c3cc370636828b40ee156f916b10537a85e3a1333906947b0713ff6c1a9f7fe6c005ca546f654eea5277ccc8943ca3f403bb2266a27a8d50435411faa20b76b4d72e3e546fc6a4ca86ee74b6f4c7564b739a70426caae070837075c1d62279dce3a81f734e104e02ea77bc830f813147d45a13c26010bc75cde90203fb766468fdbaca5433d757dcbc2f075aa870897b61f7151db0f401bd499cf6a12196667aa583db8fa858208237c64ad2d247525d7d6dcc0b883974b0b60fbcae5903e5007602b8592b1fca6c8f1ed639309e4c0a7c5fdf5fb8430c939d777c54938e8d08bc05e971e7ce4f2ffe508adc3bc04bd4b2c83014453b3a06ec4c3e06969d7bb4a4bdd9defc6405220f47193b046d144921e0939adcb84267f14ae8ed8ee85b537de40715aaa77f3f4bca2b1c8dc0f3701bbe1c8946190e27dbc80beeb3cf489ee1ac57d00275e274f825a57425022cc8a25a93cd9d756d01f38221014296a1e4e8d1c70dcb17f613463bf3a21f92773142ce08919c30040f5a044f5b2c0fe09b996bac2408872c0e23dda0d5ca43e684db9ea4abbbbb0ceb73a4ff0ad789a3424a2184318618849df85416a2f800600052aec7646fee8246594757cbcf29210228b751b3b14a0e17cc99261d3c292cb125a81f5b4f68cd707aabc702500efb9d9fd1ee41938058a6dd9a07fac157aff80cc8f3b18407324035a0b1eac88244a7c425b85ffdfac7338a30902169983248a6d7d9105a0c145337b2f751717f41a0bd489cc7ae230ba00d8ecff7a8bed5b26f73fae0be4d1b01343460d79129d28312b39da1c8a5493fc470e4b4b74937783b9fb90ba935f9a4692bdb8e20041c2418011a5a16247ef517269ac66fc024b98657589edd9b443aa02d5469b245a751b999554d4b7f0fc8515b9a80d3d78ba550574e6b742e7a146c6d6c3abe49500109262320e334cbed94a59d583d03139ab533d29772f5364bbfd2df68b5057a91e4b0f8ccc36033cb4cdf99becef7a84ec0f1f122ca950fcbf35735d2a2a404ec73411f178617b4e6075aac560dc3bf6fad923bc6480845193bc1495c75fa0f9d18103f1cec5beb62540723753c2e0c090b85746bf9e076d9e8a6a8b03f9c2abd1d2566d15cd84f64e9bb249db723b0de1b69f83aba035bad9cf85f31945707cf69d718e49a0f3cf50b8abed6fb2d137281227be8a0c654fe47c4b78db352fa680b85733bc0665972d8e9890d8f5657015dbde83746f1d117bfc8dc5a0d43fdfe8ac2514fb422f3ace0598076cc73f6cd64c872939a1a4565c8508f07389129d2895696a9dc7d15e1b2e5150ecce313f57aa3239c7594ca68407f7a0473354629c3a28242b777e3b7012ac9463b0005375182aeeb57c772b1766be7721708b8d43b1be48c784dc5ddf5f1003b9821bc8e5d15cc352f39b28ed382f3172fd6706b8b3b79151527d3c3c9a7e3d05c08aa4aa72babfc42800770496368795cfdfbd7510fa6b8ab5510fd25f0fb279f78fb21ff0b3932fdd204e94c9e1a9d7ca4c366d403e4c3a3d0e85821f8644aea22dd5ec8f6dc840080b4a0c8473f154ac9567665c5bf8a04222cd81193a44efd5303f47b225bd223392ff33f42ad37da686540a9f06fcf9faeaa3643d9c0997b2e1ce36335cdcc10d85cc538aa3de5b4506fb0830da248698ed7f7726321237952e73c8cb6f4f2560da0a5fe2dd8bd843b5c988addc879fcd1bfcba318155dbfd6985b0b42828ff93cf0ec587f0059fea8070e980619570511210a88f2761a0814d8ecdb546e7b6a446d7114e25748337320631a28b56ba3aefa3e5231bb2a0d7ed7a2aff8eeedea85bb8dca4f0d0b4fbf777e6e091ae8230d9e1c4e6f6cd62c98be21bf867597a6caf9e4148d4c544d051c3f46a6cfa89c38158746ff496a956d858bdd398845ede8bac0d33860aa2aa5afea8d7235d2d6ce5e54055d6b8f66d3302cb95f8636341510ac7e1f6031a62b28b5f0c2417b2a12325c2dd0430eec7e5f35f4de9e94903c44b42ec786459f036e769e78465b8a9b8732ae4c14df316aad9fad1049475fede529e65f7b9491f7c3b3690866e652485dc274ec2745d0f36b0d564ba25f71032aceb4a2c24639ca2410b2f74669447e4099df839119126bcdfaef49f4bdd41833e5d85d88a6a9f6d6dd90f85174e43d18e0dca7c1094b9c1aafb162e052a4f1e6e323a2fa1acc81ebb4456956a3f6f8fe2d21089e2ef7ceb6f7d77e49e39fc4c422193d7f730bd84009d6219926952de834edbbe58edca6fe77cdd19c0148c49372b87cfc3dcf121045f8f36a702691aabf8ee9a163ec915e90a5c3a78a18bb69b381e18bca3e19e0fb964da2c37879a237b1ed90dcf746c788285a923ca57aae5325bedee36b935eae21e04332f6cce7a05f641d570e587a300e66990275b1642e4f4cc02cc413b39209ea018a587a306fb8e0c9433e83ae91d85ffbc0211f5e20223f47612f27d958fd9ef49a22817f84ef2a11d216eba678c880c82a9908a3469fa77b6bff35b1683a812e1021e60547ec7292b731e7cf0cf69124895c21c5300f06c5931d51cb69385d248d057a0ce0f15ae88af01bd3b3d6a24d5f2740f19004eaff27a4bf36ff535d5962405fba5669ac778e4ad27cd5eea1a2ef14f70df86f728f0a7ab913cbdb44efa5502a4a61f8ad9628f605395f646478b1b0222c5a8076be22e76320ec4315d217bd6f5017b54ae888ece12c424d091bc8116adb888c1422b657dbd990f5e5aa30187dc0ff68e79f4840c1e865b54ec883ec03d5a36bb60c2b770e5d37a9cb371f8bdbfb89a536293020c12c995ddb95c4859266f017e8c4ac0ab97cdb4bfcf08ce852a95ded90dc169cf15235ef6753dba769296334a16f5d164d237b38b27b57dd7606017adf06207b3a0ce8571faffb4171b583a09f611ae28b95f1a213f9d67307ef79447577bf39732531d8db5fcc53907e71adcb531e81d12202e2eee310b0455139f78b4df7842addccae224b34222bed79a050e0cd63fc2a4b1a5f18a57be166badcfe29691a6a261b877791f1319ccc6762f266833af3f8bcf4797380818e0ce90bc85c5872f79296ecf9eb179a7ee9bbed2d6b5630c8862bf5fe60f717a9b6b449665cfe10f11b170b0406f092c030b82de48f775228a3363e9f8aeba4ebcfa2196f6e9d2c38941dc91cae5bf68d83a08fb2a0c3b01ab533250034b4ebf455d91a567e314d41977421ea777d5da723bde8de9a4542044ccbadaf3552bf570bd93ce457365eadec2c91b2cbb7065ece7c7a5af283bb0744d864b76bb7c19c936ef52f32a51bc451890b9c9aeca44827e39f457e69151f2970b6c823d5e17c73e896c58a081412608900674e309ebfd3cbe51fdbea2082fdc5fde1c548a8b52e49dec787bc9f9fdf1a97831d2d3860e613ed9a28ea8922602ef9b6140ed8c96d907f2b3e165134311493eb086643f7059a837074f32675ff1a134f631ce92ed0cce7d2bbcb29a2489b96c5017a7de9089b87f99062e6043e436bf239f828a79db5a8dcfcf567b16e7775bd967d2b2872eac4c29b78697cfb26a5de34fa423339274d5cc44ac977f880ee527a56eb2e124525194c49cc345e1899c79ddaa9bfa81388306a594df1f8ab6e754ca851c69ff1cde96cc09afd44d9b3d980afdb6178e537f624cb799fd08d288e7b100aba34671ce1c6df47183862d91d4a642660e115847622ad52edeb5bb83352bb3f4e46da102b61c90e13b2ef2576dfc3d96300957637e0aa15dc90aa7e86bed79f71364e2247aa68042ebc58b43779cb3ac668538da28be3ea9c9f5678484e9ddf3e33f5829ecd2f0396d59bd3c2bc5ed94231b06424a4fc01500e5aede2b95b1955316857b7b16322e51e153949d6316dbf4b3d14e710b8e57614a2cb055345232e90f10a9d6ae2c4e38242229dee13beed63354390ff0808b5341a2e3fb8b159d9037f73cbec6bf2f94c5d99f208809dd05c6115c72337fb7487f4ad97fb0c5ec455d24301cb0f4f1bbb98a9e6c49455ff6dc79e2c6627d88b3f6a53a5514c6642e8d862a27d6667b1688f4a383ae699233c14d564f3559e8c893de15ae7984eda43407c8e2ba929d319fc6701eb9df66840deee1497ea32a38558dcb42ff407be7a03da7eeec69ee18d4b3d8f446092465897cd9360f71f43b1b13a251e647f60a77eff0dc127baa1e8bd91fbf1eeeeb0060283ce84cf9bd21d7537f6b49165e673b416dda1e1bfdca2a3138cdf236aa374a25a4b40afa4d4787cedd9cb2bd981b5a8128cf083697b8c85c79724143ad19a09e6fa3b7bd29a22f145a6c419e126d058bfbd8b9c9072e18bf8cd9ce06906be6ac00a8566fe6da51f231c5d41d4b88f04e54e5a3ab1bc197cd4257e31b0d2b1cfcbeb630e7c1333fc1191d7f9cf685415338d5bd126ceb9b6eda4f6fbbf7ac76ef61648b531696cd780163b0a33dcc2228c4acca397554b45a6f37b861279c48fd1ffb899f029a0d68fc5b0ceb455ada278a48f63a11377a30f70674bac1184679cb9ee6f7460798f022c8310eca7d7ced61df374e6571bb1659c4b7968d685b823afec8c06f05c974a7d21771cc83ef1873296074d4214382cdc5d80be86013bea86b6d8c509dcaa242f0b9f4a686a286fb6d4a72f9825f683c7041c64fd97957b8738270277170740cef8db2e030536091208263176b3ea5fd411260cb24c6d054706fb27b30738764feef5dcf8975bb67a9cb611d59856c8d4c7519fd2adea44898e080147a32745affaac1703a9c482bd636003e874c9045a4057880a9e32688e80351ac91faf1231c25b5d52ee9340e4495589382e147cc0f4ad2971a123bd88048107babb74d66f74ff9b393dec40df18a24e6d975ebebc8c6a8eda389a7375f593e3181f6bcd5098d7c82b7448634317a87d3b8a3bedce8e0b9d0837098180d06b9f01f13f3a5ffa6f32918ba7d19ae93bbccc334c4ba50ed9005fa20b5e6dcef2f3598492cb89b2d98381b19b548a0ff84ed17108a86b1df422a0fbf3f4ab01b606212bbfd03ce2a8788d822f3f615ffcfa8859fd2a2222eaebd7c6f7faa2638e76a47880229a6fc844fc9971951494ea82ae0bdb4f78f50d16eab4414d0ad3e35722b3541b139701b34a5ae69f3e2b519b1a5cc95c5dfc6bb1d0e304ce5f829a2fa782d511aa6bac317ba53fe645302ede8b300f7d246ab07edd020d3d5dabbeff524f8dc5023abc9982646d0ee67bf2886319d76d9127e4fb1c2ec87be933270805644623a8c0de2009d64055cdd6b7bdd133185d378f6498848fd4e746dffe4fdc20d5692b24535e6dcd1f2ad40f3003333e7987568f9d56bbde41d49d83706eb941573e5e955e6493cac161aeded45ca1fd0f13173ae05125abc3a35a2e548b507627e82ca2f732574df5b921a4e680df35cad82b907460192d828ab2fd0eb53239b2487fdec6ad54c26667b7aaf524c808bf568ba2e33b6b7e9f70311a3cd0bcf15b0d17335978a70e8fc73926b5e0ffd702ecf11605e740c67b3c11987c15a55eff4c9302bf7f084958b6255f25768d3e99bb3eb299046e31b46258fdcc816efb505fa2f05c792931bc7dcc3c9d33b851ac0539d79f05b5ed4a4238a9cb5d6a5c34ad1b2723ddc10d3ac8fa1fd197612f0bf40b39a7b88148de50d4dbc123e07b0bb427e159c4501e949e4d9ab0cc7dbcf0bda8ad705224d540ef9a3ad7e29f5fcc049df293c51c954a6fa2c3d561bffd95410b045aa1e4bc7b24dc5e4a8240f151aacaa862218194e8c8182f1682af7b0ae8924c77b70841ca6f3a5c5d3ce9f8bf87406a4e37d9bcba4f838d81b2aa0dd3f6b42e590c08ae9a2cc1a1b50ae0cac4b8b11721a356e1e34a4b4ec157a850839c3568bd1b3fbc50c7548762a87a1d62fac01f953a04db2cab8d8ca5cbde89e0a2f25a86fbcc35b147001dc168be178bd37a06dff6b6324206d69019c34523883f2c46abf1ef04d505b1b07a41894262a7a32a9e9ead2b4e36259ae313d62c872560982bfc6ee8d37c2c1c69eac37637cf66a7b86783eb5a9ff81725715bbe720bcdec3f841b543315e3a865cd2134a55fe983d12a8796ad2a0eb2518290e05753d3cd189c84380b5a0a349818f7327e4593a0ba2d07c6116d5999addd374ee0756295943da4b70ffc4dc990033197e3d9d0d18091645b6f9ee984c7a3ce33e49c888db46f8037598138c1e6b84f64dff33b0fa395c2f7f27e660dca931b45e1444b1193235ae6304bd035962f5e52708d7358d0bf66c38545c5b73fb16f0fade793da0a06a669d2f79d1fa60b38c686b157ac49ad41278a6c8e5271c5da6189149f25269a16dab3378f8fbc49d4ca370b49a2243e49f65843ce415d04f0f9a18b62d060c99b8204dcf9d9e7a74c8b6de7e8390addaf2225e734fbe368bfc9a48c068c0103ad2af7249a21d9f71d72bc3bc65021e59051bc39fc2a4b533a9732f82a9a55e95b9db35399dcae809a19e91b37a249dc3873513ea178f8bd86ab57bd7320f3daf3c2c3545d17e06584bb53db2bc521cc7b6014eb1f9e9ee06b09257604b0a63e540a8ae1edf1c5531490e183f695121dd4e7e9ba5f85277e217e80cba0aa670afcfe92e150d4cb0065ae1d3f1a5b5d01031e69ac07286f3ae42e2486034f1e375ac7836bc7fbdafb553e6870de127ba4c455c8df564f23403a3c0aca830d72d3f4265e6a21a6ca86b727faa0e7ba8acb5dc57df4a85dbc5623cd651d936bf14031f9e1535d3b2f93d1f2a3e54621ff77fd8f4922bd7d53c90edfdf1807749fc3b116cf0cbdb8db2362b25cec920b96de7414eeaccfcf481072c4b18943ab46aa9f415dd55a02f6d4d01df3a73da89d2c5a08ca348601dbe015c7c42c71f921e1afcd421f25ac55d87e5002f78b8fe01f610fee1807ead6a601da3d01d8c1ef0552ca74c6da80f6afd6207933972e63383f051b9bf72fcb9b05b1d4eb449f10e3c113c3b3805546967d3384b94cf1c4403baef8b54182f34b2b21a6a10594c886a13a027426387906ae4a31ec5d7751ce6e0bdfb622256b23e9ca9a7c8f83a36b9d6a4e79ed5e14126f6ac357c2726d553a6e868af2a4052867c6f6713463093325e290420df77c2b49d8fbbc7193d4b035242ebbb6f0a79b545f55ed2854edc5470fa702382a2d929d9725bb4cdebcf19fcaf0debcbfa894e951de1207e26041d2f59eeecc9830e4e1832bd39f31cb04bcaadf9a63785ee636fc835b3d784f4aef5981b5d7238ef47f22f0042a421faf3781e84c89600af35b7ef5d7f1395ae77cbea2854b748c9cdc90f034b4e767e1f657faffc9eb513b61a5effe188ab225906044c31f88097a06dd7da6f7b095fb5fbb1e9fd77f3b9704f179d4b8e286aa651c3c1a5ac78cc4f5f680460b4fdc89f27358323b33d86c92cf6eacb35ed1e2fbaa5ef4e6997f3ca20018b59bae7233c82eca02d4e6f97fc82650d6c29298f58183fdfcfc50b43f064192776ea95f5e8f6b6a3b95de534a889e23c5eda71d2ef86fac0abea254f14f928330f4c1c069b27076738bb079180188039b3eb5d3657f489e2755b7a9a1f4404fd06a6ab6894fa131a5b5a08b36d9728872f2c685307a229db6cfeafadb2c11267bcc08b68d4a8a290e43e5bf12c341ffdd9509e8ce4938041959fafb95f6cba806037de6226321cff4507361c51c146aced0cc0738203778fcdbe45e53849150462882f4c9b57552aa478e31ef8d7e2135be9b85048169b285394bff050f35a4ba048e851d32c984ff4bf47f3a43b5e44a41b497f82eb7cfb066c0adca5e013ea05682afe880193f4a5885df7a69d46c2fb2c55e4f9fc0abb7c170e134f362d93966e41a91723e64bc12f58d5a2f1dd5d980870db8b6945ab22c0b753bf8a49ae7a916a7ab7fb98f85e4030c399e4ba1e48fa6a913b35be3ea844380b547f92b2c73b3fa1ba6321c4c4ffb89a3cd8a876b337a108ef9a922cefd5cf1eefed7e022c5853dfa7b6dae4515e9f38e2bcff75ae2d4332bf55db868e14e39fbaf92a0fdd4963e984091100970694b8077c9b55f628f96aa553136c892c5fc3e221defffebc0323fb2b622573e283ac6cf42530c6e25e493b61c80570ff4192f7864ca7f00353d25582c857d118efbd596b54a6f20cd565cd9466eaac3ee388b5d0d73323ba395542f9ad3e6cb4b6035f28c69483efa200bac3074839db7de86e53c837d32860c928474d4a343f404b21667e26ebe9d43ad99ae68b354e2d29740e819429f4d9e1b792e827fb7b5237af19dcc366943aaa5e841128abdea4d51b04b7e5fdafe822f8ed3d2b15b7ade66ba2e30e06f95cd5730a2218b81b76a0a4e92c6cf242baa6ef17f0af84348ad14be39b7c3d928f7219b9d8bc265f813b10317324f119762f821e6295ccfec281513642fff39bd0ccc3cb9dce8f22ef05bf1ed71a18e362b5895c67298197d57872264b938893988bab16407c7c92f609ae22e3519ff3c216653cff3ebf117053b5efb04c19d6018809959f4c6706bf099d9c0c0a68f545b555e9b768f7d7c6619094969ab3820ee143774c70fe909f74705855036fbc1fe1386c1e25636373d50b1bc4e96b2f9dfa5041068d723899bbdea8f240ed7327e9fab6801be9a5b62f942ad41f2db9f6167ec614763a3005c18a4d74c32c5976c23444ab56e72f42fabb0b3cc7375d6f7fee40ba037c33f5390a6e79216c32d2fdf1ffa17a4385bb3b43c6cfa941657c819d5e113608428e177d43ab63fdff10f46f8599f257b9ff8ee23571dc8b93c4c5cd635d3f770b3342f35c80ff1c872604fcb3a7213902bc48ab9de2d2b23d87c2b9013120ac7949e462d3211b1436947e0b659b646e0c75ee261b23269848920adf21ba02e32f126a2512d4fac9ab413171ab8785d741e4dc9171d7455cb7649af8a2e065ca45444a58fd7966ff71f371f78e54bd08e59de4d52f0a2e3f75d8d37898f2db2d23cce63c0952d9b3d7de1e1c6de4a7d751190009348c9d4c561069ad358a33ec9e9e05266299ae8251c8c2f83437a8146308c4905757966f2da97ed5684f305210d4d21dc7a3722596b2fabdafd2badf22c6a84401c122184db243479b1b9d874fd043ee5f3d108974c8c57b3a8f6f7b0105d33315c9a25b93e68a8e5f0d098139e94601f68307baec2ddaa18b9d71cbf821ad7a81db0fd36be179510ae5e06684525061eea3dd5629d34791e0daed79456662e26610127865b8c07ae39c2e612d71ae04c230312ac86b9f7257ce14ee4c474c65381f5b7543e9a321755442dcd91ab06693614c48e127269d24b9a840929a1e834ed6475ed198d57a567e5004f581e12cb5c4b9018145ed9d06df76c59564cc356793d7b10ccae38126c77060788ca33253d1c4a2cb95d47923682a02e3c1234e847750d0a1cef57df3ffb22bd59375b85515017ee448a58a5bc97280d623873be25cdd01d3badded2e025245946ad7c452de6c95738f56d60abb296e6c1af8a655ba4c29b26606badd4ab7c9881acfb32c324b73096497a885b823017b7ceaa6d9f0d7d5c99f52de74195004d42f34cf3586e85b2d1b344f08cba9b38c123a42aaa8211f828e7fe47a172d26183da30c4c912d1586fb6b305a41b9609043b685a86d07371e2b0618dce69ffdab38828def33b981b27e045d745f69eadec23e84177f9793726616473d331b24e10072bac0209851aec006abd1a894f5db095b689fac3425b0db5cb96a03537672a83089ed09b06643a7df3562b6b13f848d14b9e8171bc34bf59ff5b65a48fcbb93868eb72ce33cb0963960b16aeca537946d399393f7528bdfcf4a274914a51ad26d5bd996ab2112b05ee2dee67c233dee82bdaaf0e2eb741c218283440499415533e42d417418ce37eff2333ed73fcda2e97a56793255684c93b6f8b8ef0b09e5b53a3a9c23bd5e64846c668c7494fcbb6d061616f5af2d96e0c1fb1eae5820a27d364227c064f0da5452715ef552b91604d17386a1afad16409c467685a53edc6ceece6778aefdb1606e624036de9b3a3e2668ad3491911508af1bfe7a611e54bcfff21befe7dc0c6d605428ac36fde17d701a44e47237a642ff2979bd434bdd8a6715fc1cb5d09702423d4ac9d48a653ffa04c52e758fc72b8cb578257e1822b7072dfe778a8b61cde8ebc361d74b445f68f27cf2c2bedc1cb1314235957d5fd050b3e3fd2a3dddf88659e584df22095fe81d50208189d566b9197e3fc416324e6ec76a57aef6b6c4a8d6a067853d154d6354306a9a1f1c795bd955019f917df4a502127f88f0461e327702804471dd634138d9a1b7c8bf77295e483d24c3a3279ed0d0d1c83682719f9e253776041d57d5fad65610a3a98838dc844c8dd4303610aa7b47fa5cf44a76d3661e7d8eb103f2e3de9376e18f14e018e59b9ab8ac19bc0a745d57622c976eeda2bf6ef1043c91cac6c0fcf0c0ce96d2980318a539cdcd198a6bb624224ef288ce0234404d5c60f8df65d3c041502b73c28eee276375f3d40ea7d879246b3c19c1c41fffc030507595066500516f1c40fa5d7285f521cfac279cc1d8a6dac582c0f72f3f742175b0685d833b7eb80cd8d1ba8bd57fcb88354845ed050f9831fb447223c9273895729885020aa21f97930a37290b31c34244b97c513a9e3688ae8dd0f6fc697d8e984a87039270c61b4c1289c2674f1ad14e7b78b1a3ad7d835fb76c24e345a7786a1f54634a7caea860575538b2c1bc44833961cf41245c97a8316a6572e399b908617488abc14d84880ea5f5652ee321d611c3170de8bebd571680848e32961ac5aa6336e7b9dea258bebb7a6c32a3fb5e1b77701f10e664e216ae025b8e423efa9317a380915243b3a4e854e50486bd04d3b7743ce1a69f289e85e1a79c114b71f2499b46058fdec534325306656ab1eee624419ea3be5c61db8d2f470ac78b33a076cd22591f8cc2e49ff7348fb4f14886fe19b9aa4c1dcef9ce5d20791e2b82ae826c4ab97c607f43340587abea841ddee197d13660ca962d35aec87fed30cbd20aabca4997c7767cf73e244d0935b392d5b05a2c7d428df3a5df5b0d0b7e2959a237d08ab267b41ab7b117a2c0f33820a8879c28104469c75b9dde72e94071ee86119d66d092aa84d3d12bbb2d88c9f54d0126201a99e97490005badd347244ed1e700f2a0909ba5993c1003200d276e7b9c40444b5de234a14d3f15b97c850882575327740c1618f6870dd41973042de5ffebead617d58381bf048319eb3a7d82f37cd1a874ff9d664eb36a8087bd83ee5ee19f23f51b8cdcaf1fcbd5e30fcbad106d9024fa5a12a77567a6259c7e52f4e5ed698c86a31da757527724af8f4c527e008474860d26434d199599372637a1ab0e8165629cbb30598491c99d5bbbef07b96a4001e5bac06b2f693d8f50155794de693511d3d9ff8e8a6199754671e2b6e15461549b11649b74600f264f9e66cde139f5916b2b9d8950afb05e86f54ddcefc20f4fc2125a3dd419ac6d345a5a9846958bb7b5cbf5a58af9a9164790b0532034ca77aa0c4696b84522664fa92a754376306e1edb0a1109f0e68d89d582405122b473d565c546986b7fc7ee08aed575b6af0c49e5217d1251d328bdf22964114259f028605d93e8b1db2ac0083d558e83ac9be18d22bcc1d2073b02d6852de789ccaa68086e6235a2c4b4483f1c994ce0c2d8e30f51ab5981ffb334f0df8747b95b71a2b998fdcdeb4229b69300b308db5180ce13d9c593f015a397fcfa5e52b37dd10550920babea7126c64646da8b3a5d582367051d9eaeee675a9f00fc0abc7f493bc74da000d7793ceecd70e1c0bc1ab9dccbb079149a53d25b454997b0c9ec145da4127b39746c638986788232dc801014f460e8c8f983953db7d7018cdfaaca12ebb6bcc366282a28b8f8e127df16eb3b9c3b6dd1d79d8fc10f87ce3d0c21ffb0f9235199b3642d9e1944ad99fdaf7e985cc01cf887762e80947e38ca02a449acf7a66d9627dc62468e4c70728d5887278fb3f3470943db12386fd3bf84a87bf18107938457c60bd5de1d9a25c7b15d09a95c68e31f9f13fe13958ef2e14b164f16578441f6669182f2a675a7d9b2a5255b115ce062f6ae914f9b2c4f0e5815307511c5465aeb7a14cdadd740cf8db95ee028e5adbcfec64bf76acd1e079ca9755ee1a32cc5fa9702f2862743010acd4b53f5bd7faf4d81abd98caaccebcfead804db6957a83bd53f8f29dc7ef99e93bcc829934fac6bb8e75ac958ea4c47fad7b7e611785ec54b1f75b0074d1aa842609842d96281af9074584c6107d9b15ada4cbb9c969e32c8009edc0cbf189199fa374c18f324bbe67707bfdb8982bb228a9e18c7c4a13ba24ee844c19fbf2e92b4feeda0045f438e577160f7b4dde0cf8e20c91d98e277b506a9947f90f953b4cf7b5a478d3bcd323e20e0e11757c6fdde2b0b578ae393ae5d3a8528fd931ffd485de91b6b0d4fb33a194ccfc7f0a445ba593b10cd65d2007f22ace2cfe36c0911e9fa83875fc012e7e93434634e88de278ccf6fc37309b55ac3b74631f1cc7fb5a16da58af9d419b0e7b5e5e34cc3a07379f20e357a5dbc9b6bad9fab831da01d9cbc1fd50239f01fa83840632c95d85faf4c7f4589eb4914f0a29ddc7b7042145536e1b39a444b1a0590bcd30027567e8fedb93286d1af4fedc56c3a786017e8f902f5932832b5d73cbe4ff7513b6b639d3e21b5d5285305fef875b6e926de6f7348fe328660098e97d04fdd542269448678e673c7ef72262ca15e3e929b0e9db0d0df3ed5b6c3ac3a6a7e4230e7c5f4e9da64dc8f3a05c0efbe4c94c084e000348bbc324d8e95d2ed7d942504829d2bc6466f9f15aeec77ac09bbf82ddf04c13216ea141817401e3fccd240c63dbd7d7e2854950c0628c6eec437e065ca1c01819dc6d1c712128732bc1f246d4b43ae8d381bb1ad789e6b738803e13f4d5bbfddc809be65a2bba5cff3222fd97e466d881f1203743722082cb76670c9591d25742b77657a85ccd33e05f3c8ac2d36f11edf6d749e52c73271ce371857a9e0a86ed16ff7d526a74e0b71c108fbaacdefc74a23bd841ab3f38cf4d","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
