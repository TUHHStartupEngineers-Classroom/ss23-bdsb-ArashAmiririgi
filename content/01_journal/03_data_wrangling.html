<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"7277b71d8f037931db504c9b024cfbf8d035dceae58b31e7f891471a679e82226ec78773caeba175482042ac35b228ba9339dc15a946aa01500cfcb7d3208c7777ce06ae4591639ebfeffb57a4a70c61f9173cd32d63fd4ff571dfa91363c5219704abd6b72898fa1983796306a6e1073a584baffe9dd022cab618c2ae20972adfb0cc0f0574b8aeed36605efa4003524739072f9e0c8c4ec921c9726da91370741481f989ee2e2ce1d5d8319acfec372d1025ffae2897f6acc81eacfe5d5f616f7c37960ac2bd7db254765478d5ac61719414dff6d1b5e349d1a53d9c001bc9495db7f416bc90c12801e35d686a9086218f877d1db6f493c9aa8d59e21b3882118e1a4a13471c776cdcb5780ec17d3618b8be29b6aa5e2c901d4fac19a6a8d26dfacadbed87e3f31d2532f96221a5e186118027a8e354aa095138ffe3aa0939a4f295b3a2803538203bd01b4ea04c5bf36673e83614670fe22377102b99403fe99a67e5b48b6cc7b6cde25a96933cad04c54a19fde82a35429e2ed60f6affee109fc8f1641b0da1b661d49e2055b15691094b395b98529bc34cea8e529001e902d970115aec84a8aabfd71be89fd3293fd9aa719fbbaae1de8462a6c0d1ae0dab44f7f01f409baf95e3407ae816f8a7a9fd3f034751658e173dba3782e1e7d51999f8fd9674850f30d9166ece81aeaa90f2231a23df939e77ee59a4324bcd8117ea76c1e79f063f195c8dedb35a62df887d22bc5e77f219493879c4b7e883b00335eaea991edb4d1c8fe30569bf30c00df43349451b895e6577d30291e7387de89e3437dfaa6a860c430f96ba3a5275b28b36c5917ec4d638ec5561a23977d69b8380ef6736e030c376ad7c864efbace5ce19fe3ddc3efed2fb402d12be06ed95f48883091411b794f36f3442fde0be0428012026ec9c72085aa2444b2206b28fc2ae3eb3e65b968c3cf88e619620dd374c06f7bf15b661f4306c5cfa06c762d9607ddc8a017fa18614c2e54b75036d850c711c0a1e27e43e3af1bb9f91b818a43137bb46fd2ce448b9b95e676bc3098de540cf50b801bbaad8da6f76d577d7e68f70a9016e57b1d6f809ecddada669d2bfdc07f629d94310df7d34b3709742e8aed67ae2a0ffafab51882d90275870c151a9e36acb2359f3c7aadf42f2f4f4f344d2f74d03f99987b39704201e741f0007cf23c8e4667e426db986749188dce4f136b0c9a755bac24481a2bd77319fcf3de404666cc3f9591b7fce5efa17926b6c025c0ef874d37fc6d692e71ef5f16955f03ad25918bdb26a22e8494a16ef7a58777976540d385e81c5c8f620b336c9a1a40b5250929c99c47a712b18d2bcfffe45ae7c3951e932f06389f1b7526b24f65de43c64de4af18b094dc7cceeab99729b41a1501c9aab480eef1400fc6dde82f861456176f1cd0c8ef47da5f5da789c283ca6965a33051bc964cc0863c018cfd5a5f0ec6629c1b7de2718ca27a6cfe0ec8f4d0c61606a779b210f21ebe73c20d9a65dbed326e0b95bc1c94438cc2056907e33717d8df237cc53b130f972d0f7374dd52ff73d21bfc9d256a7885df4957f9decd07af3a391029b0c2e23b36d678943592c6bdf60da9fd992c1a7783f914446e3f02301a639925eb08523073f7b34f439fc3b718bf30d333a4dd6d7441c85f049e9f5184dc4cccd29ef05ad2defa37c6c3196934669fd5b87b0670d803f9d9dfef3b9147a13362480fb180e0315f0e8b74986667c8ebb12ef709299782dd9e9a6c37a2e920fd20ef69a82386d6d8038988528f2e9e05e0c954afdfc1abc8eaf4d3d830d27cc529db6a51822d015a87466ef5c6e51e59f5d6f2945b51fcbc722d241d37f1b80a0edd6784a5991f45e698576138c1639586a1949f633591856e96effbf126bdca6b343d32b617084a2ca8792de51c1fbbc816f34d834a8dba7556729f1776656f18390af131a4aa4aa1d442984f202779be08b935a987272d53e714626f61548914cb7760b0cbf9a948f3d9d6fd3f664bf02a46a1b51bbf2586a4699e2fe712b17a8e898f4db2ce6ad2178d046807a29ab2e25084889e1d60505d441e2d1508e62cffdfd8fcf3bdd1a5d86d3a1b8fa4b3c21b16966497736c388b0aa8ea82afc5da6c48482457ab29b98c7b7103a5995f0024020139b823f4919c28d4f1bbf47f073fd05de8e03b9b5146990f938d385e1395a582d35bdfb3b4120cb7a2e16bdc643a595bf9c3e4a93499428b61746b7e8ad09d33fc753f2a68fbfa61fcea51a779e8ccb24b1e2afe7c6fca113e6005272fb99c2f520bc7e6f7c5a1adebd27cc78063359b22905d024eb93096d994830d5476c251d53f89d3706a863e38c0814fbc85bba2db4a31f091bef340a31ffe21dc7e327da123295250ac605cbf919f8f033cd2e525cdd6d56f2df7ee15f258b7182a09469bc934440e3031b269214b4bd118024a375be664b34fa84f633671b32eb6fd114d13e8731e6f0d0dc6de1e94e9c6d77513b731cc3f728757b38c22ace106ce4403a2a49f5f417c80e14a0ee625054e805d199d08860bc7679845839a31dd6b5038fe78b7583836911712795a74a7e265329c71403c76b2b9eead570e917212ed836ba0e5b06736ddc89933516f932d33376feb69acac3c8cc5dffc8c410ac7bc3a5b57d36d3042918871464743a3e3549e386d10ed1c0979897eb53b9f3e09f2e0d6d015b1b711fcf6b4c42faa0f18a0e46e69ad0ee3f090164e3eac2cc999fd6a1e9ea3ab6c059bd09f134e8d7b611d9a1296c42951aa12eb0e2fafb880405ec89429a7c2b6a0e5ce4a2d7a690e195d6e4bc4192752b8ec4c8ed885ce76b3e3e99fdc0b3769281bd2862f3784dba027e70da4ff99882c107902f3deeebef82adb2125a0b9e825f58c5de88314156492a5e54174d113d811b01522c764bf8d2a126e66a0e345e182eb9b65405e836547665a4ff209604c456e9538784f1c5cb0485ea189d2f6594660edb8d3bbc179cadc4a20c23fa91ac40fd3610183f57e613f2fbbfdb894252eec643f309991a07093d88c020ff0babe9332a14ac0a490e4df653ad2edb7b551cba52f407bfc33963f8a346d1ecb0df2e58d58dc19499151b4c36c29e423010ef2a75949efb37b4f5f45fb4d66428fe8ad5f927f971cce3fc2ba8d4eac2e85c2917c34b9c39f91060256db7cbae1b5ddf4697a7515de834e847708fe7150135ea620e4d9585106b4a464c2246faf28bac13498a8e7410737c77c5ad79128ba8ce711329030c0958900406ec9e325702863f37c153f0370dd9a6d40a5fa98c48fa159db49131f751d69c79859b7e4f0607102c22cc37410013c63dece6bf8a12e9311104716e75063f788ca7c04833bea04ad008c79c34c24902356449a70e38d9c05555b67b9b1d81667f8302032953362e28c80b71fc8eed66bb9a16fa95146b5272f7de942851cac2fe1b64b7d78858b9072c6a2c315bf90179db96ce5d460963e03e582aba1a818cd36fb36f1e112c5e2d8863dfee73077296a52970c88f6f62d73b783b7014dfc44570e9cee11f04df023ff15ccfdc5249d12fbb3cef0172e1fc95d56051b9c4c391394982ed0aca8418807801ca0a6cb7a35f9763735c4b50ab539c4990be8a33caad3765ec3a1f6634ccac9a476986fbdde63ff3bdabfa263e1cba734e548e91b2ed0aba26b268e5a96d94f260df8f4d41d4fd3aca826952d86482db1cdb45df1a5aee5ebc1c4379ef207366264487f7d8e964529e36ebdf039f1dd76437a101a43f4659409f477bf9aeb4eb36a40d636bdd2d3e6285512a2b8fa86c1ab88ec98cb3fc3380de0ffce1b3bd3767d400670d58c223640922cfec94bb44db0658cbc9212576312caceb215652a5287e1b98ecdaac76f5bfbb9acc0dbba6ce5e33d04e36c6dfd0d4309d2860d2a1fbb2d57bf2e98bb1214b7e98ea03e4cb5094f3cffa8dc98922d525f73b42685af1df75d6eb88709752016923ebd8c2ad9d0dba3de61a3db07d54e2788ad90b78ba837680c0ece0cd2f82e14cbcf5ab06c9985f82638a5487971cd6a015177a00bb852c3c3c0b6f64ac07b7e2961bc78a16ea0483e35b7573a763a84cb032d3dbbbfc5cbb5f137888baa847ccfc569b2cdcf0405a34fbd8fee3f796eba0c53cd581f39ba64d4729414e3e8321b504dd46ffa20591fc5c18ca89eb217dc9d0f490cdb556de115168ab08d5d40b906d2dc2a4a6a6aba572ee5ce272e661e54fde2938e5d7bbead51ab55fe5ba1424504cbdbd27ae6324215dfb3e02e845d824bb1d394319c828a21a4b33334bfe7859da33ea58c20628d349520d8023cecb8c7b0b5c7e02d8dd37ce2fda5a4611c0161d58f486939f253047ea547aee04dd129ed017ffe37b50492a99b3a0d01d9595c18a62f658f4a079c4285c04e983892900cd99048677311341d90eb5e4cf3cfe4e2a0d9d4871098cdb00a78753e0edd031c19851fd14fa57b64d1263f23a7de3539d997a594383f168b94d745ed81540acb2411006cf28101eaf0a10e5d4d49757dda595241292124226fb61eae2fd7878204b9e61d4192b2abdf1106758131a2ae9c8d95d1a64ebe494268b977647bb6868fa5d1e63db77e6d0833522cb2d0715f02bfd0c0cf52eb91e9785f5bcfa7d59b38509c8638557ed46220c1edd6ebf77cf86b23d6ca08606a38106b948fcad8f7b458a42fd9afbda65fd08517977e4c979551dff5b20c3c5dba67642af3401f76b1a6b6d0841cc59ebec14fb22fa0516ed25711490cb5ea4ef0b5e8a59046d20991b7f6ceddbd057c4cbb3ae7adfd2b5919e29dd11c3e99d43765ed9f58474c274e7d3282772464fdfa6f291204d89aebb33513f133a6f0c2978fadf05fc0bd36b637183758040c903c3611f1c29d74a06a01d896582f0102a41c584f29c221bcbb6b2eb839066469454135f7a049f04785dd4611167ff0ed83bd22ff9cf4bc79977cf31dc469b2be7e96f706a42dcfd7d67194f4e6b61202196354ad8cf138f07df60539169010d679f75924ba5f22d6da31bc202a7fa3de02cf7a0ba706c3db2c2cfb75b03be876e1db2ef64382101b5e0f076169b0e61379b6d30901b6e4ed4414b5714992e17f36b275c3ea01325d9d6f3128958e5a69281f7a1cb96da054d3f9bc6542bb7dfb10118cb1ee68186807c4572c1fb6d2ab791e5cbdf70d5b2fa9b1fd567ed1e78a2fe8b5f77db2a7eadd78757faf0b562890737bc521a65747a004c792536138f969881981666808cb748999364a6547deddc25ea1eaf1ebba2297cee41cdfd638fc86c9ab03586b9a66066f58157ffcc51419965f34e8d13a56fe6864a6beb2bdbf0ba8cb89c3f74d1787674c5ca8fbe3caff9d27f6f9b8d6d7d51a003d1532f1637588c4777d874c63163f3881a09b1fd944661e6644ba548a97d805f7c23c0b35ba8e83d4ea24547e0e18511626452b374ca1a6e09726d11523ca826c7e870c4b451bc93701a5262fef89e9425dc1a21c73c8682f29018b55fe3ed73375bc67946c256e0763a81d0d1433c79a1a3c305d79b53996945bcc933ca320dbfe46c8ef8909af91c081d3cb33c1e42062626b829db4a836addab93ea273fa80088fc6856100ebd4dd272871bc42ff8d5ad87992a3df9e65736c03c7df022b4c9979ea7dd56cee935f5c5d2fb072ebdde6ce672595abba43495dfca141ad05e3fdf2f3502845110d5cdcaa07de779d89390ba3f8c269f4ec3ff715f847b1da28bcf4a7e4ec93e586d826574c9de5a413ba5e2249c896f736376b1212fd51061694894a6caeef95c11576bb6a0bbfa1ce9c7da499f04a1c9cdec4b3ff88b5a29121bfdf9e636cb1dc59f8d9b14d1f6a92b95c2a35e43818cc76485e9e7849711c65c3d4edbbd1b87eb9b229e26386b23acdc82aea087306ce60cf400228138872e12f91d9f447006db505fac6c00d715adb7b969307516622c6a72674142ebd6a4c0a0b5795116722440d06f2ee20c6feb2ca57cd0acdacf02a8d2fe9fc4e4f565afa8ca4b5033e112657d3a985d70f51b00326ce88384d44de2cb1b419aa2c888e94595f9a68dbf733d1918c0247c1ff1edf341252fc34d81174e6686c39d1ae6a428dccbbf01d9f38ac04965ace261b582b01b1b2539893f682c20066eaac3b09cbe011dc1ca0a9bd04f8346dfc71214beb201f8d71712ec088953c5b724212317428d8ea7a5c5bfce3aaea09c0dc1f9cf319aec86819bd2756f2eae67e459a35afa1ee54a5cdd9695d3ccd5ab0ba47bfadd5b8dca5befad60848e06f0cba917e9ea91e16fce738acff994962dfb67d8f4b8a0776d4bf4c0d828968ce12e24ccf296834b3a8583a93688687ee8316ae4d3a0d2a7ef68c1e9dbe50e889a260eccee4bd28b0cf6ee5ed31f53c98cb4ad7d9cd9f799405a6599b0a4199ceddd361425cbec32a49d7d831eb06f64747946459d6288c32e3f50bd9e699a4d736f95b76154382d538881be9f4be511992514abce879a3b7de57edf8dd548033cc3000738b40a340414f01365ff0b2b33d9708c6ac68a2f8c296fd7970d9819dd45fd02232f86a6c27d8a55e0d8feca7125f6b694f320cb5b36d1dc15bdbdff99eb78c7216de99d8d6fe9e59396ecf465631eea77f7018a35cfe75a5cb50a4ff9febdcd1743e8b10ee3c8641ac27fdd5d93b3e2f380b2cc3f257170d379ce70a9d0b3e2131e0f97c2d26dbac26e6224a866e10617fdeb270233dcd7bb7254cb2b3f9361395def07175b6be148ead0c17d1e669346854791c26026dff84b6b049a798b8e4241c1c9254d9357dc6b7739ef5678881873fba57cdc69f4561806e43b8c247aa8ca4f51ed7df358287be155f25894d46de8129ad3a42262a895fa8871f223a30f9dd39b84648e499aaeaacc32af719bb626305e5cb6646d568fb3c058222bff99c8d941a0af20633104bba53ad1243a9e68552a75cbab61c090b271bdd0aacefd0ef69adfcd2d5202795e08305e28c868430a736bf5f10ae7a6ddd94ec3bb06795000ebb63245b54e614daae2384fb6198c8aaeece57c445fa055589866672bfa4b78f6ecb967178d29db44f79dcdf14ac162cb6bdc84abb32dee12893603c75b8c6089f65a4bc720313ed404501ef10dfa2599320dc30d8f7c6b2b6dc10b1d8a92a4df6d266cb05918c62b69ab48fb7665126dda700693a5de308aaf82e08c96b83c2fa8bf79d5acc520ad3de03358950b73e7d3cc94306f1596197b56a879e02bc87cf422bc77f6f4dc8bd16419f782d1f47845577c841259b9eaf3a3ddc844f9eebf91e267cc0aeb938ac436404fb35b320691558fa2a7dd47d93dacec08d3154ecf72ae24de50c0a04525d315cc72f21173a10b07e8350837b629e44995294cb19f53321ce0f8c6be200bdc24b1b0e182ea564f56b16ed38ed7a5d52831c059fa99c4b692779c6cf4e4ec46d96b9bbbc6a75fc06e8e27f16b4ca33a9d5371ede27d5d5015ddf4d6f2243b719ca9f5263fec53a0eca5de0774fa98e8f1531befb4d9bb357453e2be766ee8a847fc82af87de6888f07049bb249e8d95c8521a0198b934880cfcf66ef7477b374fbb3eaba646f41e00c36699d1cac4c27c630a0888aa540a90a3e89aa11f0c5e23d3c1783321e6f40dea9c9d0273602945a46597b0920a557ac0ec35576d9d5778f76920cafe79c03947dc967df6b1e09fff1426cc06947399ed6a3d5fc25ca3038a2042b84c8270bfad80f08918710a70f6bf00da2140fe9394f0221a72677b373c337f7f29f74fb017fcad7c4005cb10a70b89c984a8f48be0db9eb4dd2895029f5b0dfff0711546baa92521c0efba2a3b719b8379d48eba8a8102096b9d6c4cdc77c5065c1a942f4ff2eb57f59e4fc2f71e64fa5bb1598e91a63c218cd8cde662eb8a4580e2f45f5bc96c3d1cb86fc2f0402bf654d7cdb286d9236b0718bb443bacec8267c6798e24112742aa56565c3b4c0ba2f8c522c72118e2aa6f9f77d5e800c29f8151c378210f092691b46ae2ae660ba9680ae1140bc823396fde20f1ac959ebd1966129c51042b40f2200e121cf05bb6d0bceceab8cf00e9c32c22a99d665abb0376ebaf3636828e025dd6417fdef83e4129bbea11cb26d00efda0f95c93ec6458de4f1500fd08b6531b8ff6ed6fd1dd33e5451b3bbe69ffa0ff9e9319e03352a9af30448e770c02e8f000ceb6ca2311a845e073ca03c80018d91aa41165d5606b9ff89eaa25db380f145ef53ce528da087b691cd67e3d967f23f287c2c8dd92107097c8c385f5b99e142c9c864673dd1325a29281aadd2945929ada40b9c71ff992097b7cb1912a1c610555bf1166805b9e4c1367e1d58c179fea2831be92f1a1a59bf65b10cc8626a4bb1027b84378340d0631fd5bb61f010b173acf0087b3ffee4af1f25655503ae67bc5f5c261e3e104fa8fed14ee925080c14f3d8ce2851384246a6d06810bd0908a75788107a2c7f7d3543d3987eeb4686da4d09021261d0436f5ac4d4b621fba152baee496e4264c179908f00924411bf72c7a4d5c128ce32229c18e1e0b573578d70d4c1de45f8ec560cb864d2f78c472f811bc84c873ffdb6b0fe6fd7eb30643614777b81663b7f34a61e0247c5c16e0b6611aca374fa2d5b99322c15f71fa3f387bd1681b8f7661ac460032c478144298ef0240c0ffb6caee93ed597405fb000fd0118c2b82663d3c2a9bb153d9f78401f470195cdecc8cdc51bec107e972fd0d1bf197c5af889b2fd0fa940276dd338334a28b4a00f29e974de759ace8e6ef50d0ab0783bba28ca3a09accee9efc5761339932d74316683a12c61061333a0f5a30e9155f4d920acd5b30fc9ee4bf8c22a7828961e4f575dd18db7757dcb19cda5aa13cce87421121738e53b3048a6d1ec5645b0704b7af047779cc5f630d0a640dda7dabe5404f4dfa4afe132b15200c1250b58bc4005e652dddeeb09a56fe66ae0ecd48975a737d2eea758cd634f39470243cea9b92ce5ac01c990047923e7a94e8a61f91bb3a4ec378b67278df797d21a13d12e35a7314e1561e0fdb5daceb17cf9ddeec6d784c699838252f1ed86533b9c0919b1351e61e48d0f9aca98b03107da0710365b5048183699851cfe55814afd90cc7bd57af00d6e4590cec7e3d84cdad930dbf83bf243cf1bd7acdbe0d9654e8dc36f75bca81b2b58b1733e2a2244b14a9a2b28ca185ab3d5afdc6dfd3ede2e8347829c11715b2a9ad633eef49a85b9fc4c61192ecb543c844b345c77f43eeae3a2c2b0ac3a4e97f1374c9b100828ad0db9efdb3704a67b9ddf4a130690c15c9dd7389a49bb8a32d0f7580ca554e90d621733c99bb96e08ce87f9b2551da886e64ac3914086af5eacb22d251f83422ab3d7ae2e536032f88aaffd05345a38049db6b0b6d001264a6999b953b933d64d2328a2316bbe264c2fde296be2013db8b699ee0934b209945af9f04017e11ab56ff7375f83ae962614369befcd45ffd2091d0f015b1515aa5b2d0e0c0352138ac7102899ad388acc6b26f859adf32e72602016af833ebfa77e013b0378d245c83591378fcd711e1e2656fc06d87cd4265a4f558029276a1b087c270e5aa97d9306ab8796b1d2b42998239677c8e7eda9c383759661f6851077e8d69cc25e5918c3bbbcc989aa74debff93e8f61daa015a623e4cc2be3fccac15268b35894524b1dbf3809118b70d06bde03b952549cd306995088a2fba4d2dfc8935ab9b1b9d306b25b95ebc0a415f0f73aac0446335ca47bc612ffcf912da43716c1ea84446d3997564178e6103b0116c80c68b54662cbce298da92b16edeb1fe25576fce06da9a8ff6d9913b704c141ddff4e7d0590df551bb9747e49248d3d599109bb7096fb9336f60b9cc2b6cb399f455b1b66f3ee050b41645cd0ad5c445da7ebcfb1278c404e09ba4589b085211b598fdf43bb9683db3c4be1705a3b2f90482e3b490350ebfd96f86e1c4c4b6e027606db0111fa1922640e44ef2347dee0cc1aaf9f501a13998d65023b2ad6d2b523c1d0f81c3d72a0a36f3fdddfca6d812435eef782e9a22a4bea2cdf8fc7f6233bda5a8f0bbd7d2e3b884635654c99b6d22cce84c75672d95558a26f2fd3f1b0ec4907c5532d500bcaae6af55c93e4273675859660656c788f34d5cef13469b692092d8f37358e01ea35312cdae50cf0aca50cc42feeb730387ea88fef09bf040df606125ddc5f49a8cf6d6f93368f4a4a41319e0df5c67771be6cdd6044b48238993e865fc200a0bba7f8c69caf02d8a275aa2a8e83959d4059624119db3ab66dfca266d7c62716118e1df0f10c2b682ab2dc73b5c4e9f3c79ad0e15b53b2b8fe31b523d10912becbc937a67e9f5539d3bd7d90fbd9d55754d8369435a585fb5b5e6b17cac587b0688af651fed2d7757b2c825ad3ed4159830fb01fc6772317776012820cc35d4fdd72bee071e169f513ef33f35edf68996bd53760528952345b6843547090f57d674e854f64efdc15045a5d00d7742a8fc89c7b05dae81e070734e8267770e14ce39b2aac7b5fb6bdf7122840c47156ccbc936532c7cb5f1372bf63e2a06b644a66d9ddf3c3d5e42983c2b843493175a117ce045daec5f64affe7d60b12440d6da86ec9a643a64a1623cf9aa981156c06511ce2725750cfe2b61681724cd465d6eb92055a98362de916d2fdd46a23c6354f8175998c569f484128b48a347335166019d61460926378d696fabc698800f5d6f619f8f42105ca82755a7cd705c3b45ecf8740738b8e70f7b3cfb1f2815bea096ef068ea3d9e827183980865fbb5df4bb67461b3196da1ba22966033253b17820eeb570fb668483f265447d54ef4d8f4fafb5336a412eaec593a044b20538db8b0f284d7b55a8eac14087e54bce76b4731161c8688c76313c9671fabac7692c9883beb33b705ba4e07aba01b046dd07fd691c9db01690df7973e6c28ef8bb9eee80437794f6b5706d99318d0b8a62335cc273436e26bb2fa8d35bc63cfe59ad958475bc87611b197302fc80e612640f4a05fa4a527255f4f3af3145e04afb514a3edcc24fdd35cadaa954d26704aee4e01a74f45c5e316dd6dbd53cc3191851bed7e1eb82551895ba57d1a552d508b50013a4351b1ed88819e5624e4ab30dc465c2919f4d845eb000434ca6f4edb8846be3545fd97f247e594dc153bac23789c6d028d4e7d9eecf9ec345dad4341f1e155259b1cac27168fed41784e57e97948c71b6fb216cc20d61665e21461ffeeb25a94c4c64db100882d2029ae721cccf53303d485159637d7afb0d0a9c2768461253ed9c5cc72372ac32b3c95506b56450e550c09fb1b4135a4b24ce56512d6eefa612bffa30dc9a41389869fce5777854a3302e1cfc9c85ae687c578755fea88fea52bb0195fecff2563524a1ccfdf6a281978c9f1fd67b9b104a3b0255f83a41984179fb4c84f975aa59ec25016c9074c0c69a1e33c5701361b7f9e7412c0fcdeeec5d95c24e6413caffc6a7e3a7198b93c27cd77dea7e6a5d62d1167a26c6b771bb64d7aa1445e959ec2ae875c5698eff9a8842cda33dbd321a99b076a75433043cc4bcf6b170d35b8345363773cc533b623a4f24d3358ade0b7506ce50b8df72d383d9f02699b147527e4e602b28159324abe43c0436c0b532918b5deab9c928f48058e01691660877ffa57ffc4ad32387fbca8454edfa951cd893dd3e0d640cd35ffd94ad33eab5ac9096a0f16032c039edc3318fb3e268ba5aa8f8713ade546953f2c2e3b37f03f75c4f68a112d997b8dbaf85cbc540e36ccab83bcbf27b0c1337fb97df267aa1dad515ef9ec8b71bfd8d609d761015510f95603d2fbb0723388992059a24a7c9cb40157aee8bfa490c3ddf2e5c7982afd5243aa9409ae573f8b7f6326e212f21818cb601c6e7d8c5e3599b000a113c1520404acca1931b57ad7f4b3b4108fab630583d707bc1522ae19291c5c3e9193955145f112733e74c5c3459dc81f3abcbca05b2f67b5e30d2c1431b18c2d4d573085ee665f4317286b584da2846d5ccee0fbd1ddf993e521a20b24077d78b506f9dfbf2e369abf7bd9baa3d5a7f4804ac4ca039de77f58e5a2f92c59d26b59ecb3727320c48d11daa3741907ee0fc492a90a4d5aec5e9d280f07b9a9eff75c1668c5ed0e94c81833d77dfdd2f76f2f67a2837cc8d63adb118656c2c6f9baa69d17da582d7db192b1545970e590752f25762707ffb159d0a800daf6182b19c78d1c8d91c8e5883f1f8b84192db901ae1ff4dfabf3a35948a2399ca54e3d651717efb19a51c441e8baa011141bdd8f5226f897093f09259c92344a6ddf8759a1eeed687d4afe58858087431c42214d8ec46c6d6de5d44badc754ef378ab11c7bf20970669e0b150a564ba539a7b7d4ff3a49c1f0f62cf9c83a856d3b55ef433dd1b4ecfbbfe903a0a5eede3afc743d5bcf88f4e7389c8af8873e62708d4fd3c1d7daf410f3f98e4c2869b4f24f26c61ad745077377d72b201537eb326f7ab00c43d995be2435c98be2e665270280e0783b98d9a7baf128ef00e98d2123e2b5529df5cbccbc59e57afc49644bb8dbd3416f7f09443c049fe3eb9b6304f2d7b944d135f909b1972996f226e907a9c373506d38a38843736995b13bb8e247a82082d54b13ba4b4cb808915fa5ac2031445a6503fad4b9f56cea53b8a0fbeb0fedfaefa6b68c730fe022e76cdf9f3882f3c10d679d0741d75f03d44f364cd549e2b35055b58a85661b79e02df1f25bbe9dad7abeeef5631dd6f5dfa1e12146839a55d1fe337a5d52415071d3d8be56c39b29cd91840ad69d0b4eba16a1bc0c3dc18da090326f60bfa5c892841622e7924cd0cb48903d79c5decddfdddabce681c91c5cf83e50f9842b47ae6009d5aace12611e4f57a4615ac0fcd3e4b685be81dda7b72f25a4fb63a95cc226e54b76f4758aea238c0f6bc8057ed3bc7fb2f85beee9dbf1c79bd43cce1d5511ac6a19adfe1f0eba844744f0c3cbee2c0309c044b5e8405e95c28dc9639adcac671624e6f114ee84b72079f1cb6c5ab904ca66d7fd76299b3c93272d6a4d885213b3122fc58bc2501b3bf039e33de23fe0b574be61c90b0c78bdfc58fc00e31ad8f7e1123d5791e29486666f034123899281641cecbd523a53f4b4c6274a08f50478eec4d8b189f63679aa8c83c06bd04000242f7b38fb4fd42c6166413637165fbbfe99fdd7739bf665ffae4e1234a2eb2b7b7fe462825f44e2db2582482bbfee3e0541682c3dd8832bb2dad3e4b9dbb14b3defaccaaa94274fc2e3304dc4395dc175b972e5bda655b543375b6259c8f6aa7b46dad8814889581c389c8d03af4cc204c71b786b80758c785a7ff6da23256f5eea0ae31b0327839918b6bb6b3d92711a9a1dbc3594d64bb05c5021032fd624b654d271fbaffec6dc2724ab9e43d5a52507781dc30ce655348dde5db14eaf3c150dabbfa44c8b3d213826fd0a2219f437c3cc3d718eb8d5a137a5497761bdb6f0ed0b927efd304e2615b96dea69c8262c840d9b43abd9ce1800c7c734a66d0aa79ae9661ecd705c91a7a0ebd002ee7e7dfd5489adc64b3d313ad7500ac49f36c8e82e29a8ea686623b96196852098a140a4e0b8455c5d398ce0581a4bcbbe39e2e40f0bf963a4cc8a31cce6e1180cb6f7058d2eaf038ce7bf784a2639ad7984064b995e03de9c1d1d466c647395d8ed454d8a8e783556c6e1ddfb856c3abdf5fe910e9cdfd4e348ff0805e64d14386074de268d81ad3a3660e9566510e4c308ff51cc70ca5a2cea68d924fe56b212602be664602acb72aa09338945a421b4cf6fecbe11a5a5b15c16f605d466d37a56e44cf4e16b656df9836c79f4e7ffbd9ca39e648d645b08a9fd00ccf8602face520935ab6499dba9cd9befd268c01e81c4eb4218c99e417c4c1a4f42f891f0fa2390147b26c9706f62e13bffa42aeada80acae3d664f49368b3011553f214ed1bf52fa97e50bd77943b2e186efc9ae540c9a498a3939a3c244aedad28200a4e4f16e2338f8278a08debae0b40310456a8b9b003c63cdc18625a266b5ca31e37f355869659d99a6da2cb29f591f7d018d253f18507a22464fe1dd2d8daed7a397a2323d64500bf7d9de8e94f53cd4981fa67d8ba325d3ea55d3b7434ee6eb745039117ef4b9528f956035bbaded37fc7011711ad3f77025feb94117e31e1317daf9882c4f4243dca62a51d36f50f8e6f6c2da11246981c28af130d5c670ded44b1a6d43bedb1b436d3d9739e57eff93dd21718b05a7ae52b19881d6bbec1e37985de69096aa0d4650676a1637d5187a25bb6e3bf356dc5f3266cb42fb76496e2392ff6e11579161ed876407349e836275fca1f562bf9368222453f99b87760fd8a73625d7d0645995fc7fc8b589ae3f46e909cf319801149ef407227af70b919864a8429f981eedd455dad77c3c7622ebd8d26693344fe831769d2960617ad009272fccb0f35bb8c9fc6b576828e2d82abf79570e76e37ef7869305ba03160c6c1d1ac188c967b5f089fb607275b5ee2da729f00b88d01e76888adf85ef69933147131bcfcabd26272f296d4aeb923cff4436ce39e9c450f264c006e79189ac4c414b4ca9468eacce144832920bfeaeeec6bb7ae6736e108f3affbf5a942696e30d857295c853db99ec7a0de67ea816f74897614fa4a6d7d0c2acef84464622e7ad3c4ce2a3e5efce51c11631623af7f47219f56c6f72ffc6c8338a8c4602576e5027165b5c5f32db173c953a432d67bfd8ad31ab6606ac025f88284661c67521db87eaa32af9629ef397501e83eb0d6b9c345e417da2a25c21c8b0f7eadc6c4693a80860f84df3ee53f98f4d02678c88ba48014b0761d5e4ce6a3afca1579c76af294e6b79cee6a64a8e49b9c09ec6beff3e55190dd9976e52d1ebc364fdb1fe50d627e22393eb0fe07357ead992305ebea0c09483559609097a2d1263054ae3c77f86932e6ae3e9fc9dd6ff3b6ee948c3d5c0063e2619726f8a1f66fc930c01df475c349328c9cdbd67e1e9cc9d33e1e870dd29926128e96e435527c600e97b0492efcd87fb27b83dde6f7622d53a51af6b8198d375524df5bf0189bea52fe881d7b3219c8dc64a11e20e84d60ee00d4cb91ce63b9760f6187cc3d5cab276adfddeec71591993e420563a4838d1a326c0a3bf318137084b6b99e7ec848e789dd7b3bb657c91b1fb44ef268aac63231cd97990684ad320bc04fde2f540e9ea491fa4ec44d7aa17fd7c49648e96fab1838520e6b338ec8725bdd188ce8c24807cf81c10ab0d7f56e3aafbbd0ddd57b3a917ba17b3e02c6cecb8b928af0c66e12222799bf38c608bc22230f84445ea3db8c9b5caa6629f0fbfd12c8ab43ec34c50afa3ebdf9608466c405efc26343bcab6d5585f66ad03fcb2fab878b1f0077f76d6ff24285e19c8a807911dfdb025e78442269c34357fb011eaace3db7f9a32abc470b2f74de53ba90d1815ccd86dd12962a609512302c7f5aab08c02f9fcf5339016de92d0eb555acaa605581994a8be8b1defc62f4bb56deaf743db83c6435570e7f76072c74f328a9e67206dfec6439eddcdbb862fde210a6f7f6d6f2391cc2f372255e21c710ab8f525996a32f9d2feb1fb29831e960756922948c70d7f87b9f1628ba43aeb6317314d66b30f2f1709faa56ab9ea9774532a6cf376a602eb2de3a40c78f0832cc2d956926598cd285904ee934f90895ad728a02336b40eaf2f220c56f279a1981253a89729dc0bf8adf197d1b931ddfa449592a033861f6e3d82a964f7565975097be83ba4dd4b9363027f73c9f7a494aa0d43a34f14d83b25998f76196d66df93f6b6958eaac5ac11a2ea843dd5174652ca080dcb28d476e007ff2539fddd8b8164c3fd3e58dcdc1345cb12183ab334750b146c8198175793ad00c758c455474bb2bc9f6fbe90c3da293deb86f0ae68602220c1d57670598bcaab2a124d5180776e2678e3b6edfb8bba7796d007ba58535285f5e5ed989e5c7a034bd721ff9c20e8ed6d821e46b5fd7bc3f6e71cfe8f4baebce90487c85e1c315f02c623158f36c9a95b72de928b532e3b8b021063e0287974f9df834f19c04e477fa259fb7d6377e14d2128b7f6683d2a6bf13db3282ce91a5825489b444fc8c241c5b40aa13fb01acad06cb67657f9cbb6d1b37c6bfa95dddbe28e5fa28c2dd6976a18a7d811a0a5f2adff43089f982b1a1713cadd5747046ced73b03c5a109a53a19156f9b4bd5afa2550cbda13d036fd969d939c62ec323db387f41bf8dd3dd52ddb51390133a3dc813f8694b9921f0f60ba879bfc3ebf072e8a09ffa2c08f2e534ec267350b475f9aeaaf5223e7ebd6bf7dd4d4656c9c55aebf7ea0a4583052d40900658c1130bf185350fc3933cb5c9f9e388f1589622aeb5f28f0085ee324ce061e9f1c05971cff485887f732052ac3248ad773112f70a397c6728a16fec9951b1ec0fda3c4db5d9adbec98ca91489ab45e69568141e245c558cf01c64bc214862b6e484832f3c03de4cf1307f52334fe77f7cc719688888f7c7a8d1498d2b59b276ebe0c624c1df765e2e8231c901ee3294612538c64ff9fb5808fd1fe6f7ff312ce149c2d6b265b1db03fa9c498a79ef1a0d706885616c3074fe15a95bb006db9e725a02fb4e808c35d6b04d090310ec3b30c54601a6ccc10d93ff4b6c9e8ee591b7cdf3812893ed6813550e61bc66e4f6c2402c6e59680e06abcfd01bbacb3c02de0474fb7d385f60a354a1d3473195a9d5ba1ba08b6994b125bcdf1b69f7a5187af8c52612ea96825325d4509b2ef76e5a96359bdb007cf0911acb6ac4df1e61fd85b7f6ce060803e3a680eda31e079a04ce9eb5494faa7f9c7de44aeb762373afdfbb39c2da603f67969ed5bc38e5f8ac6b9a2a05df6459e8c169984000fd438df6eee419be31deb6458e47438ca8f20e0afa2ed426b15a18801922ce36480ba223674ccc32072d164005deab1f7f880a8f6f35696c460a62b79500fe065260ffa142004f4144450d4012e700d2451865bd358cdb0a2ccfc27b0ac16f713c999d7faa7da6c16c151374c0ac3729dff6650724cf680f4ef60bbdd009f623f0ff0726f8f6d0b966c8abaacb13089b8274a5a7fd15cc45b6865712dbf11852e797fc0d5a986bc64435e3dd8ca961f87cf126a952eb5a06d314dba1943dceb0b893c1094ad1921bf7bdd7122efecd0a50a7498153350b2cf8a1b755d065fae6a9ce9c26b351aa2c5499d183bcc7b999a100c74373b34ad656458d4994e514fee66a78f3c343a6a81454104eb60e5f785549ba0a62f38e83ec42eec42da906014acba1f373d0bc09bff740702d7a6be1c841319804215b3c2020f7f840d1c6701b0cc6eb7efd115c788d4b9c6bcb982e61ca63febc751d2923eefa515115cacf58f143f817c6ecc2253856c55a2ed69d14cc6663bcb0025340a06104b2264c21efdc9302c41fbb19086323c724bbcc39dc121185c548f28443ddbab58cb9e7a3e65905b8c804bebcfd7b4e9ca6693253681b776a054724a13740e23513b4def6b0ca1679168a128073751d8db924d74d9e30c41f8716ab91aa195cb9e74f1fe448ae090013ba37cf1b3e88931149babca40d2dc4b169a26710130dd4292567537228450e1495fc5f49d6e9765eac09848e92bf92fd861cc953899947cebad1437671c0bd4d21d6a8259eeeb62e7fd296e8c72799b55dd68de94ba276131e29092d2cb6800319e8589bf8c2fc6f87947bd4724de3041583b271cdd5b57cfd0df5fd67c41f89b5b78987783ceb52dcc7b0502fdd26e8d860f0ce003b40e7295035011e259499d656c0ad89bbe154f3fa9f9868f70b0a6b868692785d27dc351e6e217f58f1dfbfc637840ca7efec079634b7cf9d295d88748784ceefb3b351a973b43cf0ece426e368b0c26a4ca9cef5428cfd7c1ab2cb8a864cc0eed34e4b71cef1fc072cba618d9ec721d556b45b2c4a57be1a239608fb81e298390f7dab734c5264bd4fc03698f9976e14e7e25c4698736ae655a7ed611b2df6d28a95169de140155b099a1ccfa85fe88d45a2f1b0d9ddfdac8f81f87dfc0cd0500992a9f75c0a23f3d5550242780469871a484cd739fdc1b3230cdbeffbacdb7e7b42028cf5c7c4e52666bde9e96ac08f80c8b861bc77b020e20d602811dcb9d1db8a1b669763e1bea6781e3ed81c0312c763f7e1d527f5b32f9efd36c2b66d7c9636b32fa6c967d6a134756b6885ac94b8a8847542092f7b7e56c01f402ae8764eb639e455105bb1f76ae78730b7b02796584e1340a219891a4b8140f8a3b6b0ecdc9ed51a83a22c32cd0a3c904cf2a8502e8b39ace618fee3c777a43c8c168425df0f3856f170721e71d02fe4f769f7061d3e193daf93ee24ffb7020a3b6ef42b834c68e56faec0ae170dc769bcabf5f52d161e1cabcd4188e7868219a7d1b34ec41b983af203383db291c6ca4c933fcc20b8dd1540bb44b57a9d88c4e8748fcaa904520826ea98e64d058843f193fc0f59b2c91cba466677a8546cc7aa898bfd074b12ec40527911bdfd5e82edd47b13dc6d0389c6092144609547bf7436a4fad779e32b063ad3d3fbf8dadf457981324ff4daf9511ba05812df8df48b1e47e7c9f6e6986fe633a185b4af37ce016c35c35a4495b19deb5b5db00d5f753133d1eedf05aa8ec80c16f5ca329457dae7d5e266adbc07d82fdbcd831034d6f1dfb4eeb9b9df876b9088e4469af137e670cadba6fa3ec3b7fa9021447e9fddab934daf0767fb490dab98326f3a27dc2ea82ac33aa0ba04e3b6e63d6ff0ca06c7f0ce50032f271d9d451d5acde24393f30228639a1ce2d502621696c9e12df4f1a438832aed204cf10fe29b19e95c810087c18cbf3319cd53382f80c2ec88c642f9e99dda790fef5201c56d25850ee0917a3bf3ea1eeba863152e4a257472ff32754b67833de2b733fc34535e62b344df74e53009b6ca6f80c5deda958d24dac1498892addadcff3864591188f028abf91eca50b405a8e9510f996bdc9a0e9dfe150ca9eb0395edcfee474cdddb17172fb897ccfbf1a2d658ca81991a7d1d7dc50c0eea8e13fe89042d135a604a0dd7985b453d5ebc9723ca07c3fb0833677ac3e1e578f0eedac4c75a856684ccaed3477b3f22f69f5b9541532adcb01de762e3e54442172a29877f5c6e72f90bded838021a162432fefe3a22dfc3a16dbd278cf960bf4480d4e223aef987ae9c9c3e60947967474898035d7cc8827fef55325f981c1261f9ad30d74ba4acc6b7f2e0f47f5cd5e0e5d944b7d1ced4cee2788b02946c70f4fafc83a927f5c9b51a9c0c8a2eb09e21778769b740e152e8eb39acead43d1d6ef5ed3440a6a1ed74c7ebe9b4e0cb7c57f9ff8cd14cd3b78775e36dc2a52759a3f6f49b83c9664a5e01dd297f623170e4d793704180529d387b2d05a7f521ffa7c7a88d8c6cc4005a1e5e8f16194af89a85daba5188fbebd5738ce9fee1254a2033d907db83bc50e51e2df403b67f3846b586ccd91bb0a9b4fd7d1460232ba5e3f5585231e9d9416dcf9c221c711ea84c4b43bab65817f42cae113e0220f4a390daeac145638b8290573950bc89e4fb47d7aaf52c02922dbe74f4e45ba5402a4dafd370591e0ad47e712f63768eeb89702b365784d4db68fd4b9912247330eedd93f5a8158d5c89ba4b653e9eb6a3ec28850152556272a06ba702dc1113127bf37cdc1d5b93735c8476c3e1169e147c75a7eb1a773ee3e6f48b1ab3943121c962dcb490eae4b81fd74ea0d84cae57e6f5a2a645f23e208f6b57670b982dae02e1ae0dba4fa0ce53d17c938a421ffd8e5941e38f814e954acc32fb8658ec8dc9ed2945054f6bd565677a24424b963b730a4460ed2c9289c12dd81484cfaa8116837e197f9fee0119025c2b7da64e4cb4fe607bd4244dccd42723c50d8b5ac555046c9d94eeafdcd2b00b0d8713d0819a96175fc159b147c9e4b05d2c12c781679dcf621b22cc619a42d8cc40d367ce91d9c427eaaf9546ec30aba20d7db3988a3551040d12d74dd2fda63bb6cf2c4194d71462012cba4ce15571349fb2eb1a36c018938e62e6cd7dce4c5e61982c45318f517ba651545ff53069d1adfb3aa375fd3abb98f56615038f0cdbc749fe9f689b4bc38ae93db70ec527b590dc42f89eb4ce6469b51a7e417a51f9c2e15110c87e65b852509c936d5dcdde1aa2cd059fb59c53676a1ae3d5f1936211f8a3947a03dbbcd220e3910774df96f02bf5d95576a789ebbe2b234f6df8f5a7d6d916fde07f48b3f4e43a1d947b97a06036666e5c68b2cb5c11bd4670193091a57f242af66e23addce77b8d4f17cd48514026c10d6647283029f61a78ed94cc85d507f1a868356f44744c1f3e8f70f5258076d3829b61ceef726c9c7014a28dc1c374527903f39b2bb1098014de7357fff5d6afb90da957c2816296e79489167ef086cd73f5eed11eadc1fead970ea72aff028c4a152968c73f2058ea56066f4db834695eb6d0aced4afc9ddf7cf7a3270847e1e21ea0111d730a29d405e961207140b7de7ad4e9eb6c130ab1cf0e1ed7fb23123c243654898a56a57c9cb8a0bcf4a785c9761fb04bfd0d911428c08de6573361ac4489aec76be988dbe5c29e71dc0016a28b4b320fc69a58cdad41b0150d7deeae6ee968e55b20ea37e1adecde6e725d971725a08ca47cdc73eed3d49fdc034e3a8b09232f21bf1cd10664345649254dd1636892458a3407d7e9cc3884447897e6cc2168099c090c38aeadcf63f5706fa287f566ca6ddf496b1d7be688298bb0227d68f7d608f7da278a0ee9dcadc4f7055755da7d274eb2e2876925d084fe6e73f80179ba27dd67a304914890677011c4742847b101857d2d4f96efef939d6b93ae1d957ef8be55b10b9d519e39fccdd14da2742113f57f32a49f4f7932ede8bafddb499709760d7bc3e6a7086afe4db93e89b98bc11c3bd5437e0ade15950b327f65fa5b171b6f3bef8a37a8348837a91778c392ea7495c835255ea35a984e571a576d9c6314733a9a14f8fd71744d1a5f6fa00a6415eb8135a341d38b4a95e1857b0d4966e77ae11890cbcb82f865f03c3121a819ea34637adc51b7fe21c56f27a61ef05a59c68f280edfae2e6f7e90b17927790b10d4455e2a0272e4729f141967c6bb2816b9ea7320ff2f7f6096ed18e696c4946fe31b39d23e46736f73278efbbf0c6c2434e734d9b0ce835b1d7685433ceac20c3f1c043e7f12b0328f44afed792b44404a54193f0d370a814cfb772c3c3e8a1385509024dbd4ac1d0b64fcaa7e12dd380746fdb77b3048692f398b5636f3dd5d7cff4f5e05eace0bf73f171b2a6b098ba22c20373d11c706d8a4ac239cce6dc4de73380a49ff1895fbe5184420d75931406d566081fb21b645813797d731ef4c512f80294f2432a96f9bf3d7a6ddf0d7240bcde7aa8412e218cb0c0cf","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
