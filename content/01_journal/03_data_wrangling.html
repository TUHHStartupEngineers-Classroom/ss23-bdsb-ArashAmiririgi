<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"132d9059e797fe3bc587d32adc2d33845eead6f844edcad81d465abc594fde11c9809c0e1c33c035151e79fa3629e89c6e1911bf9b3f622897407edf57ee310b7d28980551129b3d1a80e636fc53585a5d6b23260fc6c3750eb745d23670173aca13bf9de3eaabd34543f0694975b0236e7223da6215a1193ba0962950c865217629cd8259f0179fb6bc284f7295f168fe0ae9ed727bd6c467873f9ea42255bc507f81284a1b22d2de2a8694eada21eb25d28b5c5e81bb57d679cad13fcf5ecc8a55b8f3ac5836aa0ea6b2b488e97105eb0f5697580a6f0709f7d5ae89bcfeccba68b5931d31ab36558149b42cd26b2295798436ca51d052226016bd238f0f9d645b5917f40999c2b81440e9ffce76f523aaf539aa966fa9d4915881598c05f45cf079895f5a3d4ccecc70653e781bda5608149ba0a7a65fac5946bd307890cba2cb3f122d0c3492d14810ddf341f9e93e78a6b852a7dbb3ecd7e1771834b79c1c9ce55066927a2b7c6f0e72fa604d7d1b15fdb8c6d118a905c5c2ec19ed741d7538f9245a9fff318e2544fda1709cda1a2e6522eab6d66ffafb019d359f4edc8f4d8895144add29ff8094f8c395bc312d3814b4832a24c13eb1437339d81ea6d7a46a79334c07af7f44df08e869dd7fbc96b96026f9b0140351de17a1b202af35f9b8859bb1e49276e8126caf7d273cf932b920b30d06fa1eb76af9f6592856c6cb65823357b962cf37d8674ff7eb15894dec4289f220faff022f573efdd9d30d13b15f4d81f21dbe626aa4124da5443e09d51d6f3d76f18be80cb7aed75e18eb96e0cfd084b7780db78d3bb15154bd397207401371c0c6c926e6c842bd18e67dff353ee22f3d2c9f14e793d3d5877b651a694203a00ce350a0c6531ed9482a806a216f7ac98bfd9a46251fa2f08ea127612bd7fd93e745ed1a58da93b3f67e1d611b1061089406987664d80bd391d5163c96ad6e73a89d804d6060f604de18ae8576ac670daa8febb388579086dc8bbed8234d62fa4c16510081d5a0904ef414dcb1bdbcab1eef143244aefc4f1c13c38449a5ba12160e111dcb6996c930131e02a07689c2a786617c42c8ab96b45f364c19c6e864eb19dc300e720270489dc824a2ed8673b3492d989d403428108a81d1d78a3d7bf687667dbc21a751725e2eb4d6b3877b2efc8e336ee653f9476f2bd4ca18afea57fa80f0bcb8f499faee76cf3ddb8c9ea4a07e29d4f26ba8336b1d6ca0fdb6eb34ca819559113b4b9d0eecc2d2bdb4867df87bd96de36a068778e0f0849073548b5ed6da63079da99e8a95781932550f6c86c4137de066dc0041dea3fb005666fff67f287cbfc600b62ac447a09e0dcc25963731e4dbc8283fea1bff05b21cb57dc4b0ede51f629126ca5c13da1245ca6a5821d135c30387b1a376074a100b5c466c16cf8e62e83ed9b825cd10631989e8bb85ce471a574775697e4a02f57b7095a1fb6775a443786a71ae9fc0661f64c08eef78251ed5e87372b3e4549da6c6f40ef828aa377b2b8be063151e8ebd9387c0eb3d9af71330900e508d5b84e60c1f569e3c3ae80322e6847ed6b7d315640a252c9143d5931ee419a7fe8076977ba871c1f991e8903a08b565ef57d2914093a2117c15efb2d9109b5164e102bb32dfaa9da2f0ef59fd10e6d8519b40332d2bbc90c73aaffeff1f684ef5a25cfec1ac8be6df7339052feddc606c648a1c772b7fb489af75f497dc91e8d6362f1328fb1de6f0abddec8af1b9f740d1c8f97a422af16dc2b9f6f540eeb8ad1c844619e5d8b0fb7e2674df6a802f36c705f680a8b7772ebb5b3529b139af665bed59453424afc9d2b9452507c8fd7680005b4c1c13db5cc62f1f171ad700a7d3f7e4fa9c1f54c982690320da7da48f46cff3f0eda3e99352b560b24de4bdf04d4eb7719a66c315d32a5961d5bd6b998aa68754ec48a016b5c0e4a83bef39ea5a95c2350f855e9874988a85857e9f61160a2093da28658c441939315dae74ce23f1558e509f0e8c489b282547a69b594395c7c12245b2c333907a576e16518c21a34f19cdacc1cb14326f8a9bb8f9665da06075e6406417f789b8735296a63c8ebe0a06ac82c5be0e3dadd1bd4b72bc7858bba5771e619eb4cd30f3ec0401235e42b2386c26ec5a631ebe7760cee6f7ab54e520a35d9d1d47cb4b59029c113f00adb59c1fbeedba4734233fe57cdbdc0c273c0aacb1df82604750fa8b7f81b61ff44b9cd971b14f351236f270c07e6fdbc4753e4b8bdef55862cbfbc79d6729f74a25c130b5439a2b2ea05297ff3df3d9590b52f5c5006fef46e25612e2192598ff03835f97fd5f29459daaaf1871cb85fe5d7b8360ffc78155a160d15e9ab2cd0ef22a68bf98efafb0c60db74f376b4c4f0d4a395f6d47f07302b38bebb5a18692d541784d5fb4b67665ccb9fdcfe84cdf097a060d178368d386a4ee7a6bf85b8280d45057c3c1fab44078d4aa0c60b15da028c6161bda5f8e890add7f551d6f89e62bcf21ccea010f597b54c5d970e73f12335b7abcdba1de832f91dc45587e6735e9871fc8d2d9432a35f963adb04b636a11ccf9468d1f8e71118229bb50b4c9bbbc1627386bdc71ce67f1e7e11730c4834d42476b5195d2efe840165542cd6d0b0852c2969bb160bd19ebaf74106a9cba7452b8baa8868a07fde00a0303f99e6e0e49ff7ecd3664bc2d2332c455e1be86ffb76b0df6b85c0eb7be0a12edc0cbd2a86da0d13c40c0188f502fb91767fc6167f11659f989f83cf158897e79eb04c6584c710a374cbe71400d099bf583a2fe9c3f1dcb66373ef8bfa84f7ab99643209c34ab4c1a0e63f10a2a2c4bda867252b7b96372cfe2f1e7df5601fd39e9ab3add250be32bf44e0cd63a949dc1a190d7e329e754ff447f514b3b4b8b7b67d66bdd312b44b5a4a87718229c1e9eb13c492bc3d8dc268fb25d39983953afe4f6198bb43b16d1400ef4abb3a6150ee597f9633be38e9e9d44298b5b3d4a18edd2c98b16930895ec241b1cb5d9cb894d529f04aa0d321ed56cb03720c58f2f543d111e5a777b75184187ef5cbf2751fce4834642c0346be9d9cbbe9c0aa379cf746bad10c42e9f42acab958f9b780b2d00a495c9c3ff5c1d6b1ff6202f54bd201349b62c2902cd3cba6e51c451a7cc6f617b60aaf3f45ec8a093124697da8564e7cc1d34b205af547c0a137a4e3828d54828a2b1535b90e377048f3cd92a8b9c289bac56801e5d8f16e26604dc9e2be203adce76a6861389ad30ea12498bc30c43d19ee0865aaf5776414919b2bdcacb9f759c6cc72dcf613bbca598090f417d4c06b339654bf56af6bbc951625843bf421d408718e0e2da91ca42405a2a35ed8d567468c662eed351f269da7d175a212c4752566b3b70cc68a9d073c7c0d9caf2c8186a0c419b4780f66d7c26b6b6f3571c421f8a8d2312a058534e7528f9cb64183ca95b213c773395ca0b7050794bbb16b6eca8f060aa9a56278f9d2bdc43e741b41406e99311ec0f07bb3a701bfdfb00be0a3c15f2fccbc081317c30551adf6cac25c423efa001039460ec7bc87a36f125d65335e6e8eb9cbd67725b98865dbf823226914c3b0ae41d35952e9d13bd3bb846f91fc829d5ced7b93446e445c97364b67e3d6d75761ff48d6ec2340328951789da2630631eb48228ac8d83bfe0451a798481773a168c6426845098284f2bcf658787707b782dcbc8fd0ef42d83a5acdea2e17667b2ea181c5e6a537b64abf7446a7fec95d741e6f0cdbacacd9e475967e9aa1db07f2d0dc4ba97fbeece2cfe7b3ea5a049d2c81b067cf3590a0cab4fffd34dafc1ac63961b214aa1b43d2c1241fe1a16b8986e05f9c5a60af2c6ff3fa22b485e129b4596eaa1e2929d5f454fe984b2bb8cfdb90f0d7879b6288c68434e543fa1966a9334f9d20bb1b04542b3e3a834f5702945bc67cb4a147b8c23f023ee5a145ebe8930ccd096e16e016ad152292c57a83b71b8e4efbbed58b6b37a863b29981d3af5926d0e787788db6c7d5ed5e674336cfde66c352ff683dfb8cd2fc3d9282274f58a57b71bbc2d0a6ea221219521009139a3753e51533e6e839d54159beb7043cc2be191bb8316e7e62c37b58a5346cffca12cdda830958169473b58daf15b3910e20810da2b48749c1d103c344f2e6380e917aac206c0b6695dd37831d9d346bc21f10ca185d591d51563af7ce59f692c365aaf20eecada233c9fe0df2263ad28584681927871e40b13e4422e882e5960bbfcc3b86b033e6f73dd5454ca074a291550acbf9570b543db53c3095fc7fe951abd507c411873898417c74044b2e2e51cb7b049e7c34a6221ef5c81eab2a3258633a092f180e09520fa54a48f61e9f717ef992a5e3dccc28711aa5dc95f92efe778d06193e6aebd4ceb762d9b8fe6c3a4a3985c590c39485f7b79cac686103a1041aeb8186b808fb7c00b109a0d6da39748ae5c3cf3f3f43634b911ae5e0222866aaace17096f0356ad8fc9fe84ed66d16c85ba26fb1a84a8ffce429773b7198bd32019f0e50494e9520bb0efa18f812e406f3ea1fdcb2ec66e41bdf14b3fe1b767c220ded8c180d00f2c1255c64f8758b3f6b0fb9c22fba2cfd982ccdf4662521eef166f85c999a32f59e8d5aa3a2d67f0546eaccfe6dcf3469a6443161c5c2acd84516110a2ea46749ecb212b92d38dffcb04b8315a23e3c8d8670d25efb7c0ebaf421257ee80d50ec2ce660ac19c1f2265faead657de7855cdf237ee294acc98dff2f34b3949fb92b112eecc7a88d35165d0b280bee76196c4ea161231b101de14448e6e6513cc48351941829e41cd02b38b4257946b69dc27d5a12346cdc7b2b9b7da849d91cffe31cdf8072a349e68b1c8c3cee5d4a221bfc40ca7d33d188c2a2c362ebd2073f6876ec24f6bf5c470e58a16c56039e9adbf6902c0a7a054f4757d3c643840a37da50cbda3fe54ea49483beed4636ece5a70bd5f1ec575a446dca497fd47c5f17e7e09b8d76d3a9a603956ad66bffd0fe91712e0f1f1345518048d7e78771883fe606afb2ef361a91adf1d48f0fb321eadd0ec43fd040a86e8fe5f8a98aa7e2a331cd3a1380cad9acd81a0f330cc38d4331240fb5e0c61df5074d61624b5b6b1d626b0ce6fed1c78972b1c8b4cbe32fcb56189ca5d153b4ed03602f69465dc19766482f2c710463a3459cb5d10ca345c87b97e7ef03c47c1c03d16f4f009cff8463e03189bb109bde52996a158508eb65732d52eaa608ce2680a0216eb6de55921b7534883187010ed24def0050858b7a859e3bf08191df6fe609a4570a0788d98e8528406a7b8a7f05421b03dea1896dfd69c3153e387963088b7a5f265c0a89318d15039726fda1cc6405072c7eb0d5a09ecd2641a4396a8b14de00524aad2d4804e9cec96f1d72134f30d30fe7252ea249ca145d894dd7dfa3e81ecbc548130f702eeec6752a918310c996df8bea429091be50e89130a391022eb990150060e8342b6c1808f21e446e2650de128f3154e936b341edabd2d0c91b9e35f3eaa4726b597d507ad2d7e32ff3c315145cb5bfb1be130bd1475742500a9aabb4aa9a81d1c822180998d92390b8e86dae0c2f23b9e36899293ee52811ff57d8b16874838d100864549175c5da3026d44e8bbef89e380e41c87b15135c325244fe9405eaa063e8917f59c7d364a4a8c88fa9c078bf32a551a362ac9f72c4ceeb9b66a4325ffb0c28df04a78322c5c1c4124c918a3f9a9714d72ea94d9d0a0937de4e2703a4dda3fad92d6788003e0ae48d70c468b90ec840ae43998049f556cd27a601ba0b9188b7d153ef0bada3a0b0216d276394fc5e80772f584a9fb1bf2dbe836b6ab19b6497a8413ce7a56ca2f0f87fcb9cc2e4e89884c73926d78d4f5235354b186d4971ab0a3c39e72411d5c05cd0b76d166d0d21c0369c967f7f6b9ade6e39afa8b2982c7064de87dfb34da88ba36fca6b1349a9937292399406cafd42535884b6ccfbccc2eada05d6c985883eaf25ff0c49228b85f8ba7b012a953960d23e4b7092df84be6b2b5bf8f5bee260150228af9beaf014798ba11d3ec465e5bec2d183f72d239ebb78d930963c2e86113d204ac1458fbad8be290e5b03a95586b957817f2f6c617e3ce9526e0e878b387613ad0cc92ec4acf94bca2539e3cc1fff84e29eafd5aaba8b72f59f59679428747ebc28d7f8a2c894ed11f294650fbc023d020648c95b0b60aa2eabcbd588de3094aeaada4aaf64d847e19550af4b6c8fb372b1b2b8cf3d211b40c093e6d0f8537c7aae07a32160adae03998bc2f2e6e8bf41117f53c486906cb7d8f07bc231491065502d460e9cd3cbcc5ea80f41164ebbe7b7dfc99789d4ab90bd8d897859c5e1b04c29ff3db039826da65e8ef563211cfa7f34eb88b18155b1b737ee8ffd2900e63600b25dd8dfdbe2deb4ce776a49e7e2c2d05cedab73c1dec82733db9806cdb1567da53a0bc25d87c234b6c0e4c7f75d54d97f8204ba2c509e0f0396865e8a74e212611b19f3746328d422c5fbb860445c4abce2b64804d51b236382aac958c388dc5bcf193ebe9754f75eed0989e39bcfa28bed7a96692c694cb4096547a0d56af868b17880c641c29e2e52dcc2866ddf3174aacd48680033957520b2a5b159411f7addfbd6e64ec1eb5cb5d07eb36a15609b87835c2873ae6fefe91e80f10713167996874e7abde376fca5528123eba2770ca59bf1eea6ebb277463a7977d5db90e1665d55e99970bcdd0808d62861d9a0038d5139b84d0116869ffa540ae3cc448064cee38d2c5c5384b7cbd80094778e4f72fde2669eb3df09a494da59b0792ea08e27c3780ee45fa23c1fb0463a4650527ee551f95aafe5a74fcba264f3b2f73597e7a9fce6d4be413eecc0d1a8207af39e7f03d6a7034bd0f060cdf89bea7980ccb20c7a05ead4e56afaafe92f478fec22d8b7eaab41241e66ff13ce820998ff03cca88a8131fd78647176fbc14f3011fd0e4b1bbcd9345ed96db8fdee9bfb7101c09e14b1219fa99250209c0038a21f9995f4332f37be2ebc4b89298cea4d0b0720bff424398cccd4e8db2beeafb3aaf0b250a9b6e8863b6e2c4e2425b2d7a9aabfb78d86b597143ef552de6bb47ff28075c547be958edf3fd48fcb5b52f126d5ae297632755a3b63bce0750469858b3e26e0a1438e4cbcd7d8d3d0c5ecb59df7262c13b471b8c78f4c7f17c94386d0bc8b5b73fb06f848b09386487582f1d7f194bb13e28c1975006a2dc14cc7a022c70f2499f097e499ce3b0d1c28cfcb34a6bef4b35a6d268006d61eed192b63f5c8e539c788fe4cae9870b2322a378f1befb1176e5421ea1129ad162d4a148f2bd1dbc92e905e5381d358bfb8fba5d2c43ecf184c1eff05b5d937f7dd35961f62b58f827704f125878c09343c687e7627ce9707d451e4577c8c98ea3e4e8d6baec447a13dcd6aa9184dc127bd4827d926b65659c05576e0ec4e81e20310d7038ebb262c07272be4cf22c1e73534c3b4e428b1d3a2355069656f05123f4328088aa6c446677fbc641b2dc36f039dd09906dbf27a91eabd7284c62ce46bd1dcee85f8c84ea644a9998420df6ce8a8d50fd628b64f736e5b193a89d9a322fb425bb033d8e38aaa1358830965f1107333357f2e90eec7f018bcf4ca8b601e03c71c93be3b43b1fb5ebf96bb6b6fc60c3df28cd7b85429646963a0a594ca005b72021466fe278f30175a70e2206727d6c7228b24e7db16869d276105a5548ce58c5e96bf9b747b7a7e4cfd8b92878293ac125549296a87cc88363fffd19bc5d8296f9b151a53aec7c8a55c514611562f36d687d324e30ed750150a0b5f71cb0d4a721c1c0aa1ace0fb64800c4630a56c63ab92f8b45d20c625f357dc18caf7eb54a8a161171ef5644a0905b24123e0b63a9baf6a9c0a0ddf5b45da04f86fc117b1b5cf4240052d73788edfe1088a1a0172ef6a5758bd8b8140367ae39b448879d2b21c8981889b9aed15f920be6f12724b521fc1ac79fdfe5e106678233f0caf0b9e2ef75d33b754831fc0de0f06c6209d309ce7793e9a74cc2893fb24a6d9ceddab7b70f8a7024a41fe309b2e539afc56ef89f6548181e7e9918616f5fd70c0cf79a42e16ac72be8e0ba894776e45da23151373231fab8962a5ca0e41f0fb86f84618e475bb5399e88a2b390520c254970f49dfda355e3abe927573ffb7cec75effb30c172d24b642a64e5a68737767f2c122ba1d90fac4a0ab9ecaba155f5310e593a53993a8bcf87e77baacfbd6e90fa1a2041be5e56cdc8a15ff62bebf081406564ae77687dce3b311ba11fad599a1aaac2f559be7b6cf666b7faf00ef1433127ae6beededd76154009d718ca64e3a77ade452ce8670641def8999b693bc7fc5c4d94cea0eb44ae512d4f68fa4932a3941b7732386308091f8a988ff43cc225e2859fedefd81f637301796398d966ced848dc8791263b389e69ae3dd875f1a1c184284021c10aa1416ac039072ef4c18cfbf3857082b0a85fc147dd1aae09e17c3d8c58aad7b343dc5cf34eb11bd8253a41c59f22f9debdc2067932bfffb55d825d7e12dbf5dd6ee95b28a60bf23e948c3f03ccde610df1060e009091f8755a50288e102ef5f05680c89fa97b9d9442b2c13524a04b788bcb35d66b05f4227494dccfb5fac3f95ae9825488da61bd5210d067f7be005a434cfe4592931af832d5dee0fabd70422c07d62c74dd121d5af08b5692ca0ca378ec1a23df23f033bb810a583d476a4c6215a3f6759eacc404188f9b6e66cf0b8e00703b409c42d50c66da1c381250c16331b023222cd8d02174c5ce50ef4a1f59550b238593d1a786cd3585e23f70877c33d7e72d983ee005fc0540cf701a1d92b0845cf70fea2f864af06a9a355ea00432d06050ae3893fca472476c34c9888185f4d7496da16ad801a3eb7d55f45c2c88889d42a60388d40d98ea59b669976f24a6907995c0e03aecb4a5b6c7e890661d305f26e2c9eec1334a8779d5e2d99898504bd0d73fe7be666190309908a3fa46d10b1a6148ea3914d326161309892e43b1cf57fe73992b168885be32b7cbb3ca7a9f66f312be6b89f1f4f2f81f98775fdd68e225a1cc506aa5b14a01d8ff73e4ee46c0203de96b37bfd21683a0bd0d4df77a91c12713f3627421fa6e64f67ed9b35c932e900c1979f50bc66492f9188dd0af917b6eb79e3f96145ec461f4d692d13200e8f84174d706525f63e0997bf49ec4a18d21a3415661766762b49152b7ee7edd610670d4d55061e716cdfed4954435b2e2e79c71f2d5c0eb40353fe14f9ad208237d443aa0d0400113d98d8d4f3d8a5b925bca7f3e01039da1af9ebb4be105606b2fa092960dbb52ee768ff453e1cda93bcff0d8a23c5d8f1aa122fc38ff1d00865481405d751a853e13437abab55293ca37846a4fe9abb0f91063988c3a57ba7390aab108f8f346c29068ad605572787e706cc3130d6cb6ab7ff335b30b7581f106ca35127db565df1f032090978c03c7faaf2ca481fac42c157c3e5378f77a9a906302ab6ee5ad64b94e59189295636660c33aeac16be5c86e8bce5cf425a1c7effc5612c2d51de928d5f99eb0288fda45f030f5e48b2b090fda944d71dfdc5ef76aa9cf6cdc1121ff3674393497548e6095c0579423b1e9461c7d5aee12143e4b4976dfc7233d899fb9bec7347319ef7fca6b1a5b85c465353561a0a0f8eb29fef344520fd9b267f55043fd6e4a24f2b77a65674c8d2557008ad9ea5648f69b9a90536d8984752adc47211a8c9f70381209a700918b9e247363bdf365e5a49a880549a245ec39e7e7039fbbe6274343af360d54f8954c6062ec75038804672fb10804839aae82a28834d9a00be7198c1acfc59a749ff53e1282354438ff890a867bd3eaba9e22e16e6b3323c7a8237842872e0cac3b4f29782257685e12eb95d41f572a2a472a430038ee0b7c8a6c567a1f5b6953be2655fe05afa053c5aca29bfe6fa622ab4efc1ceb703ec6313e545aa91208eb519c011d8f5cb7a1a6d1ebf6c91be220350872d2b3fc59e773d71d3a9fa99293a8d4a38e5c761fe672531c9ddc9be67308d52a80717a6b356964b160ad6349e7f083abdcec474800603465a9b3274fe51ee45f1d141d47cf3e4f411fd0a0ddc406a65466598ebee54a47a4c62f0a5bef5fe258a8a89fba10c99f0d1eda82b77178f29783c22a66a712b59de0bafb6cd3bc3b2fffcd2841709b7ce5c29e566a39af6024c04ab03d0da67af9ee853f39fd51747d35c6a14582058221ff81ffebd0e62e1c5e41283a18d96786bb47588e76bba2553dbd5c793ad62bc6c46421647688658e4778f29b4820a7b84968db5c9e29c4a52ed6a1b6c09d0064da26b6fef1c9e36271a7f97555e3fa69c18913dfb9679c5d47de9fb6b002f46abda2a995f4356ec86216dc7d4e941ce3c7085b15f1b0353b4093de65bd86c45e41a9e7183fc0cae50853292af47b2a794869d6b82969da4dcc9fffa2d688ce5f3e70729ce1df8587fd7cf6bfd4c9a433bc8e663f6223c275537ee815ca0aacc78be71b79f5f916aef40ac6aa5bc688311eae8a7caecd15bd240f7b610bf9ed8e623cc7e87ac7442d504e6ed1fe302ac10b42141cbff2c3ea157398b02b609c44edc576864a8b6cd11b202a3ce263e186961d9ca2f663577e7f715f0019eaa48465d2ff3fa17ab705de01dc282aff324b8321a3a4ac57836c876d17ddd69fd88f914a81c7a1fcdb6f1efb793982b1361caca9d039a98974659793134df56c4da7296fe9683526a6dd138ba5d6528ae86260b9ac7a7af70f63eee863157e5f0df90cff8a14807dfce2b6002e0f266b83c1d3043b160929a753482463badbe4a8e9e959c70241ee0f556c37702b5df4cf0cbd69185eaa65199720b5bfab18db1de16abaa1dbf845d5f2922a25d34cd1ae81cc78f35c886069f760479dde615865e055c5704694510422bec1977f01a3b4828da1079455f3ed7f85b0f78799d1340c3d994e6a58053728f4709ce83b268c13d337841cd14819e3255a7361de37d5cbbba951eb0781d0d9efdf866d287d25918a648bbb3b71ef24725a2901e141f6f7eb51c3607aa64af4e3633334ed390b301c07ab1cdd5fccb2791ef960fcdaa4ad3f2ea9e4c793595867f1b8244b094d9a29eb02b77b9d1dd6fcbb6d15f3b28e1c29ef60ab3263b86e2f4906072b3c0c817dd7e8712c2222f513e1e97acc76d68acecbcc872d9139805734ace35090892416f30522e735a4d1a66b5fb9ecb13165808fa4ffdb1ed00c9dcecbebe3f74e2b1ffb6f76155a23be0ca6f53f24c3f1b1803282add2ffdd81dcb15b074cbe0a42110a309fad5f7936553924ce1f2f885f894d2ef4e5dfb1014c466cef5153b03b0776890beb1dbab725b759e5f4f70ee35d004a497606aeafde4a361f2c7dec531aa20e712734a768400f3496f1344c5046c1a62149949987fd3aaac0e7d1ad824f9b7be270822e3c377280287003e779ad5c84deb69cac7095885fe608da6cbfb4ed833873eac96e0f32ccb95dbe333c6f8fec88287642f8380eaf3f544f10251f9f9f4a33af46ca1d64db8bc6c2a564721188a90fb579641b942a796451e406e5f6d68d5193751555d1328fe8a73cc7a7cece5447aba1f70c8e61efa6bdfcb51bdc2f3adb040e6e78127ebf7582f9ddd80318aec8ce4927407a171c7d891f6a7b07ee4239462273692fe8d73dd86f8f40c8032dbfa7373eed3514aefa3d5bf026b5ed3b92a3e43a0953d8b4051c076f8dcb09e91aa425715438bff4278d9bc6d8cab2b7808ffb955a6bce4e91e61bf71e85fb5e01c5d72a9c27ca28a6355946e7b9130114e236446c2c5aae0c512869e92fdf99365842d8face30b12af365627be1d60c6a991e10bd88d2247528abb24801b0f9c0cdaaf6398f349423cc5fea68771623acfe0754a09267281959806cb3cec4e71929d191f45ef8f2002846eeb209ccdaef68d5b0d01b3003e8c0e1379638c62bcebf81f852f56cbee846d4285a243c90e906040946d4b32626741504a9017f5f3792b7a07898d1a8df67f9831d9604d95882716a8926e41cd0cf86143ca69e5b7f52601e8bb090b3bdbc1ff07336575c44d60d1e24d8cc43eb71069a2d6164510af67ddefe9254e89164ccd78153c1624befbd09b220dde47e19ff68e02ffe77776d6de9de95d710294ca3cfe3e50acd92168c1040e0bf7a895b03613f7ec7b8d349e58f01350d429b1e7ec91de0d9b0d39247180dc1d86a3969b87c6724802b2a8ac29aee7cc0276cf7f5312d3571070aa0ca67eab4a1c5431fd7bce19d3fadd00f0371f0642b65a0427405bde15cc084d38b7f3a7ee3c0cbaf9adfdb7f0410671d1d466b3b4864315de17c3fb679b04291abf129e0097f77cadd5ce10e7a1535c26866775634e0d2ff9784e04560e57943c8150d0a5aa830147694505047cd621efb41ff6c0aa8ff21a145b113e9f1a3024f8508d974ea58d4e086f27c0db39ac169f9f404fbc11f45322878fe7e086fdffb1b9c3aa4506fb0164055ce6311818abbf04ac919e15af9910550fc2dd1e59ca7500203f38ae4708758d6814d4e55c08f1393d01f08d0b0ada909cf7d1fc1654e7ecf64f636209647a57b86550625e3318bc7f1d4fc1bc66690e64e83dc2c1c7baeb164cff38a01ef3eae0877d5831ef6e7190905b695aca805357f8ed8e9a3f09e3dae252c7c80c748ab90749a61bb7ff47d0003156c80ac3b30f2ca78bca3796fad222218511dfefd1ac330898970c10854476483621b134e0af4e9848dffdc3a2277027feed614d7ec61c07aaf330bbdc93905cbd0be22a0924698049b8329a6b789052c1b481d5e5e184b23cb0bbde61c089899d017fc407717765464069f17ac7b2ff62fc6f95870e639a9cd11e22898e883181b986dcc5d69587d9cd412571c8c147079055d1cd357e226e5bd6877713ef977c0bdcde3f728d2e0b5ca3aadf857550e367bc650f9c045a123a90421194134f2908e0782e1ea5c465f9a2d8aaff9e4b8f16f1f902ac8adbdaca305616f6cc6c1edae4b5c018ae41f64b13c5454731f9e680198807bff24890b9d1b8963ce55bdadacc8c81d80beaa6d72ed7f215b8e50f84d7e95aba1080ec1e360663d118825ce4a32319f16673c7bd4845eeb410b18ba39e7b6dbdc2fe066420f7b72a67495b3497673a72e74a05ef23ab9a5c4adee21a1b29b8413aed7fe58989d3949c16be9899ffb632e65d5157060299d39a86b7425b06653c910e4e9251bf28518d59981b518ec8f62fbf18c13f27e14457a3499a7f997a0d55f0e55597335a57ce48d6f7da30b27527247ea244f974240f6f38bf96f0c744a6b167494cac7b345d6cad76dbcc5a9d8849de979cc5036c49f2736c8b1e80c32933c044f33924d64dfc212949233907a151d1b70fb59aa8bde2b319961034629f1605910844f76f8daca5a6b2cbef187fbd6588708f203f4683f3973d076e52f76525e705b1fb66e6790e03049a66789084d00c2f06ba26edde393749952d7bbee0fa7ea7fc8bdcbfd0ab6fef2a8e21b6c929efb9229aa2e4f031df2cea4df34ccf9b11c7d115b8f18f9647ec9d0a45ae2f2684869d4f75b8854208cd9bb774c3dabd1891ef5758032814b509b21977e6b8ec033ae52518a4dbb530f74600f2bc5c47bf6c0a7f91c7b006bcdcd200f0cc4faa995c15bfaa46d9010e0eaa080e32356d13d33fa59c1e75683c4771fea7288be888160e2d1f092d3c4771fafd34a6bf97d2f9345fab3a435247c29e2cbfffcf75ef3c0a0f4719c9df5dfabb925573cff21fccffca09a98a95de9c114808b30d3de66a3239002cd470559773f9066c0c29091dc7e6bce41a0e0913043c8f0fc02aefe7d576ee1fac19596d9f0b992368e784c6c7e3f2b4560c7b55bacbdd61d2bde0a4468e9868a54295e24a225a1c87f6aa5852b7fc1c79e3b511a6713be18a1d0dceaa2c363da0e78e0b7f911f426b81efa90c7433eda487aa64ed6d53017135512eca3d19b6293b79e40bbe29a1e052428778603c804ca6cdb0ad3fec1bc912937bcd9fd0052be95eea758566322b593ef8ea1a5ef807417a5cc60c929b7c3853e83fad1bff5dc833de129360a4120ff20e864399dd3bf19d81cdd2b2cb67ef175b4161bbf46ec7943ed381fd713435ecd6659fca4fce95cab3a3e8dcbd552cca11d91c0ddf2199b44ad0daa0ceacd84a9bcedf151187a24691ae7d4baea5b1177d8c8d89c39ad352235d0678dc14b90ea7f5def3031a740c6d76b8762ad06278d096e860e4f67866127dbb6c43e99fb91b737d5e50e5769b8a69ff01328f5ae8f78ff198bd28a65154b31da0a7ce0d62d339a30dd22ed8a4fc395838594dfe026be19e036c88017dbf4cd1cc036f185995011de3e12b3ff7b3e20aa779e15215a3fd8ebc13ea6ad4c7eeebc2e65a3a074a12cd989f3499cb45bf86a81aa9e691fd308b2cd9b2b9aa0f5193582686f8c217c4891649a5c53309cf0742d42f83bd3c9664e4ae26bf32090e91ca49e1a31adae0467d106512580e588f8053012a1b1914c144dfb8d86f5620abe8ad5d35ad434336ee8af3f2eadf32c1141f9dfa26fadde1acc00cb4775faceeb560544d3d38962c4204a184644c7684347ce660ea7e398c2fba5a806aa3ae2b1a9f972694d97cab27f07049ec9d6b81c684892cf59ca26d484d4d175c4656e1da7ac39dbba46a460fac0c95b46e8ab4becee85dbed82a5ba96e95cab23fda3853eddbf327e852ede59654944af229ed3bbdb0a1f8d89f3d1727e1c16c09db0f6b61ad15979ef0f12c11e388a55a47992c543efc5b593c8734c6d89e06ea492967b1d2b3dcff988e6ab3f7da3104e6cc75cd34b4a30c897e8bb12209d8aaf7dde9bae3b1d05a9167ba8386cf298e12d078ac2f35b5d82f62ad664f701f058be9be247b455980e14486bdc331f59212a28c57056447b90c4e8b0f6a28d09dc02bcbcdecb340b356e30b66e18139f57f2fbe49933c6e7a9f7cd340aa566879e95d41479c4caba6d0ed54dddf1bea20a090a094c511d75e90f54b77d22c0e40a6b1e6d1180afe3750fd7251517b3ce99c18fd7f6b67f82b216e675641ea89ad10ab27d7b63aedcc1f86dd244e3b9dcff4af997f0ffbc6a684a0bf1cc4d26c1f86c5b97b055fce9bd1703c301c1890d34e5c78bd1aa5c626820517ecb780e5e56017c9bcf7526986bd945d9d6c8c85f626e681febc084785563b26261b9ecfab4d440f9f106a8e933087c7a00809e3a17238fb649cbc6cd4ea7271126aa6863ab7f20aaee70aecaf562fd5bf5637cd091e46ed05333892bd5a98f6447ecb822215140e7cf0525e8c1e3815ceef111267fd407c68feac694f6ed6fe0ac9d7c64bd959db4d16d2d743141528785bbbb7a5d1af9d3ea0956106d97f7a9753f86e15883c3e155e5506ff3601bf577f50f6f63a9e114e396609e9810e92730cb35c26b083d77a20d805a74d6ae980ce0834c3ab971078e135421fa3dfc0deb1b5a95d5bc4de3297ddf34c81a08b2ef50198b1a3a3638e0d6846e21d1009dd967a09141ff39e1a7f997e941489361489c9f0410d816a6e00f12350b165caebae9e3ff7c6f22c5d9d9def8f740af12326a79ab8d08f9deb955b07a760532410ff44fa12bc48dea38b7cccec28a2bbac90ccdc4f63de77f0e6cb5ac22b26e0314892f2fbc8cabf050bc634d7ea843ff545a5c9af1caebc4d719db3a41c95db6871d06bea4a269a634369fd163b13953802ed1cfcb42f1d163f0d70be83fc0b0895e96e9727c451c88b419053f70b974a18cdd5a995577e08c6065786cc786d25d0c8a77db4d5e850ea2177831b107dde42ea103b5d32e4f1625705dab9a1fcee320d4db70363e0c9e8d60d66866904784babc3e401f2535cee410518616b6d7e13e0083a12641c52ac0814e9da88be4d46c07f4a3579544f15ea08efa40e2c9c141e817196f8f2baa2b3c1aed428e5c317f35d72d2d0c26851f3d49f5d3d2a7cd1e05e0772c4bf8190f2814f460bf51c0631451de90ff5ed45f7931b68844ccb3708bc52d6478c2511ef5ec2e0ab0e78a88157c7310c7c8d6f3aba66ccc86df6d3870132cb3cc277f7d02eeb6f47c8b0ce2c59e428f108b2a4663db54f9db7f9d13abceb2c44098bed0af02a0717063a2a4e18c569e656bcd340f46d4db7a7984f80a08a90116caad96187c7ad654ef50e77a113fc211c08243164b7ab27733f392e881211ed715081dbe75927553688514da3c00fe295edbc7948711dd17c43b97afb55c414963ecbcb199056df1ae6bae6282fe861eca98b356d476215154853afbd289f068748b2e69f601d68d793821882993da11939d246691844aa661f3fc7df6fab43fa593c7d437930d4dffedd787bff9fdca2a42b1464725b4d16f5a030d9105b1c5a2413fd17759f53149a0151a48d7bc8db423f2256205d55a195e03ea66da69ad63dab11dfe556a8ff312bddd2dc6f369a8bd0ac3aba965a9b7cd580b121e1b94227e978b94001130cedc51f3b69afb26bad4a4a9eb33b37c45954afe08cb88b4a838694fedb5f8558418850f7646285f22797b39dd69b66e74a16c2f37e4b511678a34593283a637083ef92c500c8958d18df6f67028bedbf2fb2c3879ae600d78bf1e9fd3b7da9af712c1a5ff0819ad1a940bd51fff627b24553c140b7b6b84402d182e57c3ad047574fc4206da7255a541403f0d1dd1d53ed3539f72c7569bd8d317dc70b1fbd08c70ee0edcfbd713219be02897f38e8f9ab61d26eb83a4c3fb349bb296da307f4c302c3b1e911d1f56f7fa2eda71e42e100cf1c39b2accec028750acded74fa7257d84d5ab3d5c5380d230d697bb100b66558b9464eb4e08f8c4dd3febf60d92eba0085afd96c683456a40c7da503c76bdf331a8ec30618142c193375972b48520c5f597d430262a6435d3ef95464a0aef05d87f5f25d7e037ff53d927b14c13d08a09d4b89150b6637bec324e1f90a87a1db96b7c7f6744a56465685c92bd49867fb494fddb26e7a4e09bbd03959febc6b81f5eaf4437711cdf2db9dd6ccbc3c640e4a8a238afbf8ca0588dc51f9340c410e28b9e7526ead2ec87dee6814fbc73eb749f504e1110662251cad7ddeaeffeeeae44b5016bd91d1719b646891ef06a60d7f762914a2e1d4b36ba637add02e6c65ad6fc00b822d01dd94287b174ddb1a0c165fca9704ffa2aa53d0f66e4606e9b936329b77436333b4b79d07ffaca46c8e6aea83b3e97f4d358589a2cfef6f6ff1a14aed887abf7b4e2e6014c01cf3ce365fe261237237afbed877d3dfedaa1ff85eae916bc8fa178a198b48eb5b459b87666917d3eb4104c86e2f4d714bc0e8dd54fb9f2126936649bf588902858d0560e75280cc77155b5b29739c96d0bcc7f6eaa84cdb1ba3129384783b5b885f4216abd474ceb4dc0e91927b245ea9f5f8ffe05b9db12c02488104050f0db4a5243818ba22c2c739e15b66b452dfe24b53d8eb2d585175701e6a76018ff9be2506aedaa89f9540af16e0387e280d64d5a6310923de0a9d7da0e9977eac6817b1cacf73d883964b92ab733c5f65587848e4ca246fc851e7148dc57971b6a07e7ef2e679a3d7bbadc231005ed924b9211de1e929b2be4e1347644dfdc646cffe86d30ff86ce212b235b758a5389908cafb767dda041f213af0e166c70054d8ce78b9d5f79363a02545e0807be1c501f79cc931299267ab556927e58e41b8394a9a3aea998aa9f5d1bc0e16f6734e47747fa81592e7df44f2532e62bb74a0f13b88be8fc0008488c163a126ce8bf3a5adca68f2d77384c89c492071590d878e7698172cf395758d109e4373a53a0c78aa34c6834b675a8827b3d48624635a432c8b37d130770f5bc21ed540ffc0ef21196cae89cbf945c690ab3de2dad9ddd7aa59fd21bc5e5462168a5d6484b1db14feec6d421b27b945e0d4a176cba668bc392eda5ca1c96873e1b653b6d99dcbf42274506c09c7790626c6a04c0574230d1271b5b7b82795a5a36d1555af825a17fd30df4b2e577a0cd2d858a7f1c27979c06c75a8b32409766793fe08f268af68695350af9e54363ce97feb17b2eb281dbed3765e9ac04b3bf48cf1b9860ddb4359d0887543ee7da4b70f6d84691867ac56c5a2041e5419479bbd3b1fd3c5e258b20a87afb2deafd7496f9ae29c9b09e3b13457dde0779f906985d87e6c11f0c56e4354b57733305daf706593104c4bdd54f97ece704abab5d4028faff5c54b758b4980c95daf79305213f7f6259378d257abaca6d0507e059f765059b0a6d06f08cb75cf5271bb44eca06134bfec0b0cf5d73defd7ccde2ef74f2fdccf7ec6ff69a65c336662039466e2440ee8d541107de9a9ee82e08ae967ccba439ca8a71b115a8f1d795f33477501e8404299d0cfbaee56e35ff56cb30f2bd395e042b00c60f9bc3827c68a2799303de2804ef9ef2b04764a83447a169cd48d405e2568c84cfc0317e5b1e820c4795ee225ed79b24da947c847d3c3b7f6c91714458f2223b9edd76899a824cdc65633a5c5e4eb0589f255c342de2234b49a4ffa5c1bef038776f8e1320005c7166f27408100c530b530dc9e0634d7b7af3ce6391e5368ede10e74a40d4ccf1bcafe288bcd3f07c0d36e1d13d02248a757f3d31d95685e7ea801deae8f7dbb4b901601d625bb9c4a9672de5511603b492cce8d56a0bbc5e04f6b3b9a5671a72387cb394e3d6fea4de91ac165aa7462770090ae69992ad293ae76dba2412b52f4e37c1fec2e00f107b4d25236a06b6a07bf1bf2dcd4c3e98f7ab9914685f3d78a89fdae0e7d14d4e2912cd10dea72e1bb8159714132d8c692f7e88cb575e62da68dc3338fbd2fa141b60c7dcb1eff611c3128b16ae0078bb21d83a75d4871f5076ead33b3f0a8020c2ee967137e1e7c4796ba99df6a684d16c00fd29ce1c3797b1e260b716ef0e8cde67d29985d89b360e5d14810de1d1de5201f46ead4ccdf863382b8c63c82111a0fe5d41e3909c207f5f1ddac61b78d847b611f0403af55785b66fa08cc20192d4be0ff085271c5c7d4cf0a23fd518cd842d5e50e832b74112bada25a50405937282eeed551281dfd3899c2a21b7e4498863382c142ad14f69227d31455d5797fa72058482bda7afab8481196766811d06612e6c36c096d7b001c4f1d84c873d89e9af041e0fbe8c6c3d0d32a5731836939289b5f8729a588f601b7a848b7f3fe75b0fa537daca6f3962195fbeaf656ff06010256b587d915ee9eda1c4147a134ead290ef7ab1b99cbf17ffff11e7adbdbd23f527eb1fce188e8fbf10ef154839cb1f9535c02a1ef696bbbcb9184a5e18fa5ca5754612a572d0c1f0d31a2839cb7b77f1e249bdefb21dace06a799d2208803654e9e57df13ab7aa4f74870cc72b937b3047280f3b5b3269e396281f835d19c21cd94278e96a90dbb878b6e155f88730356922835aa7a56d4aafc45ddf87a6fe8c06809c7cc7207e6ebafb97a9169649fafade0294cf41561a8c47322cdcf4e466c1b651ff3b2610e054c784ff5a0958b4cc2d31717f853fedfc6bb0b2a98beeccc50a0ec68d1adf5e6dd7a370836276b1bafb4a99f7b527e1ce489385c9701f44cc3bbe7fa8e5dfde260646a53cf37d9ff28f66972a41c631c2b9349803264e37d35fb69ec830a29425ca1a75cfcf78eb167d13f914b846db5243ee60a691dfadb67e61b599d44f4d44ef1688121f2ca68f162a77ada892cd86cd33a650a425ce8ddb753ed42c0de0e64c808a8d8fb6788bf3e4c92b97a2e2ec45f492973a9b0d0934f4bfe9477c12866d5ee1b4cf61626e51c7eb69ac85b3709fc14acee7f1b06c8e7810e155643be5d9760391a02168528dc179ab2dcc2a43ce14e8bcd2b4b6c2dc00ddb930bf862793d060ac104be94e70e419e7aaf52710081a1ff555cd24c2de613b981a66e1e50d160de58ca53a7a041192a757d4df3b25af226b53188c1002394b0a8347c3ca2fdd42f926dde3b0c9cfc684d83a5bfc64fe43e3060fd22855a71d1737846fe595502cdf82b95419e47131f63b35ae8525f3b498210664ccd7647c7abf59f73f04e35543d02b48d08a7298acc5b44727a79df6d460b4257cbfa9819579f5ce4d254dcbae51c7e49492edf7cd4761a180d96931b339c98d089d3892074cb2143ca68e3c5c5c9b86e8d6828389af2d794a5631f2423821116cdce4e6bf18b0e1de765bf06a8d7f0b2dab7e660b1f26db5d59edace23c297462e03ffd2f93907a715c1c28d9786ea9e68c8e543b42fc5e5ea8c3cd8f5f07d82c79c9526d2a10bb9f95d5f436c92936b29c07f64a59c65a64f1afaccf51d4346d173542cabd83085d6765f452b058d397f2aed30087f6b4524984247e5bc7b06c87ba69614efce5bf2a0c458f95f761b3eeb3de752c73e3a832f9e5162fc8c64fc1e17dae63e6b6eafbdbb01ce34a4ed3301b73f400fbc2e722d46c9000204c9782cc708fc9e0482805c572904c60e61d8e57caab5ebc5bc251aaf82338758c7fb19b6f18647e04e972b75a9266a4c630f501d5b16fb4fd101e2b693e73be12c6b12207b628f1d5c32c854e0118922159b44a13d29ee67ed20ba38ea6d4bb3eebd8c4be39f03522f0d15b70508c072e54d369bd4f40925a093bf89841b8f8fc967162b8d9da6a4a89941ca8ae72b048147c67980b01721a4c7da2ebf4c6f87ef6c5dd6fca21e7474e9ac4dedc70658a9474a25d0b59cf6b764be9db2907974e39c4b3bc02a0699c90c73f9152b5b67b493e0581da27bfdf7b7593d1581cdecf40e7568b0446e8082ffca813b988bcd311fd5249d8bca9f65191502b11dcfb7f86c69cd6d0bef2e323513f324d52a5517c8271d4315f3469424cb2959ec40a28467b39eab590c93e3f0bf6a7ae76860a2504c236b3d78271ff9b62eaabbca8d4be3c380d39bafcf6f449ad708c7fd82e1f304ebc93854f32d8c1ad4027251ca502725419c2240e1ea1df246459c4d308f35a6f3d35fff7291181d853bc3e2e5370e1efe6c4577d61083e5c4b350a7fd273210f4fe6995030217bda931582c3194ce5085d005af03596e9b551b36afbecdbb0146b1a3e4e02ba655600115014ae87725e28603b25092e74504fa75add95de590266c4af2345dc567f5764b3e0678a1efecd07ce3baf818ec0b17ef0a364fad49dd227a6655206150ff1c0af171dbc122d650093c5ede6cda966b73c0b12f336355454237dfe9a9e5cbd018cd0eff8dff6d35c12d246a3a221bda80c6f5ebecc85a336efc83dad2170abf0ecabe2457d640e5a4688456a5f2e682b2b247483e5b5dbdea1800c33e75da2978a3c2b04b82b40e57e92ea2175872a30469bf037a492d8fb75176aa3971ea9c45b65c9e6558d3f97c79ba3a81eeecfcd77bcf60bb6d0c156ba4855e46d670462cc5","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
