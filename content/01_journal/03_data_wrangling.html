<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"d38b8905eeba929306940d47fc50c67f34b01adc950d3a3bce912869b2b59e1602016d7b9c4e5bd7ed73abb21a5db19691837af199b363409aac8838026bc5422b6906efd2ef07da34e665e63ab074a27a81fbae62bb38ea7130a3a8b4a7555d72cc8acee38f33367113eccfdef6e3e2f4440be5a9f78d2e19d98d164a90bcc8999d221239bd3aafd27fceb5b4138a4edcd914d417312a15869704da7a526a22c8900f14222097cd1b40745a75288c719856bfad39776431902c02eda9c0828d1a5e92deb888f35608355a42b6e22466c94af77540c63d6e0ce2dc470f09aa146bf8fc8cf27c5c9d423646ec6239950980a15a3955fb0d04109f28be3735c64c526947564042140a99daa8327c0871ba61a3e98c6eed963db2ffc0bc8a4c2e7edfef894e75552070a5b1407a8f4defcc735fda15984e6fb01b4d3ba7303f91eb4b30bd62fe6540183fc11682f1fb1cf5dd0929752d34e840a743687fae796ad80747d6e2f360e42743df25a7ff9d1c8c01cc6acc3789b13f8c58f1fa1742c93029b6fb730cd1dc484954be8a0cf52a9c4e8184b4ac0b0982f601258d429d86726e07dba2bf41269192f701d6439fcce220160bf81bf1fa5a21c3f98fb888642be4fa34b58d9108343a35c9ec54309ebdad22a381eb30ec9d1b541da902e0623c839007cf06c95665e2ab375796eff8ee64a8736b41199b2ec0ece722870c4d867377c731d764de9cae76cd5a1ea6e857a441f41def743fef8d4438c4e307a2ce2230e8d18c42319ec697aa293161f1873902b4c638aede606d5be1317edcf46150b614fa433d68383aa4daa13978b4e03f33ae4c20490864f8bdedbb54ebda50650994ab5968a2f6b30e03c36aee4ac3fca53447ef1ab42701f558559cd55e37ce14ffa4a1f8f14b735b89562edcc09cf6e61c45132ff5211b509048851188e1f8d6edf5677618cf3f5db6bd5cd1de01f55228919a85e714c478cc1406dbb1cb4f5fb131748b65f65220bad4abc0c3e75e56a89f507a273335dd18e2c3bbdcc5aac52108e1b0bd0097d83affa8bf36552e0bbc2ce8d313940dc3ab46562604fae68b145f137d97530115493704d6ad74a3414a5f82c91102fec09d04f6b05e89a5e8d72b51568cefc5c5a144077861ff7fbef12f7791faa709b70625f7888319232cfe5f33be0658aea945771cbc435627c2c1470abe3a5a29eed0b9fea77cf074dc30c9d85171cbe77e2e8b0ee5422235a30048372d619f498edf4a1d5db3d9d562ec4a9f007e0c82d4aef178b4d93db867e8bdb4c502baee7888d23d0388e02192c80850eb5179ada4ad1ca0ea0c46a8ccd2e5f9da15d945019388e76adb70de871a80662d5e4e42b6d6682027a59968bdaf09b5bca800c06e56026051f59674b73c5d58f3725b62f76013608f887189e0a970a09e3035810ac7fba8c085a4ab8a05f65be78cf7357f509f48affcc61604c340e182c9a558d1ee6e12fcf54c94f1457d16ce35578d1e0f99544c60f1683194334ba16e84ca502cbe2a32834f6859e12385f5f827f4ce6173053b7c088f9225385cf928808530ec1b5e780571983bdd60697c23f2bea90981baa54b20c3dd975e5969e55ca4cd9ebe3fc73682667d655d9b27c1e31c610b33c291fb3dd57b4efad5fc71f5c96f0824d2c57139552975a6f1bd82343b921dc51ca90c8da99b33ebf3c4bbe71916946a033aa1537c527506d98886e6aaf809cef349900d3226301c8102f5bed91bc42c5202ba1a8754bbe0ac817b5acc3354fb869cd7f6b9417646f1088fbb9460cf562764482c7b8fad3b300a4cee1f64f938229599b53104920539e4f65f3e4f2b7669863abadae30972b25b20a7f146b09e05c5f7d5edbf0f70ddab70dda37506dcb8fbe0ef39f9325e469063500353baed85d1251fea048dd100fec26ece0ec9c1a86f01d8d32a83d87f2c72bc72e73ddcbd6a5a6fc052384958832335e062f826ed43a83ddb2b25d1756604c7cef0f37b7b9cd152b2c9e0cdc98b4d4c315c7ed4672b08aa63321c14e236aea37af5117ca2edcadb1cd31eaff4d3ec86f063bf3cb380fb9da0c3d1d3f7cb50580ee1b1c4b35bcc08cdb9820c6515fdfc3f6904d4248559b3a139e7e5c2342f64c873f19c823f1c134b42320e83c88ea393d432129c8cc3f50d905d26f074302672e5ee90482680a0a4bee3efe69a4c9c756c2099ab4f0055015c7d491de7aee4953b47b756c959d1ab574a6e0a9493b8d7127a396cf40364bcc1af36331319f8ca055e57aef6b5e54793a9adb37b5bdcf78038491e7b4e2dbc97c07bb74e94af2431512ccc1caff790362392b2270dad12dfa8afd57b35629486c318be97ebb7335470170dc6e332519ecb3f01a7cb0407de952238696041c16bc809ee9461e4c920dfdca91b018f928b9c16a0ac330809d3a7fd07c4a8c880f34bc63c84dbf7f3b84a30a708920ae77509e5f90f962c014f6a456b895982505d02367f61bfe9095a6fce8a34fae7d1c0b4ddacd7c54f58d4e3a36a47c257231ea055755267592193a63d608e725c194fbeaa55b0223ee6f6111b31ccab9927a0ee303d5724bf752fb81f9f2aa9cbce3603ae870f89fd0941702604458c7cd73aed440713a43ef27ddf02c2a64e4f333c837862968726f3617b4db618b89a8e56d149ca79982cb0ae97ff6d84f79f6fa569ec05059ce8f526e14dd8f300560c21883881b82140993a504b93a13913b2d26150e1004321e076486293170cc5bffe6c550c5f84307209abc706175c11c85987b0d9f3ff2b4b6a78d057678e49ecb7a5bef15e9cbeaa73df93e68e1c1836c59a81e3e1644926cab81ef21be4c3ff7dd2853e865c8147ea85a18fcb0ba1e1f3d118120254978c3532e2118577f1c8b686895f2480cb6f0cd615b65b577562591861a17f1064166d09f41ab348ff0b46bc0294f54d23928e53d5db4059c9cda4918c03a2b1718e0cf6c662800301884339a4082bebe389aa8a20dcee7764835499a2d698ee0d9a93ac3dc3be5d98dfa3af18fdfab3da19e64d0287d2298aaba364eaa46430a5f40b1c89b3d00c67055fd81bcc79a1ec4520b90edb72b7d3fc549944256c9cb8e2e5e8589fc48f7f492a000f560c514c123f47b00a04526e78f0e98d2839e024e6716ad283fe51dec084a0540e41007c03cc97e879a7e196057fc534fcb1611073a7da174d921b8adee42bde7c62793fa8d746d3ab2dff0f54a969ab4a2926afa2aea871ce52390942d54ca1e94811520aa57960bfac4e3e2d0e401c80b650aae24e8b27f06b43d9cdd9b0aa167cf17bfa68ae870f6f1786dd0ba687a0d63f48657f24f65ecf965936fbf47571b86c7b56fb69c74f45b9195fd63aceffe3669c4a91919195270dcc06650ee93e8c08d16feea4a0547a56a7d3fa2b9ab152a80e890c111d0279c133cf5af7f3039936163f7dfe7eedaf31fd71be59850b1f36495abc2419735fc090d17faf1bb01a186387028e6b8970e2df2f7561fc78d581f61e2c24c9fc40da682b46c4aab770714d862d70eab653f73a6fa70f0e9bba33cbec1ddb7820e60c5b495f6dcebf5282110acf64c3e660625bac0d1207110a0e87d59fbb1f4370e48c98be25cc7c7ee06136efd00beec105cd38c8e30ce3de97b8d37e5eec6986846b9f3c08f9774d20ab0f91231d359afea3650f6cc63bf64426b94bed466674877427fe70602e0fc7767c2d0b1a967fd7d4214a8430408b097def8d2912fb5042dbe4c51b651ce5fe87ff2abeaa57f67a83682c3e00e76c641fa56babb28ffe6bde2f31bea3fd36547582b8d9d528320ed979269b16e23d5fe403bf4250d39f3127c16aa2d3e8bf6c7fd65ab47afe4508238eaacd36b109c846cbb6e9d4358c0262a76c9c47b5dee7d6cf171b6c2d695f6a1e7c004e0feb850974582f62a74651ee8691e734639040d206c5d99d068083a25420d268488d35e1a478a038b6a48ca5fcca610d1e2a0b0161840bd85f8be936396cd7f0b140a54fc9cc77518436be58e3dfeea5b47c487c5472f51044001fc3899fe10c2974876b51ffc13cc1c4d9bb6c5960deb08e75b034aa9a1167de485d5d9307a05cc5b2025f6e0cd8b048017fde8b978d5a0c60f5f6823cade434b9d176ce5d57ece7af56bf36327cdd0b888fbdaf242e987c1dfd9c528307faf9129f2f50cda8c2f6088b7a79235fc9efa0e52bc699ef682873ad62a5b2d4113e0f0d868cb5e0d4200b956eba58593a239640f38791465dd17fc43eb175cc4fd243d6d623500c31cfd48881cf5d78d0accb6fbb95d7ab74a04898be85dbd286182314bd8bd306949b9b18040691a0c23336f27b32d7ac50af60f9c3b4f97d6478e79156cab18d84439fa67f5c2c0526866c785f829bfa91eec946f79b1250002e6f8eef99fa2fdb005014bf6147f852ca6179b8d605a10a7f77c4a09990b26584f09a31dfd81cd2ad7935c2c07da4f61c51f2b5454d335505ae1baed6147e1961c48925f852106def36b629ae3276706b26bd497cd4d727dfc7f9051ae5581c6773d028d15441e011fc565a15e1abf89b66b3235d7fa44860bbac1ca9dc211354b31fe3a316729cc46c562053c627f0212c73506169f95b2b1957835baba31b8362f64fc7f848f419b6dfd9eb34515e7ccd87b5363464d805f89496812b5d81488227afe32c7ed8e6a268c44c8eed5674cf47414e634a1682bffd508d228ba58df9c5458568ae1b616c59e56b5e31641aa953c27d6b703312f62bd39862b3f3f174fbaaa72aced7e706377cde9d89794fe217e9a21c34548b85086ab2cdaad218c907ec3d4c874b2f84d3f1ea62a9adbeb5bc8aacf33a4c98df901ae536f6a31aa8508e0578c7c0af4d58f92319df33b96d47c3f76d5f92fdd38345a3df8e20a6c7e053484ec23f215d51d87e7b19b995b0171298aacd59dc140b63652d8058c6c835abcd3e2f965b0a6cb50ade6a7ff757d40b2d311552ffddc08ae33d12a72e870c25ec088a9defaefa0b9020c8005c5cc5eb986d9c559fd061210bc7e505664da7fefd69053adb606a74ca2407a73a00a4068a703cb8ff0413c7f0bbe23b6e92dd5531decfca7757e2da05d11cd74f94edf7cdf87e6a8eb26e39279055eeeb532633d3f8542e296d6a6dd6004789b59c313c246fa490a1d40b8f80fa31a26dac686b9eef18fd5f2722f3c07b3d780552554436dc9917c201aad32000405a2be79520a63dbb0010fffe47e76e3d1fcff28aecbfbac11903cb4649ddbe98a68393c77ec608d0460670b397184b5734be5f01f3ec462da4aa2f2c233e5f81c92b68d36d0034d0292d809f51bb0f26b3d4d5de28a9bfec283377db0d75c7bc97a1ec351a2d7e980b639c2b752fc39317adcd1b3dd5bd7981ffee3559b8f982785fdecde8ead7aa0bc3ba9c1358031ad945cdb734cf5432771cd51b65d1bb9a8f0bd63e96aff8db05c2efbc7393d889e371f507b927cdf714b9abb93fb792465ee15e429c09c25498954a1e05b8cff70ed3b75270ba5efa934e55512306af0f19b60499dd54921d3353232f4ef4b6d4310af4f3c30a4b9e92cfb08318e87ab388a160837b080ce9b947beaddeaa5b32ae3e3ade45dcb7a484868152727a59ab7584bdcb534b66fc78fca0a39251ff74bf5390a850c9862d39bf7d33b058ad31e68c5e31101f0ab5da48adac0eae1d70e1f083fb4f0e1e3790a8c7f74076dd5e19737056d3d8fd70f7e18ae57f6b7a8115ee12e2cd4964faefa95bf9b5a33f9e0411b9165656353e0063554d91d83e7fc252b111ed5b04ffd994eb85dfd63b4646bd552e7435bb6278b9044f07fd04ac491f8eca2edddf6d8f8aefa1a38d47b349825ad2848c28f4fc7801ae5885c2c56728a429e66a44d987e52bb237d8707da2d590fc27facda2b68665c7a39bc9ae5a09fdac32c7b926f1414313403fedc6cc5b4b246503e6be1e9b9e416732fba6896306fb383693698321a21073bc0bcc88677933fe04b7632c3cb512d5d2e32e7ebd8b476d67945b27f0927a0bb3dae8a8f2609aed7df2006d99d05b60f258cc2c2281e48e24c01edf012f56649376407433b669c7e677794f71ed7421e7d37293de04b9d800164c46a05cb85602e985a6b7d80f482db34512b3ba2d91b27da42052343878a5b790e52da2d94441516a7524b520d8450fcd371aa1e1147919945877ed324f89628cda1d4524f90d85f467edf2b9141508b6681f8fc66520420323fae36aa1f3163f34f15f2e0cfad2383ad87d03b6b41b951fb3dafd66972936883ccdd297600a85dd70ec6b849c3b1ad77d828cba357a4770546f15d3e8fadcb508551c6c99a51963888e84f1c09229a87f0ddb65eff76794af967a766e30c4f19ab0f19c842ff00601fd8c42e1c4a00ebb7605a50c6c2453b4c9ed42dcb3ebb2e420ea1f65296f1f8d3ca2f5eb10abeb6566c64b028869caa67071d0b30089728fac7e008fa89dc67b0f4a8258758d9935ce71b835b0d3f4d54a5a1eaf6e853a7a8e90b77766506cb593dbf00f0524181adf5664c646c6321b3611d771e0a448a83302796e3eea4eabc2363f6c4823ca90e2becb2464b664c6ba2c0bc257645c7b6bc7d807713b778325d8972b0e6cae8bf44f1ed049c40a662d76a474eac04158300aa262c7652195a4175cb6dadb6ba68a49088e38c0b5ceded5f4a01cca46c2dea31c887efa53bb73cb74972d36035285053c405009464242746b5ed3daaceb6b633d63f6d15ef74548066430a289d1b2bccf03c6c405716500280cc4e6befdfdc96c570a1cc17bad361c61829559f14e42b1c04a794e38a556ad2982db01faeb97ba721481fed7e3db5e9ba195ef302520183f385cf14a4cae47b8628ce12300ee4e23f69d1338fbb8b84f26a1575f82f82d628a742468a78e6114b8cac357a4a0721451f66448e4da9328b309e477f278a10c639e78b88f822f91579769b596efe8ea7429d88c5635527938469c5e4b6ac54a8b5ba6cf5bfded501ba84c9facfb7d467519e7411c367254eb0e1c2df7507ac47d608387412113c5319b5daeaaa36d2e1b9f7f540aa0f811999b080902f529e2988c6f35ffc4ec43eb856b401ebcff537115fda84e6cd19322ad15fdc8769e1b1f27c5920a484cf3985db52ea38f9b5f6fda4e8e91119f86139aa446a10c1d58d1c95b35729561f932b67dedfd01850f353a33985d1c76f37c737e330414bef8b873a6ddf8044f99ed878acf3de4031ee386cffac53d99b50c6d0daae7c00360acd426b75ab865f90179505f0592a41d28c6a7e9195981aa06020b47913db03bee88f28ad6520e706194f77157da2d9ee849f5c96f9a99a0ae37c8584d371307b489aba4dd2a34f7ee40a733be35252130f431411b867914b88ed95a8283a20c72ce919bbae2027eef680e1f8569d7a10482b47cdf7eb76c301cad4d7daf017d363e43d6c18b6c26a3817913340e5922a5c8b096463f33f701989cb9b48e57709e137924818c6db0447e6b8265590f4a270a5bb81e9b0c470a403956a03c4e2c68c273f1431d743085e1fa38dfec8cfa3d532a22b1641709a50b2c850b7f316441e430cfad598d175cada10d6bc588fe1fbdeced0fda3ed134a16de3acf52ec685790ca10c98ba81b5f94be9c2318af14949400f40b3788066ec80121c0df219076c1ced8a210cbb665ed7b70e2dc5f113f46684860ab0d972fc47d2cc291f46f875d080a2880ace64aec1927cbf413f60395579a9ad91173896e5bfc69c98e15cbc2bcb0804b15938100eb2b97605a0aadbd232e5304e593fa6fa087f0b7cc3db31dce2f3334868da1eb7a860e2f11bc10b64fb5f9b9b62871a0404e1491de5d6dc2765627ddcb2a0d55bd56194e125561b006c449a3e01f2e573867894372d9a3869c03f1294b0d1529aa984bd80ee1c7d6a15136785f6ed65995c4d4a3276786fc938cb45297a323a117a7b608a3e946b2d94cdd8a26f61e10870efab371641f6fb0c30487aa657c475f98d72d85e6066f16c25161acb7d879774072c2b2119c23cbb91350f6479dd6246e7c89a28e9c561337697c814ad99bec7a72c6ce32f86a0bcdb0d24726acf764ff1e636b54a6973c147f628714054d35ea1f725bd066031a1e03dfa11fbb9d55f1827d3f3522218d8259565938e28caa9072f1efb7b5b7b8ca453ba3fb65f66abdc124eabf94c09c9e9ce935e971fab6a40a276a28d18eee0869316de2ea32df1443fe4f7eae7fadf2907e4508b4de7c7fc473c069578b02c24173d216d711b07aa6072ba070cdd466afbe304c07be4fb8c2a22272e92e1c9e67ca9d051339d0fd8b425fe911ce8c94a2a7cf1b57d41f091d67f15527c03cd016f3db9251d35dbb44a771f286eb4d096a9541a39e837ce6fb7a73c09d6d632dabd55a8d7a8d13f7c10da47e25806295398886a96d6f2d7833db1361273b050f0a9020e27680ec068797183d6f5f8501e50160adc5186462ec0a83041f1a8d7b61d59b0a6c5854f38823daa15708eba48b1ce876188a21fa996f1ce985ddb439cd9a8244d4df3e6ecfee064b809018b6a5fb24da732468086fd9910d6c290cb67eb97d68bf2f363bacfede2489a13d3f0d42f5c62b2bf56018d00f7acba3328f3af78bf6ba8fa2517f61f3bbbbfbf0dd7a29c6b6f999f3c252c483cd16732db9f45fcb62b3029cfb10a91e7b17e767fccf7aae66fb3fd3351b4785d68052dc72f49094c61a20d4e7db0742012124b216597fdc6699971af22a673ad878977c0f545e24c088f1690890bd7e69318172a4458b8a22a63a1784df8c165ac6ad0e289b61ee8100e96dce392d17cfe89f534b4ded8dc39c0e4c5499642f97726adc78db5ddb34157a13ce4828892f85f06971eb50e79abdba34108f4a4b5340f8d7ac7b22a340853923a57b5c64f8603baf1cf68f1db91a089f981a558359d118e747e779cba07da9260b5eaaf43a0efba24ef9eb59ffe6c747c669c3e20e044ff7f0d9e97c0bb5417a9734d0f7fb27b0e5f5f212b1400deaf319bc20a258dec63603fb9e361c9428c9f9729a4a0347d7e93aedea96c3f2b6add5cf80906341f17acaa959424a1ced36d140c7b563a7cfb5542cdcf286962fcfd259bab491b9a22fdc7526dcfa7736952425212e3502033bcd902c467a6bb53ea740e2d9f822887f43c171bacc5bde88847983667bbe6c69cae87a4db915674eddac38e0e0c6e7f7eaaaa02fe72ea2c53b917e0592776b8e89c9d217649310e678129509182b44e8f208a083b852e36b18985182ef647cea0116d2efade8176781a986c1ccbe53b2e18a35d04e85536e4efa6104271a97cddf447d415db7c6092ee25ac03a61269f494e41a75c6f9f4b4cdff43370edd38b17459b5fcaacada8353215f20a08dae5dec68a1e6547557112eea3a66031816997ece64b88c520a5f83352f425590e051e0666e625410ca5835a7b352f956008e38a4cbd788807d20d9a326c6ab050212552f4517d4407746b8fd78e0cbacbf200dcc34c2e58b618075b33274c6a6e1a5d45cf68e23fbf43ec93ca144c2f95bc1c414763d0182153cd86cc1024cba31095be1b93996d1ed0d44ded745043641610e71e4e4e8751e53423b2dde9029fc0b90802f4b6e0dfe0c73deb89ad58e8c53331b7c03eecfcd237d99804f3a10ad9fb1e1061f203ec19959d92463cdf857e74a920270980f63f8c3023956c1b7c3b1c9c3490e92007d8a3f7ab5b4a4b41f8b55679ef6f07616635b835ed3458ac7324468167da478bcfe4edb4f2cff6dc6f1dbfda36a34af7880d79a91701b85c6e1dd35c6de0cd68e965a3af902ec33be15ac6d5b1a7008b7c7ebba3a1b0dbee34e54f45413356d1b226be7c54b832ee3fb428aa2957e8be51034c9eb4d6eb4852180a48277e88f6bd93b1b67dc12b87564cda25a584a2a6667d69ace219514e77ab65970f11cab80ddd214265a853ec7c3662bf219bb80236157297f764201879e737d42a1ac9c57a4e311608e4aa1550b9e7d1b929fd012f2384ec24b72f75a908a88a4f8362f779716068d67dea82a420947d33e3043fa286982a60da6db0d50e49f6bee2ff2ed50c1b5aec5c08c570a36d70cafc587076ee0d35a1fe47c751244f66c5ba157ac62cc834868eac78cbcfb7ea5b86c6ff6425d409b217e1a7a840a912854054edfd3a347b33fd40afc155bd77fa237c025732339a7e0dfc2fa6202061c6a8810977afffe9b37d5c386a45db4c65839bf59e9e81fe6f0b37f660b6f595852420cc8650c54fa144a156bb8c8c3350a62f53bbb12ebde008e2247a470d1430774af4bcfd67a3ed9c3c5b3b4727c0f7f5fb6163370f064c49e81e8d371b353c8fc3884fd7d7e48c01f1d999386a715ccd44ab5e1e29b43ba0173ec609d913f8ce50a5c5879d74eaf3c143d5d9e98b42867268b8306326a8683859cd50491550f072e6dcaa1f15d34ced0250ff7f6ebf466acf9fcd8c85a1180bc986736656da31a5c9f7979a0a0d72621d8ba37e84a34304c10cef4be9aae02884d691a15a25d762ff8c814faf048cdc94d5db81f2c5c5acc612887ea20112b581bd4c8da032335b030ead5e576a0eecfd125e8429b0cec725daec015612831c7b5d2c6430561fa2dd53d93ef346bcf3049f918075be504f4826f1a145db047c52be6a9fc2e1159a2895b1c03f6514a6df8ad3b55009d3d45e9ad7525e303079c61ae7703600dbdf966799515c203e7788c9421e1022869c61886271c85ea1540fa072fcffbf89f5f76655075d119eaf396aecc2a9fa710704a84da13ddff10cdc5afa2450ff8a80bcfff9e0edca98b7d89b0318a2520627d722cc318d28062b98fc4932236fe40145aa910142ad23951d49993471c847ecb84d79bc14ccefe195152348007c7e5e180a67470c05da735e336bb2b0e169c26511558582d4f29dfb8db1042876848359e27115ad5226345fa33470f239c48a88be1b651fd393c7b76fbd1295f46c3fd524eeed4e2578e8a01b0d073e8cec44b077ef9df076c508252d32914b73ca2a05dff1603f629c41260dc50665c0212e1deddbc78e5017cbe35e31d2bfcd58beabbfece99caaf1425459013f475bcb21472b6ae9474fa82b7163b14b08f24624f3fe8ccaa201af79c5ecc05feceb81738343b31d7de1ed3d7dbd5727bb66817579b468a07ea2a9f4705d50ec7e323ee4127508aedd3716d6b955c463880414c0110864335eb777e916a2e91773d6f15e9ba6654edbcb9830bfa8275046e611163db937f67f9cc32308f38394df8c0ddbf67fd305246a6c0662118c74f6f8b7c942426ec5b9cd5de4ddd9d4de7257d150d6ff5c3aa17f6f450530181420572e042bffccb091dd3e2766a21a11441ff0ad7ac57840128e525e1a8cbe2c325e463f447c68154de1aedd053c52cd07d6213bdd666b8943b333a5c12c37d2b4d40adee87cf367d3bdeddd586f2330c383130fbafbab00bc5e7af36b4cb21d4dc54308a7907f69e075faa1f20be8f28cd2f06c0f3e1afe73aa232ac8cbbaf2ded5a33841482a78f4af6ed77a58c62780ccfed7a4aa9e4b406cb07197471d00024def8d3ec6248e25526676ba3e19b386065cf0ef5b44cdb74e955a3d52332dfe989af7ac18124ff2ec5166619c00830602c4cdc19ed31e6c9b4e5496eb7428d164c307675a19fb32f2974153aad29e9a1ed3a3d63997f91485557edd4eef9a6f45276ad3070b462f25f943460c77a1f2dee9e6f98c0466d11fcb0a6aecc1f6dd8c8df55d0f549208b79935e83e650ceb398e0609d582ee788937106cd91093a553f21d4b5d0d339f8dd890c2e4bea3a74884c569c6a6a2bf8eec9bbe93e6d8a2336b5d82a7085a7c52d8ae7fe77cbc0d17bdf1773959dc7f22ccb4e95ded8e918065171bcff78cb9dfab9752cc69f26590422e47b7484cf2fa75992bc42ca8d767beb713af0028df1ef9048c872c4e482f639884d9dbf49a0cf1ec88e24101cacc1588a9e9e41654090396cb051dc3c797d6d33c2f286d1e17a4cdf1537de29361fa93fc4228ad32c8e5045f7b0046923e6e752fa3eda53e616fa216872514722f733b0bdf12e39e256d8062267a3385b4246789477aa4d2b9184234ccfdd22a45c6e48a62a7122925be651ddff4e303e77040ba253b7c2f3c82aedc6de93175e19856478a1494f23a314757437ed25277499785242e1e2fcb05b2489226629f7bcbbfa8e5e73e20e9dcbd6450be79d8772bc009522443a61de30b30b2dad1683d3a0c1b21e6af914c04a515093ab12f78fd7be57c3f7162e7365db102d6bc3958a2c1a9d3cee20a1c2ca858ea79b503ddea0008cccae9b33c611b12f2a073fac14968f2ee98760571ffcccc60938acd7f23f6bfeeffa5bb40b92e00c9f3b482dce63b4889ee00ede7de82742518a556e558b1ff23b8d2f2eceb711dee9aca72e1112a06e7b746eb73bda00881f01a0917d3af132498e48608e4ecf287a7b0a20efc8aa5636107e1cc68f680cae3ac83ad47fb6e532710acbc0691aa70c6ca3bcfe92854cfeb5189e9754925230e882ee55f08fc691d677cff3f5c58086704a3ee82df0811f10bde285d44c20a5d6b5fc3d0046c341fa7831c6fbee7278b2d7b4ec254b7edd7a79708891f466ed2edd3d3ca229fbcebeb0cf9a23dc3fc1a45fbdb51771962d22bdb4fae28e1ca24bfcd6c3aff081921932a8907d9d79243ce02ff44a65125f114dee3be9fb0aecbc5545e0b2571e37010cdda1f62b01e689fc434d98afc1f2347fb10dcdaa18f741d0404c742e24daf3458dca66566f1fc5f652e9562856b0ab5fea0d2077611b2f581a41dafdf04cef10209b089b3b6271aa11bcdfb67c1927691e0e2313a37936513c476f23fc779b48883b6ee05d145457c6d94df4452b8b22a408f98e1eb1ebfb775a1b1ac789c802973914178c803e7a8cb72cc9f5752ab3d007f3106d3f10a8e4252dbd433198d50e899f035c195f5e0ce333ab67973a5009db06d1f5f15216f17f161f69874f7a57c3b277a8742c06f79d1f74d93143b06d059015484e9cf58809a66a5269bad16f2fbb655ea27e991b864fe9093c3cac34adb683c8a2b7af093326b91f63d5cb203d2144e8cee8cdc0adaf5cc8286f18066f9e493fb96cad1573289d3d93fb52defb0ed5976f9dd9df28e311f12143a8ff61d5b8dcb676ca8b383250793612e6052fa60d732e73ba090a88e47a38e4ed7d5e2a051b470f70b2756ebf43158bc651b8a3bb7aa0ca23f19a19174092e159fbc9c74c6ad190d72a4b275e57e727f2ee388934c33e9b0c8734b989e00a273a662339802c765b1bf56a56e584e1481d2b3bab66832424b2fb22be8e4fcbf2f85e532eadcffb8a6ac67d88c868062656b7a40549e3af0a24bb4e86260711ebcc6b2cbb418511ed6463a4531b38c7c27ce78a768d8d72b6d8d614589eee7b59b1a3861e88640244a4eac63e261b10417889d1cd98abd78c243366e2f064353af95bffaa4da14ade1481601f117f6934cfdace876e7649414a09f89565ee7b34f358e0fc49d7ae46fd2336b2a02d513852cbdefdbb39ef0d36a3d7a2ae46a6a6846ee10c4b2b889176640cb38ecec623576a8e39f67133939325a2ddfec8c32e5129042eedcf23eb299e96e66bdf6e4b65152fc5deba6a28f7522076e76eff8b3ab81c2d3d7e624aa82d7bb5b6dddbbad6dbf5e130d5d2a0de44d563f1a9cbf078ac179f3f276bb7aa635caf262424ceb458d950415e2ce7fd2830555c2ce8eb9bf3e18bff898860ed0cbb7ab679347feb7391c0f373e81a12e3b9f699394f518516ad7720764352e1576e017b669f80415e04bfaf5495da2a3465b6b4300fe530cad09e9cf279ef02bffb0d6b4934461015951160a87d250c0e4f4a59f5bf5a95e6bf11966ffb2b4edfeec0b05663b41795ed22ee56e542606658f2090c95a09b33f67b828c739bff138b4f8cb1fda83a2c110a4d50168eca078802cb1982cfb05664c5c7b4e4440ee2b3c286f943174ff6cfa0add336027869fce8f775d47f1eb1999be314c34c6d0c1166c94389ba66b53ceb214c051b0c67941133bb6f450c6669c676f9a0bf62979bf5009db907b77bec93bb61774ea9cd180b5efdb37b2a8d1b8b51846aec5c834156a20556aed7358a162ffc83fe40f9423320ac2ab739cf3797f667b9b1d0915a946dbfc921cc97ac3476b503109359bde3d3223b540d6b15272b6aef05147f2ceaa0caa2f1f0c1e17bcd27f86ab8b3fe43923200416323d26847a15e6c789bd9ac2390e2ddd098dee8277c800d47c05636a74fd47540996e70615a551ce85280324bc6b653d929241c06b4eaf1f6b739ee82f5779a472986ad3c09c2641e5bb5de9cf5865d370079c6bdff0f32ce372a7f2b498bc93866aae6d41d460fee1c94ff09448ae402420fa5d51161ec896063a55fb80dce3be70888e1c2d3c9b1fdcf6952611c159b704a39a15d3ba02a3ce9bba7d3d743a9c08386be756fcfc4cae4d4bd497f3c974898183595718fd9242129a5e4fb316ea070b16833b50b6a2febaa2b3b3d5102fd64dd1cc475458bbe2cd0b3b5e9a7590ebca06bd0b724c9f658ac02a0f0fd8d0bf246dbda4df6f93c56effafa1b324795bb063fe1a7e83e7e713bcd4a5c02c45c900d55e19299d607e599d8bc707b5f9c843d5a2257403a5412e9222323df3c45edb410e001dc891a6843d2cb5ac39d9dcc4e0d344118a7bf10cd09900c2189327c263526007f5f603f1409f1fd8a62ec85ba085f4e67298af0bca0534eccf37f1890da9837a13f8e5078b2f6c11457cbe43b1d2c0e9f95395809b3cbc33876a30cabc3e2efcbec5559c470c746c5a6cc9783cbbf295f2ede0288502a661dd028020b1c4746a10a538ecc4d9e8705f9f9e1c36a44f277fa6ae9add5cffd0d2203e88c61368ca122005f57e27c14b5fbb66b1a240ad494e06232bd035a246c95316f5f4d26f14bffb533c9f38431b1c8e854a2e36d8c138fb4b485401ad14929f7a0ce6bc4649593fd46f732efe0408a5e4c6b5d1e798b98a901be099cba0b1383ec892ca5b46ea420c3d7248ddbe36eb56a21b726c2fe4ecb55adde62535e9bc086d1139943d4ca5fcaf7eb410ba784f638e662647efe9bbfb2d494ac392bf30065ef667f4abb1d1d8bea8329323035bd252755f28a69515d57bcb8d6aef01d4be26c3d73d98fa58376079bee8541bc59b573aed8da7df3384da3afb5270d70039ba30da0568154c9622023cbe8052795ae5c25de7cd5f454db48ecc8645b5d9374d34685c0aec1e683f78e7e1d98cc393c97ca12bdc2167e334178763d7114070299d5811028f990c3b91ed93ba9a249fa13a0ad212c9dddc26f74523465ae5b63e3ea71d6e9907a8e257fa03a5e50360d3d2ecc386f75ccc67b7a8b7dad28570fda853c61cf60e1e2f337e887cbbeae4201f101bda09812381e861490c36af35c0dc8261f7a34b7dd7fa10736788913c98ff65cee981da856a24684eac077af80406c1fdd85515f3d22356750c47e8d90bece3d6984117036c85d04a3d438fc34b256c0ee4a32c3790d8d1747e679c31fe6c53c839491baf44e0ebf46e1a114446eec5b1ef451bda3adea7e21eb7056e0401051c2f67b1a59a43ad1cc41e43fd285e0f819a61e68132646bc7cd02c23e194a801846a74359551362d69886cbcd99bd4b0990365e903a1085e499014618294ecffe322a8867eb5bede781d6ed83210de327534f16945593b1c64d10f92697591f15b73aa3bd5a7d3407ac28d67994d8bec435bcd8cf5db8a75bfede21253523454e893cc77fe4b6c3fe3532683134657295fdb08e0148c7f5502c8dbf0c55d8c70e5a0b1294ac40834a0d983e7b0a0fc6eda8b0e0a456eb65e24a4ee1072da6bb983934e729c1289c617a3131f28f5a237a2d438266c88b1cf558d3171e25c226ccd867749e5a6a41bf02a02c8e847b0356eed965d9f379a23c57474925e68200397325cf62e791f3296c25059bf1658dc3ceed4953e2bc44eecfdf5d915a45f5c1cf3b9840af9dd5c3f85daeb76c43829cf8681b29960087a3319fa17df4396cbf29c21a9b1d726dbbf281a4ef8182e033446f72f20d421896ab6a3e7af43e8860a3eaf44e351fef9307d412cfb9deab6f3103e6af089bdbadba072df7f7815ba299aa9900d91f5776e1c5000e802c07a04149e627fe7afa833f0647d4e1cd270220f282de4ff9648fd9e1ef6fa0b368bec480f9889e64b17dec218b29aca6e884302e0f8728993b36e3b22c4c9de752c2f40af26435e82c5595947b66f8ab68846883cbe86055cdd90178281530e0dfa8bd149de85164161d641ad0f38e4deddec7cea31e3ff9a92664b22b9c5e4acb0f4dde08c82cb798a0231dc30123f8316db5ac9afdb2937ede9f9fa986284ced06a082632f9f752618452af9d9ca87ae3b8f5177318da6d0b7c000291891cf3cd901caf6e559fb6257d55cb96b0c821822defb0daff918fae6f3ae65fc8385fb6122fb88624f14a7fa603beedc680214c65d66944543665617172bc19f227302639766f4ab6cef6dc02ab572a97c8acf0281ba6341a3edcc25863f0e54a5a5952a0f948452544fb0a7651334b95841e171c73fa0d687a4a2ad9ce5d4233e3261bfff57fff02a7958991fc2ba2b045859b23e74160e715a995a2070b07be41209e28a5c6a0ec63513619a1bcbd718714f9d966d879393c534a167ae5fa86334f73e6ebe7939fe2fb6165b5d8b56bab6963a856a1d9839d75c39b9592f0be7f6a68e19c57572f538d3da652402fff2cd3306602d8699f723015c0da26a77e219f5875cf6881c610fe459fa14f0ff46c4526bc3571c5dec024ccc9fddeea62d9cabed415d823d674f1a9c921c6ab093d1fdf9219a6b82bc4de355a4c9c5f1c6d890f63ffcb5149047005ade1ad9d27c1e6a6bf88a7f83b7112adac27dffd6d7610f78d8186bdb57e2d0c3de20d2e34456a3e6eb6492b61fbc21866c6e4c0c3e7cf0a98d855a422f8a7840287fad62bdd9c7de5a2a96fbe72aa223a46e012c54c3ce82dfc31dfc4b62d4e900798d114ce677341e72f0bcf2d968a46f936e4da3c9bf678d9982513e0ad50d44402a68371dd247a43253c9179f359d976df6390e0fdc0411c3b62f53d3722a3427f592f5f3aaa5c46e7a890badc930aa267e1c4b267babe660cf3e5319664a884b2edb76b0384fa1b7242eb12d6bd15ee06720e9c349af6eaf0b932aa7947cfd75d3e225c85ba970c028ad19bce3eb9e328da96dc81bdb5c8da074e713a3e52ca6a59aea87adb6c116253ea060a1fdbdf718af293bf5eb8ce8d2f4a9939ccd412dc918f9cfc87ccf006e0ac7ad1b71721708b4e0cfd31ddd449789d0ed4a6b61c0b633eafdd0e74ddb63091c433c92611e975d52d2da07e85f2fdeeb42da0ada6ab757f4fd3e58fcc2bfb0ce8f28cd9e712a62a5232cecfadc564882f46c6cc71272eeb5b410ef11b98f16a83c28b941c32d8ad483586b6904317a729eae3edfbb9fa101315b92fff0a11605a935ccf226744f040c4ca656013e88cad4464df7792269d5f028d66423dd9acd21e3ca1817620efda2c157ca22e39ea127259c69d2005f83402dfdb1e8ab3a1fa43de6a1771e6d4b5d78363ec42b0aa7ad29e08395e508805721be44b178ea7b39dcfdbbc7a7b5e95bf7032dc995d1989c58d49b453c16a437c573ae3346cc1178d4db111b4c9f3a0727d49cad7e9fc9d0aa34944931bc764b357abf2b9d4ef91e0d8b8b8dca8e67b47316eca9e685b0a7a2ed6794279f8c23162ea48a71abb21fc82ffd1d6793982a79a3c89354216b96911ff3a742137e2ef8ef7f752ddb15b789531c298a82b4ad37ecb172b4faa254b0c6d483af7224e33046eaa5365232e67d32396515a1b340f06b5c8da3ab65ee16ca0479a33864655e19ea52b32d0861ee39ce23ff60e8c8aaf7ed4151af367346b57f2d27ae827689d9900780868ee6a4c24aa8dfb94a26a8f07c47873f110de6bef4d27cd454a28e50251b43d80f7dc71dee2b7973cc76f3e002a704cd3e8a32d406dfaceefeabffe7cb152be65f59c23c666a8eda1a5ce7f994242fbb4a6f829378bcb64184378b8c4ff2103e277bf0cec20262af7e92c8c8c9508f19f19a6ad9e386449b07135e8e5e6dbd2823bdaa248c92b6a089eb435f523d7828e67b84a24f9fb7ae806ce81a17ac5535fa6613256822eaf3e1e960925e7ecb41cc0a3207f285b82ae16d483d12ddbc85e96bb50dcb218ba326259ee59a0d98f0b91635e2c6f8f3b312972d9ac6e73036cd406f9b4160fe31747e45a2eac07043cddbe2466ad8e0d69254a0314542c555a30abdb7a0d91662c5ae6360b955998cd3cbd3a9379429d772abe3d53faa626bb3036953294586922e8a04f19f74285f76fc72606e57218e5571fe7c40d16f962050c77fdc6fab9828956c4cd6f50cd9905ed560580d3567b55a6f53c748cc573c28cd62cd42a9baabb15a3c1508d890a2c9f2878e4d0fe3ae72bf6c0840fcb048fe8f79b130580e292bcb84525543383dacf98ce457c08713fa425d7b396bf56aeb8c371bbbf60b56fd0d51f3a3e0c96126f50eb82a99d25bf8fcf4bb32134d72f62c2cb44bf6d56f1e1f8c716e1c6755f8bae4fcbc2422c3b63dd37788ab2107870a7e5fe5c81a1354129abb17e6fc6504685297a5ac6ffad4991976258aa5bcbfe7628a9ef63020cc2801f021a37615bd0bef0d25e688fda8f4759f919e1c85b24838200637dfda74f2f8ceb1aba1c1b1d4b65560b13da875c6ccb5beb7c6217c4ff38f5beb56251eda7a5cb8ef3384087d65b52e26844df9bdf1ebd008b0ecc36258ae8a2ce4522ae26af6b447568e8421275aee4750a718c61be94d83b644f8ba8d00a32bf82a0ab507522b8ad7557b96cee2406a4ef8b518ba42b838b9695f363b822d06215914a6db84d2684a44411e1f14106effb43a5b2597df9c798b68babbef460347fb7af904f4ebd5504b9b4f77508b290352081eb5244e956078a42fee9a22f474937d638452faade6595d3289486193afa444c9990a9385594474bb9a5d71d4f92e078c9ef39018be6f5cb6ccf2b056cbc17d992dda74eb1ad5b19b7b8b47847b810ba6318f5df47b2e4880932194ea2134818feb484d576a9e9a0a81098f3c394904ed83d1c234826924220ec8989763367779341e94e26f5bc0052abe5aa511a96b740db82590bef83ccf86d5d5f0a18126ef3af71ea0931b4714322ef42f031e6745bf241cb723548199d195064352830ba47b56f16589f365c9b0509e741f4d53b5cafcef01e5a177b567aea1e9d2418b41186bc2eaed71371b37acd426c999f7a3901d0e3b55f343e60666113309be56b586f1c5f4ccd6ef12e1e357f5123224fbec15a2d7e335030429234f1205c15ce1d87bf5a344bb618c0bf725a289c7ee0239982b24c0cdd28165ba86823c91e7a3b1559a17fc65c6e9c21d5ced0ed6ac01a511fb5ffd228c24e654679dea981a2ca71aa23c40c63e5c0446618208bab51cbef608ceec28881dbbbe24f3fac3aa1695c54388d8141ee1d49a8b36d011a8c7f96d81d81926ea18accc6697656d140a5f0a67a6f7d39e52aca98c391d582cd47a745d22ac415f0d65ec922bf07a6ef0f63de1341659a6f9e5b6a97316b1d3e245f007f1509eb7c58d549e86187f3c79babda5ac56acb60773daa4e09b74b029d647a69f66f1b7a414e2939ac23a5a08758baab788fd36b4f33ee48589903e1931568a2c0ab980d27a529d0333e4341471737e07bc91c6d98b162733c6bdefe255d70e76c27bc1a178084444a39c92a096218d48899a536662f9537ad9684e9888821ce656b854e02ee7fe33141545d6a28d3a272ba93872179a82805b86a658361299e69ca91839bbb7ef374e25982d56ddbe6d00901fca678136b8798bab1f9e8a01ac4b814a812befd70d2bae304b152e826f7ae68d4bf26be66359b390d18c7060c2b7f5b0bea081ce3dce5a24ee74766d4d36eabe0d97bf77ce2e02a9ba5431bf1b11e04f363bd57dba7b7b5c221aa877ac09449a64633d29afb353dc58bf062bcbf84b2279d9e7a8385b66b43a64b86ca3556a070915da3731dd025ef9b5e205cd318324759a793d29df48f6eda1c97e6e3902b7c2076e33c67ab48680f199dfb557418ca8d8804d6166439430c140d63e34221e8989aa192d582138d430bb0bd4ff92c4c93302c1ac6fcbfc5735ad71466857a4b5c5e866cf33f8b6747acfbac812eb382a8ac77f1e6434190e7802c35ce1a8910ee7b2570c34fbe1b881f5c472e60481e774a3074bf4464928a9ef39848af0bb2e1dfb6b1ea93cdede16679c34ccb33984498eb3bbcd3764044bd6681f3448bc0a43413a99d6a943197afe61f5a012f5c6c35eccbb46d25fcd5102098ed7c902520634ae87ba4f72397c645b765c8fdc356463fdd9373f0024c2dcde766bf0e45650ac99c34d4c0e04fe69568f40718aefae6faffd1afe6ecb080e4066313bf5c6a27a27a71bb2028568f2140ce55bceee1c0a971832e2ea25fafbcf1f5f633ca5d703c4930c4a1c6b7dafac61b777c1e0fa97b0c29501744194c8033b8e25d4444eff8b7c27fc72a549bfb10c749d9d6a71c2d624a83751f9d6baa331fcbe8f690503203ece3af67b7922051b4ca8b6ba507d85211f60cbc80f3b689ef9aeb26a1e48b13766a10819f7fbfdb682328a1bee92317bf05c035a102faa985065b9676b5c3b5db044b97bbcbad6a5781720b1ca95df368c70cc6a170c46c3bfd4b543667abb53ad2a621cc734eb4ec68d99069838a0b6161fca2ab751cde8637fa0022efd46058d2775d13713376d1ae82d5ed8fcd8cc1bc78ab63cf698249e72a01648ef0dc22203fd60528567133af1fd6163a640f485b9f9c1f6611fbf15c1da9e84fe980fc5523a79a1e64b7e47370cfc62f7978b6450639ff342e2c805a7118f45dc4789fe5017a6419582e28fd41b7445b2860c1f336515b920e0c2285d91e37948ea92cafa7fb1d1bfe999eb36b0626a246118c934c278301f9bac622e9cfb23f336f837468afb3b32b07e0e276f984fece95f663f853840af5621fc5aa2b8ea260896e9961f153d48f98da146180e6834a0080e97a5373c8ce4e996916856b82a63c40cc51a8b027fc511c27b61e583bf843b81cfe8bfb2c038a8aa99bc1fb88ff5b5f535fa0a688c6ff9570a8be6f0bf637574305efea7773531aa73e730e814f28e48194d9322b75758594f7acbe70e6559984fd9fcd071ad9f512bb133b6312855a8d9897ede664ece9f266a225dd67a73db948a8a78830700a90c6ee3209b34021b1b79aef82a258fdb002b5fed07a9d575fa73780840d4757c533b0ac69d0f7572fba8b092dea33064ab06e2d1bdc2a5c2753c759bb5ce45fd43ad098686a975cf7165faef216b42a8cf346fe71a7d86b8ac300931def933f5a9aaf21a53c32","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
