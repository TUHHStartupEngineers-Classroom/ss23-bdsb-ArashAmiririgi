<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"e06b6004cf33ab11e32ff41a52e63d5484972b7699aa28b943f6b3e28b547af9363d8c56648dfe228c02f5d2394d8ab7638f23cc49af2879363ee5265dd4a7e2b6f1efac8a5413c53d546bfad812776186f211392725a3c8993293befeeb55bac34fb6103c771ba05520ed6b2d90023365994b891dd5502a0757696562947c598a4a6b4b5a80a0767cc1e0b12b72f13371e65bf2bcb7d62461f7a0287f87bd92f6868083f5a06c4f7d50edca39ee46fbc0089b4cdc9b3b1f812df3cc6e080e71f7e8d95ee88ea2352baf34f9cca2f9728924cf6d4cc02c4a81b2b733014ec2243533696a7b4aba70f19b9e7e5375004d1cfdc460407244e2b08707b7a4143635aa628032e3042452a5e07cb872cc63f2472249db9f60be84f96dd5122edefd7141af8d8374ef233fb11f117c12f9d244a0e89148c454f3a4429b21f292b4102434cfaf5fb1dfd193d69b25b9247b6e59922af145e444c4727184c800cf0cd8e98d4a01479c6628a2c34d0fd0f11f15fcdcff575cd6a3fad15efc2be91cb1050143f07f02b2155df0a9b40a9a6482c286062951240c76938d18e7b2b8a66f592d1e995e1df56b9b88458f2eee4f066074a091c523bebccecf00e73782c930f261d496ffd5b56eb633fd5ebd149506e1c2935919467ff3292813e4a84ed7174e68f1f8f5a3fa37f363b40d185da88f5d6f8477981d120e3f6e6b808f05484054b48c7cd6cd84930effdf92c19be9171018a1de150dbc89692d59ffb2ff61e1c02e15d12f67ca4993706a631d2dfff9a552c9fc905e4ad40f450e5f8c9f22805f741a5830a29bd32bddbc1877673c7ab3d07719001a31989a84c7ebbfa311a4c7f615a639e86ad4fbd72060315271fcee51484af2c81f81a1cff1bdbf8cd1d8235da9cd06a25b11d3323864ba29d33684e6af9efe49560b4a8b1ce2b78bcb088b46f0154f65ba98663f9b64348ae08026f918828eb79558bd84e45e8d190075a1fb50552ece63afd2159f4223d732eee4b916945dbd72c18aeeda94a86bb2b81b5e12cd23c0d8efe067919bdc313475fa74b67ba01c4ef16400933b232b6609910aa51a702bf2d60b83e46b2339b4eb4614ff62a9e8dc4c51732f1cacd9302d1509d6faf373cc42b39bb1146fcfda80049f72cd7c3c8da8467f0e6e3505a14638bc80545cb14661fb2ed0d4e0ba6c0546c19c2c30c3eabc4de3a4b2f8c3555894111da0f359565f40467390ae3345be38be0d070340c90393873a566ea13d72661ec7f0bed9107b4f27d4e93f0b835055ff1094fe49661e1b56b07f210e9e5021152e18453ac71eae28bec266536a2d2ea374f5f369184a5bb48a60032a841460f8a34ebd5eb458e0453e8add6e14273a433c38ee12b6feef6816a01f77611e39c1308bda9792a0381aab32bfae1c3e828eb022804564645cb4b6e494003bd6496e686edebc9e4dbfd9573acc6c49b3033c507a07b64dd80b9d899896209b6dafcc37ddab275214b235b35099002d18d56b494503052e6ef43b433bfff238c880146a836c9509c0b2ea10259f8149e62815c7a930db836266c968d381bb1fb50a4be698b09313836a3f6038fe04142a9d092c78adec24ca163502c69b4b9ae63195fa629c29b6d3027dc97e49460f22c0b4d70d2dabae975a8ce273f789b35e75a1b134cac5d490d30896c44b19b98dca25362b7da6829a0b56ba405ff0a851937d43d7137f90f160117ddda155f0df90ce41220bee187835bd4523db21be9ae9eec3b075ad9714305f6650f7a44eb6431d6898b8a0202a430234423d221a9d2f9f54361df99f41272dc324e382c93073b540cc62748ef26feb2652b3c9e97cd5d6ed05b945d8cece8b54de41d3f78ec2b27fc54a45a0f35754f35b13eafe17e89f6423aea464d957213a3f206b4a3096f3207eb204b220960559a10212d703270304e3dce85087c1691055ae08d8d20b7071dadb3eb85b954145d98a9b32f953e56f920b3a275b821d6eaae1ce3025bffe154893bf83960c7c70199000379a0eb25246a70b5b9f4cec03855a2eea4abe47e85b8285cda7d37d99072c92313cbf5d2e85fc941260726bbe024a1f04f0adca9c1ec9558f4bc4b949dbc01efd141222f723ec0dac5439136f1bd971b60cbb87b1648714bfe06c2f9801a0c1e91bb609a606adaf67b99bdf4db7f7e939f6ece40b2c300ea12ecc539ea51fc17b98b3504dd2b39826d3563b1f65088a70089568175d6d28b1853a18a4198707d29a7504c12d6855dece5d92573d1c16dc4fd0688de5cef02f5f0283b58967e3918074c254f863b56a89aaae9b410746c369f496f1d921da4fa18ea9f26d27c163d2fc6efe1d9a58a3374a424c7e66dd095094238f9ca4b57d168d188836ea6b887bd6f2746ab7bfda52e583d8fd853d9d11ba2faa5fd0a06e605597da0fa2a9833953168e0d1c5dec6bc37c611cefb42fa687b4158c5fd112941053394d7c6f76a5a080304556b190ae349c1efd97dcce5a9773aa4627e1a6df0839f2321737fc432864123facadeea7d606eeba239781929dce984b364f3d0ba7172dfae00d180ef05f5bd6bba63dee1fd9abd4559f01093b5c8d158a7eeb28ac8963298c27c6c024fc14572849a13973628fd44ae5ea555e9ef6f588f688dc1b7ee58bee635546af993ed2f2e4eea7589e1af0d42f112281587a6ba06e04296e4f45ecc99270ec08571b185e085a6be0e021c93e6f0072dab08f73af8ad86e7c6a7b74d8a60ea38e6a4e39476b9203b2490bb73d178c718c64733069310a7767505b427afc3fa6e8e4e24fc5a50958ad40144108e60abd708f6053b3a8c509fd66cf796fec371187d26f2c8101eb469091931a31a83fdff625f08a2f567a00788e106dfd88e2a3b507251edc3e16fb5abecc2198976bd0241f6157ac55d59e6a3c557f85353497349ba9e955b2e36362a7146314a5524771f4a2ff2f2bf9c7e1a7c10193da3392ddcaedeff8c71927241f59a2acfc6ee915263c32d29e912c0043bb4517e549c1be702eb7b4249f690aad22f7c8c78f4b994bd8f80443226527d3d2c6c93c0206382bbc1fc3f76e8e7e3a958d0e8f9985ca301d356c9aaf7eb263ea3b489e3daf6cb699933cb37e65d2aebdb771b58b5d953ccd2af01d7859d99db1e3b0f736365e478436cbb88a2836c062bbf87ac429b681f2c46464196a021cdaac122b84aec8bfc188f33c3f0e69a2561ff5f2e0ca5cfb369b84e45d3ae309790a8481b2141220d7b134e023294bbffe80453dd14ef878b8908357a4d6c40c67c4cd307ec2cf7915f721ff17c2a88c80ff3cb1090cfef7745788589af6788a97fc0a96061ee698babf2f20f99718dc4d493f66481903c50e43e7ecc366d410139b67a52999e7bf641fa1a4d78f7e79912e7566435ced684ac3da434f3640eab7a8b138d51d1c9790aa63ddf11122cb7e0a709dc43ce63a4d91503d83b6e8cb0c4f42631cc7e0d6600783670a46c0baeffe94a631c9dfed2d8e88fa8dc16b66a6f62a5ee7b41a1f4ae1a5156851157f711c9b93ae6191787738d6ca4e6b5dc88ec5d1e6d191b3c0b56a266131c64cd8813339cfa1bb3af5732b726850266746a817bf7bcd5a64acf4aa36d6e4966aadf09a723dcdbe9c4cab158222a4d966735b9b559d5d1bf58b96b11527d685c06eb36a8734c664b620a0ae82032349889819c6e0895dff70f0cb1e5188f829cc7ffc4bd31583e90a21526cd4486b0e6ef2a259a4ab09f9131aa2582f20d17588b70bdbf78cfd8888a5bde3debe4c9303847b230070598bae5e364940e10c7ff6ceee2ec8adff5af8fca427bb45a690518d6015c2f3aa950c8e83bddd9a81574f24c30930bf21741c7b77222b1a9875fd9074bc103a0fcfad60a1d831486a76a7e6a7f4c6010fed860f048f90ecf0b8d1eac348b2beb45abe49f74d8cdf7e02538f7e614eaaabf83663cd4dba1b7a3d8857fb496ee48dd7400c97ac1cf81246a1d6306ef38549092d5abb1dd4ecb18f4d2347c81703c0a426f525428019b8452111e49af174b0c88f7f1366ca5083b16434cd4d62fa614c37bbe96e246bfcdce0ea765d28aa9158fb8e10c3a6a1466c678438c0ec709b498e7c2446111d9e2a4381c8e2e6f66b6bd4a1717abfa6ad9e7fcaadc301dc4a8700626fae86895ca2d342db559c70a135fc168d55f7f64f5e4ac9cffd3951388fabe20f440e7bc9e9ba9b9af1e3c3d948ba2232a67c6a40dfd7789b151d67985473f5cd7e5c42c9345e5c1763d5f1bed8d097c31525815dd2ed7e3f64c3e0c9251178f1adb5256ad87414e7be17c6c75ad69d4978cadfad38da2173d03adce7cbc7b605fc2715007e4df611472cf84c653f621230e72caa6ddb1ea8b7e8e2afcf29deb233d78ef80a9fb29d6a793107985dcf3da8c38df080408fa10b083ba313f81b7677224f01cec0e2b9e14c381b85452e82868470977dfaeea7d24e1757cacb93a1f68e94c1e283fe5d6376d3ce908be1f3e5055db6a4098b6f692540ea2a93e7ed13af93f81c2a1e00a34654d2e940fbea69b862a9b9267207afade770ab64cb6d54e5d9d8f2579648f7c38a04f74360644bea8d6feb82a5b14d90139a112058a012a8aaea95ee78d2175de697d7d5dc5264dda995d88f39b5b2b57d01a0c2df09cab63e529190d3f499f7be2e0bece9312100994da044bcafb3ad1cddd00db4031d272ff7f46f7a112b3230397a9c13da513587607c99d331d355bd2cf33c579fb5386f24647ab129fd216f54a1178256ea715138b118d675701f84598bd41825c87a898a82c7eab52024d0fcbf1545d2641da158c6ce89d2b6997557ca29f772e21ff3a375a91cdea9c73b0605e04269b2b94f1badfdcf8889362775bf772933966f7fa5ee4e63e2d1ec7644cd0a197155f0ab2885805eba9ac6d6eda8e3ca337aa8eb544f083254e1700937a318488d9dacd7011886b61e9d7d015c24985e30c1dbffc16c609ea4a00f70a917658e192594b9857cccc1e09e7b15eca2b4af018b3ac29a072f52def25a0c2b386f0f70fa7827f18412c5704e5d5af54dbf2b576fb864b49c91c16b3f5b67cfe7da1cf2c3095c26ab0b844c6c59c2ed39bdc110db3f011492c2e5a65f6e4a5d16a8643339af7c6281f8ce76bd117a4b1ad13f23fbb61a79e74febaa12d8740263a08893b7064a42dd674abbd9dd4f994ee98434a79b2d083433024cc7c324294357b38015f017d526377ecfa7ee03e0c19149a1b7b7f56b5f987275b51f9bfbddc22e8e9be0ce28498bd9a2addee470da29719a34701e5222f5054c91304fd712f55271274f0937ac6889b2f832825b3c4488a8a655362b273ba33c42b27cff4193f7545e583a615cdd8a538873a83b9858a342da5a81baf47e36bd0b63217d9695ae851f96c769e29e78294c7959e02ccfe01adbcbcc081e91d288550687740ea5c05b3d8616fb2ee7695a956061db61b7d04cbbdc4e1f74eb6fa0a86e09b90d9b12684dd4eb438fa8cad67c8c252317120547dff91257ed073af9eba2acf33b0342f9dbbce9ace307885b942c7d169dc73ba1fbdc93e2e3afbb6b754ba651699d0500d0dc043a77ccd03308029807ed5d7441148dd889d5fdea224091fe31ae4f10be8561a2ef441aad6df2f3a9036c5f79139abb5ea8437ba1ad24cc98d78005010e5a729974155e91bab127e7088be1da692d16f75336331a4efa2b281c0e20bacf6955da7f66764b39123197bdcadd4175a2595c3ed4e8b3a82caf955f7437ad3f2faf06b87b881c21c9bba369b419d1dabcaabd9e8a0062114f47344ed8bfb889a36f39251947a3b1e6a61cb2eec1e4784794d30b3bdfe55f7e46ea31203de89b3c20348d982c143bf70ad54fed02cf800728a5175be291548f30d04aecf5c73a468b8b83ceed091d6624ef06000ea88aeeb8632937e4de84b52954e1c4e178d0ac3e446ddfe20b20bd44b8726b229ffde8f36efa1c9571392233f7e70e1ae1aa09de66b6327e0b1a2a79940c2e6eb1e45c4392f23cccab5af8cefa09d1fbf5d1255fac9e1f2d68205caa5137aa7c0324a86271278d817ede762a70081827cdaa41f68adcc638f01ffb8176b2c8c95f5d8ded5debdea6cd07e769c882cd162cba504aac03749b68f43a065cca0a847b40df5c0b0192d831abc133d50a364860964db685a9ff3445b6b182ca1ce1a86eef6a5c13f14ea6d6e9d07cf09f0337fac9c2e39b52b04cd681fbf88a8a16b1cd233d97790ede3b7abd30f99152c1d2cdc277619c04862b8533aae96063b449140eed9d9dc076b23b90f9f071bf16360093304cfe267b9b7e69166cd69b680e4d7f8dcca949c25e67267f61840f9864fb4c67888a8f5b67e8f2a562dbbf08cc33182e884882d8e375daba2d32ae45d4eca017e508b3372674f7883ee2a6d9f64a10c913e181a9565ca3b03ec220c947d9d9e9d72eaf92c0bba52761ab5d7104d1d13854ff210734750eba5869215003b1e03e2c68833ca041a13ea055a3dd47edafa39901290d65f4e6c402d9d75ee8ce43880b1e8070fa02cfb7e589b2d7dc4b8f4d51892eabc62485fb4938e9c34871392484210a680d40e24c6be6523f3ab30bc0fae8c9b1be10de115cba23c44ea56e03ee298f58749a94e6a08a5d34f1f78386cab21d6a6daa11caceabd0ae6b9b2dddaff6377abfe4f4176f169728a2cb83aa92b8a7c7e1f2a0ee5ccc8ba30c9596881dbec92c54a6bcb3c980a2f7620558900c805f677703a027586c88645b6fbce037a26e2d901fe0973f00e2ee5e0d54b5ec8ce55f664cff5f5ab9799f34813f3bad376c01655ca6c55d05dd8e1580bf21b680e86a7949334fee8e6a40f7d4f015b1d353f6ebbdd51708c37adc5ccf5d8da998ea8dd79a740b98463146a0a7a6681e595231a1c389f2f0b26677da608be95d90c48c418193436e4e24660b5a68024e5432b2093ddcc259f097a99a53b3255130e1d207b32c68ef5ab4252e83f9c8dfa55cdeb123ac5c4207337893040540e7df547b2215c0964681734aa4eddf9510f5bf991108055ec20774cec73acd8058bfd74636e0ecffb939a0374eb8a12e967f1d4709828a5d6b87c7c94a7ccf0bfbaa2cdb328c6ff16c0c2a02f269eb478bc0061f577b2b50abb2c2d951bc1070b90e190e52039fdd9ad71ae7ed5471739af3efc2f383a3304794263e686769c37912c8a118821c0a5d3f9628f249f81bd438ff0258c3c8a24c6ded6ef5414d16704313de1e38263e90d606d67e0214640cb5cb1b5b9da4cb63331cabb18cd0e53d98d0ea623a32a98542eaab8113563331f4684a928cd13b6b184cdc58be6aaf6f41b69ea79feb663fd9b0e510039029c7cd2639b9c54a4bcd745a08f0bf388a8c9c6648b837afdb304cfc968408c459e5ca4c87418703563e88da16f54c4e8cd8bd15652f6712660fc53c92b45f9240cefbe4ca0d072ee5e8b6fd0138bd86c33e156ade5beddefde63f92e033f97b9fd1e840d799d0530e785c59c1300fc6a0eb911019cced9142095678f374310c02634a5186d286f2cc463ae47ec1cd5fb80095f3c95b17919c876688baa41877cf5c6f2c778cbd70462f00c403aa2a260023137ce84ff1134f238f76b0e9fd5cf41c92bb60692eee2fd97806e7a683ad0b9133c38b2948f1488b20e50ce488ea68b2c8becd35ce1443640c8f84e808b68d0d15ab56fce56149512f68eb6fe3f74df37a1388d0e99b0e64701c7da8800cffc0481377fbc4a4fe2a07ac79f1475c985732e9c0d836ba1e86fb681f2b1ef84b96e6b175793f2b3e04be720ac975cecb0c9a0f464703a4ae95ba92d1997de18d507b854137e795c2bf0f3832e6c232f6aafb57869c88b0dc2ecf5dae691e7a4927fcad19de9f77fd09e9e7f655f682f3b2c5896e47832d2f61adb35bb81222551adb862906e955beb0e16aa133cfe455962555229e2fbb356a86980151411fda78611732c6cfd0ed3c85e2318fe4a3ef8075861eecec8af5417d2513d7708be60f1c4b6d9c7b25c07c42662c8e787d607dbc9024d62c7a30dfc2b62e6b56c7a787ffb90b11d03650ee44f9fa03e8c664beb2da80848d8557b86a28efdae1c3d0f9ebea4a4ea82ea9ca092a47e88dcd429b7914fa20b822a13800d05b4f522931d61dd049329f59519621e41721f93f3d0c6e2d27984ce8f2493645f4799d63c0c6a23ace5512c21fd61417a34b578bed1b2f30919c5264d0d37581813fc9cb4b1cbb530383ea11854d513096473b027cbc167b2313a1bd468c6802003bdf62d799a8583ea812405d069f03b5adcc02a37f7a2fd5747b03d97903a7a3fd3878b8862fe1976e26de581f87ae53e914aae4b7f35c17969778aefe58edf9f08b4821e7b3774ba5fa50b964edce7848bb9dcc6c52448a51c491277063a8e84eb38860d0601a8d63ced23523de0c6f73c0340a287471d5ce036dc9e4e2af13b8326556ed381dd510cfbaec566ec606d8a643f7d90aa626fd366c98a8dd30a98902f9eb29ee1532e26ab7f43cbeae8c102e4873e31a3bd9d49323dcbfa8d76dbb0d255bd05b6e6b6c54ae84c78e863c2a59cbbcbba68162872d5310541e5c6c5e57b9e8c58f398763a459ab85e81ec50c49105b034fe53eb981e839de9c91c08906407f6463ef12970ec0239aae6ab753e82a09ae63df07d0b4a4e1ca0d394bf5db976e79f960ba86628eaeb60d678cac9aa9d12d0920da2f6b0cd319de2a22b9bf9df735b33288678c893a9c3553b9a2a7c86e1daae1a6967366a9bb84b620d903b083756caf3cbc57ce7cab3c3b1e387bf1ee6c2f52a3bb6319ffe7a1ab8f918768df7f59759a2bf5630737dded0d44f3f5d0ccde180d2f3ecb7fce53a3d6f1abbab2471808bfc5927cb70d6c0c18c6fc3f0dbcd6e6fe655a23966478626acaf54883a8c64297c2b24c00c4a6dc716827e977504030986cc88765a4126fac684105bae715b1f9e367cadbc3cec99907270f898b71116c5d6c56064fb02c5d995d42c605d60c7d55bfedd5071c13d2648d753c3e0a383e157686c29a86db58b96798aa48827a89beb990e2e637ca5b2e6779ee65a6ba7fd6824d41654dfe2000977f2f31f664de0f1fc676de82f498e10b6aa0a90f401158b04279b7661d49b355847e79dcfa6b9d66e78c8c511e96ec998585ea3647b0cf60dc75773b13d39304a69e088466e7ac1b1b5660df4e1c482e7dc16c963582a0a26b8a7685871996ad845afabc550b2b75605d33569764f00384d78e186f9606c21bb222eece5bef24123e504dd347c76d36f28c0a7e45aaaf471f8872e574672a96178acddcae7cdf174c7e213c38dbe17110718290e9cef7477ad8ff55d7ca8b3631a17d66aa1336b977cba444f7b6fc440d8ad62a5f2de1f34be9cfb6b8c8a0eb484d1443aec68c5ad3e58b7856a65203e2be4a01603dcd664c5ce5b4ee17f2c8c55609431a1778f1847ec528012d93503136786ec4f53ebd8a7cd4a1a3d7dbc931de63ea1fe08141a386ce43bfe7d411249b486de285e38f07e6d04b8db045eb8bea2cc8fcfd943beca40aa89278210776fb5d66c5051f4c9e34b9bd9b3367fb2ee23299f2710d40bc8e8f85c340ee66ccb87306b68238cc484701dd2a53887c5db94fe8f003c3aa675bd8ad7508a1d6a48acbff20cddb77803c657ced4608439368d33bb1fc4040a2f143bd004865594de2bcfdfbb14d34b81b1c9450a422bf22a1cae65dd5cdf5e81aed6cd1187deed27b6b4a10dedef87d95066f3d0bc73b35db4f5e88d85569959f7070be0faf97f8dae756e1785047920d635feb03124c53fffb45977c07450584d5c951b63cce779d8ccdab667c0114e50596b229cf1bf4af77b624d2f8dd7398ae19fe463b77c45626a32a32495bce352c9b35d53595d30a8837bc7c97b4b7a032ae9b75ef2dcea1a4444ce13a20eea951a1354acdf36d174f16cbeae96199002aabe31bae48f825d78262ea9a825ce516e91631a38cc1a0dae83721dcdc38bc4de30d5ef06ca7436e996d4a1dab0b14cd23c0327e5552ec2a0882c7c53ba85e120446bf9a427d37f253f2b9c4e608464caaa53de639f97620ee08ae39aed9aba1969c89c219c761d292a31697a80378d41185b60cba41bd7c26c6b19a211b93d6d546c284c52f17219c7455374b62d8b9f083e0f0c6eb061d5be721480039eb73d80efdf0bb50f359dfa2cf31accff5378d811479cd541f6571e117d175ab1d6d82e5577f16b413c0f2f01bea3d8082d3afaa0d6ca512f3d716c7e0a2aa20fab7fecb2dbeda82d353f5d012771b7eb16f197be85d9f72b642e782d933ba2b12d45218a7b9b2386d3ed607274a988cf36530886e4a20c128837b709bbf35c174116538444b4e30d0ab2d286b133d3457ba1537e5204d597497fb6fd61145d3e1d13d84d99928356f8e6273a2414d878e0298bc1f4f1cc8b06c2fe5a898891057f7a0ec61cd6e010ceced2e8e0d7eddf0d0ac80c1813609ce07b6d47885eded96725dd5b1b4013264bfb34226ce2885e68a8eac95d37bd88e2dbf4e347bc17354adef5700f39554c51a5752ee9b4170336f7df0e8110ed77ec86a1cb890ae395736a0bb5e7dccbad76c91f8003aaa9fa4c565fdf2ae508b0f0ebddd0f919bdecabb4e6d0369cc335a10c7f00551194fd5c8b4eb4056caf3b1ae07382616b0ffc4f3abd436211f96cf931675c8f7a25d8100123a794f7dfd0912bf034de275907622cc23b6a7d8ffcf3274aabe0f0c691fd15296dadcb6295a0d2f071af4c5bc600985908de2a6e1a6f7d27f72e1738d1a65c69da33fcfb575afe54037619d3c39891ee6edf55a2d3c4ae8adf3a481c4e45fc33b2da0b9347f9f8b53888b17d019d03d9b29545844d031f0f659323278aac4c0346a3b168cb49284418f611ca4d074122d77d79a3ad70877df267284c8b3f88493e8dbf0a81d5c2e2c47547ab2136515f0462f53b2eb7050278ddf892260f3925adec5c27d1d8501fa7d628e74642f1dcb48688a88c88a80dd6d12a0e7d5ddc8417c41d59b5a388e5cfb280bcce4bb5ffb1f8439580ab075fc30e3a95b40e272dd15831a00359d7aef03f0c775850454b42d947b25c52c4bb31d55566b034af98ce8ee080625b09cb95ecc00ea502b32722ee6a801f51b99e56f6ea30539ed71175165d2ff13a9adb2e238b1f36153f62a0494d6c75dc6f826fea05490ef4ed02fa8a2ab01868e63d72df30f5f32fc9b96c9a147e57c7205c0c99bbee93af8447dae42febd91138fd6a91a10b42a2a8a1605fe23a527957748271c563a25ddcefe1b66ee3d2f75b39253d5e0997fbcae7a1ca72dfe387f2efa1c386cb67c5b9ea29889db15dd817d921f4df904438a3e7d578a6ef3ba597a2a95f86601308fa977421315561ebf1085ae8232c5d7b5bda70d74445fe4da4ef2bc5192958c89e6d8de40691506cb4e158cadfaed7f1667f4079e5e209924cab6c0d999e2e00480df1b61e00de6233e0bddf3867a50743e43b013383333591aee8ff4e64e137b3b08cb6d5b3b3c63d1d6239116910cd719d4e13f40c556b9fa2448ab93c1dc749179d04906f5113ce938ee48ce610e4678b7b6ff918ff8777a5be213b37298da70fa2a561b815f7f888d04fe48c49e5faab00f3e2cf8dd7cbc437b61839b88cc39bd0737184d7898f917ce4d2010e3a38591dec0dbf10314cc860be282f93196be0dcb486f5cac9a7b37e2f216c43d46d04c96b5f0a8018d67fea40a47894df69aca3997a65c24ec77d193d338d5c4dfebf03252924cf7184e07316c02916fc05e8beab9dec9327e668afeb14e5297bb0594d43a9800282791f1af78113aac91a9e042c8d6f4d55fd6a59a313fd771b642dcfe3f55d8e9ea559444b8a36cd8083286873ef4b84be80735ded38eff2aac3b9e8bbf9bfb9435420d5fc86af13780d0cc02d9d52660f8a9a2ea75d0ab8b8b0a11ac5c734215ea1ed2cd1b3370a69808b24fbda64997906f6c07838bd6fca34c47ae77f6daf13ba8fc7d41029b06537cecd528f433af9572b8f16f991d4a6140d47211b7b81b4b8e6092ad4f82c34d3d7f0aabc2292241e12e98d7c35340806defc280e25d9f5e2a0a2524c84f277580c29966859a594faebf7f39eb1a612b69d215bb48413e0e5060b077efdee1259a4dc63a45eb057748cda18c9a5952bd06c6c25919bd579687728bb59a6dbd9d44cd2d721247b4b87cd8056f3bb83d8ed3098527a5339d1580483be4bf41408af1c745016511c214205606ea7423eb514182c787be2fa132d208a7f3c41b3d604d0efe00af8d4901367113fda5090c116fcd63d8af45488182c5af98db6adb98809c566c29a5409d6a60bcb2cfdabc59cfbb509d6df5599954e2e1784c183459a638b5712b9b26d7d1d5167b02f2a9abe6c78fcca4c1fb119162aadf61f38c5768ebdced88dac0e63496e71ea0a6f521418f386f92996cc96182c637ec91b5a6fc0643f62a050daef2e31ea83bdb88daf227ea0bb7f2fe106578c39c6442ad8eb672e85604f20c63ba12727050e618a9c9decc762769765af87a86ebe966afba38d8fba917bd24a382c31c8e0247187a7e61d8773064ae43d4bb94cb0f9ac76772fc16c3a8fd0d37f0e70af11075b874595c50e809c8e76e66893bbac1630b87aaee8f44968d7905b6de1f00c3f55509166216065534dcf20a2dbb0821ee65ef7b39f53a0cd0f125a6004843f0ea5b859283d602f5f8417cef31e7160b57e357cc48769643095b4dfeb9ef120ee77097d4498946416309f91762e2f897290c252a6d5e183af7cdfc0da5a74c6f3c0a867f10820306f7dea0679071fcb009897886adde0cd6e982085e30bc372594dc3608241713ac8007d072d78de06f40c7e86ff4395ff4aa9165a9dc3ae53864467c4e8473c0b2f74b1dd7e54ad6302c1646a17aab7a1df3fcc3af044f4b74e24a8e933e96a49db490bdcdb3edae66f5666d497dd1473869c7c8224da66b20c7883fb22668c6626d08e5b4bde68fb6369d9aeeb2c3d150903be4554183d3986533b4fe8fed972629ef9f4ab74d73e24b4efa2c2ae851d4c2b986ec4dad978788abb979ccddc99f6cfb8d28a6308afadce6f07f65d0f70443f0efcf0e8619fee8e644007f3499db84b328acc25160a8395119ad731ada1f62ea63e8ed857f2004947e7f81db13603497b5fa7660997389267fa27cd915ff350b96ba837532d6fef1c33c9eaf4db7a8b5ce15ca45a04596610979819fd27781da1871ddb0952696c40afa2843cf1a989e74528b4968b86243d0733c30f8be6cd5bea9156cf462ec34038ff58cde665af3755f712cc986e9675d3d0e0a4a8d9d196f5d63097b13487bff10b90874dadd870380680055478bea2aa680cc336eefefc3d6aee124a73a55b6bb0dc2b3283a397e1ea678abff36fa82674f48b4c5aca0f5cb05a26cd5e0a12114d9f785b4c3eea86b08675f8a30d2c2faf9f5a121f8a203bd92d8ba82e4770d75d4094571db4e2896b39e6e05731e7cfd7b601dee686b03bc15b0776776e832a0618205abd4a5c26e4514b1a21b0e4ee7e97ac2eccdf8d1eb95bccd4f76374826611e508039d152fd1602c5d8555ba91ac273e2614dfa3de39e294eb130d6d4bd72d999618d9dc2959c0a94b07adac32ca5c264dd0c83bc84212b4808b8bd5ce0597c2d018f1b9281d178601e5fe1851da081240f4e905ec32da6cc0f4d60b0eb1c493477e1c3b2a7564ad1091371d1ab3f7300c9bf46a8a5388738ed8a96d536b79621bfde3ea73a57ca223b9e01f7dd707fe9f46cbe29bbbee2bcab03e7560e1219df53de6c85e64b4cffb0f2dcb074f91bec486a6c34e9cb533c517a31e074decec5144cd7a01627b65c333964521b69cebcee945244a9fa503ff5ec7047865fbbd0db2aa554866aeea87ebf03fdbc115e0271e61365d5eea8c04644752cc4e86346bbf76994cea963c1720bd2d965deaacff9a7ac57f3e24e88733b1362dca95ba6e1b84d6c1b6a9e10d0f6fd548e5172fa8e9cbe933f4a2100156a2c4d58f6adf67a857d76981ab88d664d9d1d00e1e18e2b8dfb5e2e2c1b0be44d796f42a1c5d3234eb348ed32005c007d758dc03806bc2a393e846995e415e4d120d2a5383d815491562010c7b2d015bdd7cbd0581c14c9264b37e2d08555d3163c171c039865e75cf84790639074556e859387e61b5a960ec2625211109244057d00e5a4d5ded36d4fd749adfd47cae1625eaa737ba14d5d98a6a7dcaf3cf65e7229d0ed6028e3f860ea8fde1700f9cca3648822e8461f20bd7bced4cd556bfd47be51c3d136b91942eb69b8c8448daff173eb5088c7422a0d7c5c38211ae044dd3d6c68e10e60ee9ab2c2fc36aa72c4287eeedcae276c2a1a3c7cd23431fc5aaef87f0bd01d41b270078981967386393cea60fbfba9878edab01a101ae36bf914ce0fe0162cbfa20cc34351916ce7c88b9e5ae58ddc3ec0536f09bc2a868e1f2ee2d905dbe22150cb7fe46dd51f13dda48a825c35a81fc5b8d8f897a88a21557a76f27e85643227cd2f39e2e6a4faf87154346e1c9640b9c4aaa3dd52116108868a551d963a7e132f89863e98d3df8d1e1b60edebdda3d4da0f0800fc63d04203f0c13f33884ada508a0be6624849ea6f79b41d8f22e759466e6b18914fbc99c767561b1e6f9f1b9d11e1fccdfe3f9141de7bc82c4a2cf06343bdbd7f784fff6773412ed47bda5a451791af5ce956bf6a1ec70148449b569239fc52a93700f1483c792c126eac84fbf0edae5596211c6b55b05075643a62d0713d22a86b3e518457f12d1e42a851f4e827a4082d97b6175b80e3ed3215c69c4a5de05a9de5026f003cc60c57c83551dd02813898f1f7af7b0780c5dfbe993c5c90a3f1f47e31c46ab62cf66f060537b7eb1c2cc7f599dd39493838e1e9ac865870f1eaf6611e2ecd716ecbec4ccb4572c60e4cbedaf87ca0028d595a42e192acdeed6573883746ff7067e8b0291faf9e0bff43f38ac1aca788f60869dae6021f372dfc6f9e37d01c07e0c6e6a5c008fad139c7c4de20541692083ab6e83b667b6fe3a6e3651fb5be52033fe309575bab48363e06f0a1aa7e564a1938e34446247a078fda46a5b5e4fcd3d10b5f169531a82920705769336957809ab9e5d7c0ed1901f9f654b66b07cb72ddfa6163e32dd27e4debf5031a66ce2f0fcd7c0740d23e729036add1eb53d7a6db915a68ea77966dc85aca5a496bd5314dd32bd4579ba48cbbc045e9caf243b8f3abead163867a2694062d89e2c314070b98344b2fda4493cf50ae9f6522bb89d2a077fdc9fffe39957033950faebf3575f43c0e2fed09444a67c601f45c47b4985544b5e881657233d7dcad2f39754b9d482ebf61dd27eb015531c0348d46430b7b9d1350cfd09db6823462aa6cac5cbb7ca89d2bea05096b5751ec399ea0b424ef1af8a37ded9d0ff0bb83bb2eaacf3deff8996e7e0a397112aa8bda7d9cf30b6f2058b01c3122fd2a028ca31677ce7e8bb42e1bf0a81f32e9c449f561444b91c6ddc4678f7ac251f5c5949e7b618522efa8d31d474c9a790f526a27a345039b9850fc59a494ac1045c91d53901ce08648acc642e839b596abb380bd48524a3a9af1b720ced52f8b130328ca5a904baa0fb5c40efff17a09d8083fe9ff0f3bfed565d3fc32093fb4a33c6a2c52eacd8e06d880cc56026a3de7af57b1e1aef315a02bcac2c519d25d2db104d7f21c9befa1354d7d24322bdc02fd0487d5bac88b95a6798dccf93d0d3f1897e0090d4e76a0471ef0cb49b023acd2802eb9ca183a69b14ed5d89484faf454ebcbeb3ea68181fcd3c16d924a707ac38af038f14de18a48d2c33a512abcc618e8742263628160c5f2c73c937e996ecfc5adcf5293cdb862584198a6276b8168ada9bc04e681acd4553e8d46da24e85c4ce8bd5c46a545d818816c92a7014db97bd72bda4049389448b48c76f8f33a8a1776b1fd42f95b5a65d546b1fe14b7173caa75a70795a5aef2293fd1819627f22e782046cfd31a1309f8c84fe5dd63e9a26e3ac5ca931804e43d0c7e89fdcc9cf0569b9abcc6a5eaed319723eb5095b914eae7548c260f981fe8bb358693f6a0f1ad32149c01fad7db24357a4ab8670d96aed0ab04132462cb99e66f6732f07981253b763fdbfe56af05aaed5c493097354d16f955cf79a4f5fce817d7c0d0b03cd5fdfb1bb67a5228928d2ce1bcf219dd5cadaaa4b06aee20ffa17e4b9c0fa8467e8ab58643cfed1bfae9d15460a36d47ef8a5b0dc83a1d0ee5a198d0772ee4517f7ac33d2baafe8a9cad7b7bfb58afa8d9d54db2c16b066cc88d83be143f9a15a15130babd4c0456f956a9bd109a927fdf2b858520f1d7359a9832a8c5b214495e9adc3ce631b70756272fe684ff2d5556ff680bf392cd915d05acaa8b1446e27ac519e362a5cf2d9deca4caf51ac60f2d8d1371160ffba06bd67f85d11d936005dda53858b6b1ed899b3cc295e0fef2a09fe0acb67cb97f2bcbb19c79d1894e1dff04f46b8ef4e046f1a424f2bf2a68a2095e5de17ab3900b8f2428be8d4023dc6dea1a868f4a6aec8610888b983680a67ca9a2cab944a0e049d35693cbd34a2e48ab3cdd44d25e86926dfcdcb1a50246439e38ed5f903a4b6abae074ec78c12170a8fc8e2023160ba201de42cdd957a953ad92805eb357a2b3266540030c0c85b6bdb8a1859712088f71d91a379e3a79d09c89fe617312363698100848c181f9780df970950cc7e7680bfbba4543039cd3d0811d3af2b3caa2f24ed20841fb09e53f2ef9c34b452eb0b7b5e32444394c95f83d069611f203a8f61baa2c3c8ed2404cfd2f04470e65d0e7adafe71476527d112c7e1188228f2ca6dcce6165059c929070d696ae4b69648d93717246654c12d786ab2c142b1399cfd37c5d31c673150f2e4b3c93c5b6f51489ad16d71195a329b2121240cb482a6291f7dcb963c8870bcf3e8cf9be85928ccec01becf0858d21291f2145b09f0005ca34972d2572303ce271b9d38703bd7d4123fe1feed37a86a8a230f9304e711382c40fbda2a8691560501941aed3921d2c96e14177daa8dc2260f4c259e9beae46b92a2d425c5712a7e012fedcb4381daf132263ed087c83ea1a90b00087067c125b5f7c11d7a9458943f3c855fe0fc62fb35966611ba83ea6ba8a9adf59d9d1aa82b6e0c6b68611c9d77b24c30bf1b9f39be1896a06e667f8df3dd317573a254d5b6ac38309cffe1d2b863bebc42e67d76e45969ed10fb271462127117b0deccb205c842325d91c244971a764d9a96661bb5bfccf77ddfc8f7574a2ecc7a8d58bcb7b437867f284b785839e773fb1346aeb4c1b36cb6eec770e201f8eeb1561f933ff1bd020f8abf4d54c5672f175612d3de96182989db2dad32ab288d6f381c12a5d73967f65b2654257a591e32889073e8e5b55f9584f8e47ecbbdab330a2c7d6983d649896fef1b7d5c09439b221455bb5ec657d3fd192bbe2d72f106d2920e8f4a57deae6df464435db20c1b07ed361930daf52dbe6ded5cb8ecb2d3b1064d62b38c7cb660f14263e488c06e5dc9370edf0415acf19ca68b6c79910434871cb0d5161ce392b593a0e13086ca4c4fc91383685113cbe2159944b0e01fc548bb6c7df712dc0a6db555f865d293618100d4faea082613c5536dd56b90941950e93c379b17c04462f2905b08230cde0bcbf226833231b159bac1a9c8b620f167087c98a7d60c4dfe6abda3453ca42e97156bcd5d2409b1bfbf012633532892d09e6db37a8ca1f5cd2053c7b5a3ea0ee67dcd84569a1f6dbbc32b8f9008b6d959401b2adc255d7aa507e79ca278348290ff5bdf6efd8834abd3e252c92be6faae353c528cbc658b583957cbd1832234769fd6397628f22734c3a47e060606e797ee1529247ecda76be2570182a7e63273cb1c5434f325ab3f8a7ed901ff067bc4f69b5062199be4a905531ccdb527b01d3544679ea957565aad0d0918e4e0927701d171014e2b5207f7d9622014fe332cc7fb081328527c3c3ae59d4c0ebd53c31d77a7b1d4ee8bc9441d3def8ac321bdf0521cd060aa92d190a2eaafed2b5ce40337324e4fc280fc901794f61d43af84958f18ea47cb5cf875b3cfa6cdbf6c8f5e41245ac20a4a1982eeb92c0d31bd558b2d7576424ae65d283c0110f74e093224144287f41deb9426f4c5e2aa6e6e87b4c8496b452402ced73f035f6c3e185d9b07bf1586e395c2871a11f47724d36b23b9b83f79d1f2d75d995eec58650e50ec940e68a1b1aad95b4f028f86949bb4e57775efd3fdcd0aa3a183a5d9e0f31e1e6c82f601ca6368c6af25697e862a8e4a20c836078fcc6a6d7e3228cc17b1b13824962ef46766d38d80f02baa43bdfcb094194101625910ef29b07e893eacf5cf67840631789fbafba1d694c57b64fa308f508922dec77ad40325630feca717d0bb819a93e8714a623c845cb38048a398988bcf83325e9dbcdeadaf78b2afe5879e1eb1bf24c64f9be01dd417d8d65f0b8c22aec151673f3b37e0df528779d9d0a0ed24d9a1f46083a4b28429be02afb8255bb3531ee951dda7924e8dd37a939f0c93ceda1361f4a4ca76db17c96f31edf0c55ec5b470b1eeeb2dd95bd5eb16a3b5404798e28f8e3f8ed83435ac6b2cce69e3428fd613d801200f9231cf582071a9fb86fa4f9b8037e670005a42226d0b5013b48e680a11dd1daeae946b87f8fc25a1f0a6d9500813a3cb94cd42238bc4198a837f2a1db549c4eafe3f159289d743986eeb0530451a345f8d9c6f3d2d6c4bd90faed64608a17631b083a06c0976ccbead083bd149fca3fe23a00e932e43ef3f8f3f40f6a83f56f16bf41ed1c4d944ccefccde0c4950ccfe0ccb3060d8784fe635b0114708bae0c1062bb36ecf2cc123744b0b618b88e0df8cd80b4a6ad442eadb62e8916c07a11a4e429d36a00c668f596bc0001d5193635f48101ead55d33bea61f04f06027dc1d3ae76c04752b44df8a5a8a77107aaa88b90ebb47415e434682af78d5e2901f308f02477cd817358f0b3f3c29a76b0f9ae1a3d46b7e54c203a5a740f1ac0ec533c2baf75246e2c8633146aa335cec9d528be45a6273798b653608f57c3e1d45dfcb52de1d92db261860b7160846e30afa317f02cbf740892bb10ec413eed5e7cded65f28854ac6759362abf86c3eefbab0e6b99dd786638ce3fa47f5855f1fe585ad8bc6308c8376a6fd585faee605cf625fe96d2ba1018164ee752bc81ee527da1b294ba481a8ff00c661eee38a81d3f079afee7bce5a350e4bd4cfde95b81384e027b66d605ac8acc8a79f043466a532e4847df65898f36b86d9e593a994311d9b49a9ad053a20a1d2df34bdc8f68c9e87d04ece5fa3f22960e1dda4b44c21854a3b18abb161270b93145189ada2c0070cd66c1be6bf487ff5933fb080153a0d957a8965eaa1a59dd2f36dce228157e17e61661619bfb2365ac192a93666ee35a1455f4f8260fb0dc8aba5b7337e47754d524f56e922f857c4242b0642afcbf4858e2ae2f0dd461d7212a8796ee78539552e7223e948204b624705270ca2c4fe56e4616805fe5e73bfd4bf0a66d76d44e6a7aad6a6db8fc600f24fe49c1e2e2222660bceb27bebf425fae0bb789eff26efd27137ca8441e8ce106d6bcf966a5bbe99d1ab3029f01e44bd30d228367b685d816acdefb492864064bff0e3454f9d865f406dafa97ee23f20e0348b02c228e976963053907ada7ce04dede3477cbbc409c6fb5d44b2cdecc8892f6f442ffb65be1a4c206ac573ed24e1d56e684ec37fb2e77a2bd238518176d37d3ce035de93523da938732d46075d61244636a95790d58b0f2cec3ec2c7f29a1978967286b589b745a9209c706a219c188ddd2f5b65393dd1cea6ead2fda022a89d33945b1e194060592fb4b25711030d74b2d213f8a196a0b678790d70b105deefe2c05b2158430a48a6445fc748fa6f233a85ec2cf2e7b7145dfa3a16daf366b90748279eebd7cb6905e183239b55817fc7341b44298e0ab499f0004b2891a5ff99abe1d11db3b6c7b547268e13a49c00802f4a2c5339027bd3c2428c0be8e916a9aca55e22fe5b72bf7747c73deea4a35d28236132781da47a6666932000950ba6c71fba641902058ed239434150fb54dee92ad91c294e89476acf70d7f41caa6ee40cd2189e7e4bfb581081765f57f45bec199488b9ec1806ccbef302cd75edd85f2b8afe0997258e0de21106f415643019448bda66abd75099b7a562c3c9c7c16ae0a3dccc63dd035fcc5e8ee6b05486b3083ca6b92def4fe7365ca0ba30825faa027498cd8fb7cf5dfb1762bbd12acf345e8dc5442fce1f4b1ee86c372abc5609dc2c571a3d06ec4431647239c2f6cbbd93135d6f03798211096a9ac3e4b85951aafa94c0c9107a22df5f3211f1be30e9c859e1789dae4575ea2d185bfff0466da540caa2b8f7cf9bf50822df9da1517f735654ccc8cb88766a08050852db30b28557c2ceca55f4d4f9158c70f7deecf76c4f687e3484b2ee2a63f21f514d34bebda19a680b9b8fbd15e00e40ae6211f092fe70a992dd90323df9cc1989b568c96e81f08507bc832120abf6b4f397ec5dc28ff7b8b25205371329fcfff846cd5be410f02241c9f5772274d5b7a1cacfef8bfc9e8a4e8f7fcc0f233b4a0522a8a4a0ab1b92ac0490bb02387f68d057eec60dbfdd1d9f2a97519e8c03f9c2fdb79523ae66010b9946a0b44e54f09b0e49513f8e06a95d5ccf8d3d6b43168c23f98ff9d12b359b9d98ceee2a92c35c9d23be433614ffdad3c2913570abe62215b5b82047282d1bfd419f941636ce5a7e7eeafee96afcac0d739c824b58c661a13dba81b81f6cd8033d87dbd05ca0c3fc0e6cbd907f877395e8d5532e9d6dbd4bfc8a75f49e9341df7bfd0107209abe8d75e3dd6ebe48253c61ae29d7653ff4a97f98f67de7a4c0f9173fc5ee55c524ae7273c88ed07fbbc8aaca302c431afef66bdebd326c2413bba7b3e071f4df75c1b178432655c5b535f9db6cda530cf1a7f8114c9610c247ceb2b9e2f8643abb6b01002295e34db2a3da0b4a196b14f39e291eb6033c48dd5ffb9bb31644e9fd03a7b2b590c1ee4ba6c5f76a6279ad06305acbcdd4867a0d19dbe93aa3d7c9788dd2546438ab7b842f70451d5286a71155bdad6576d1548d3a51b00d69a8288fd4aa680d661f25fcd9da481dd52d14f47ede852e9812953bc4bb6975bf39bc300bd3f823cdbf379ec76b9b2b206e39cc3cc6d1a02e6e794dda38b25c6ddc04501be13220c1c20871e48928e5aff9f513f844efa33cdfcdd52aa9a19be6daa97011fef01baca2c09e4d9b8292b8cdc3f6f27cdba31ab9b0da79f1127907d19ba7daba1c993825f3017ab4971cda7ee499ae4b49dec8a963007ed9e37af6b6a55de3a53a50a293c6b99d39ea62d1d107b427684777ac65816803c3d","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
