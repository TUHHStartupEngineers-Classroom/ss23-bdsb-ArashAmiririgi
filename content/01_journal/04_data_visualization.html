<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"3017ed329242bd8632ba22618ddf780b966cd126754da52a1f5787ec36d03b663c2a5e924fbc25a579a1be2618d6355b8a29bfe2252a8f976df260cd8f269c613955be62387013466a39381eebfce969f80111aabf00b478780417a44b2f4a4c00d01f975cdae9fc6dc8abae6699e95fb9d3b19d06a87cb0bed820e1e9c53febf9ea1162a671044564fd016b99d216f5fdb4ea53af47d056df3c195ae6d20dac12cfba68db5c15a6b06b3bdf4d73d15dc966eef8c856c351decdc1fabdd6ea8a239dda8157992f7e37ec99d72b02881089ded5201af195449a6f0791f4216accc4a88296b0afc233205000a76b96e941f809baa76d0146a41c810039cf96758a93d13aed3a30707ef5c41eb5b3e6821696f57d803627ede2a948c3613de79285938ba757cae0a0a839e1fdea25e38430dbefcec206957c9f4eed6bd903945cb59164fc9abcdfbee3ccd4f932e53cbfcd1e46174e0697904c730c8ec47645493ff0732d9de5663668f46ddf5addc430240fd79bc8310cf3eeb4d575e88ad6e83df0eb19b3034b6c7cbc2c4336f100bad1fc758485a90a31be0ed59187ed3b09b9d753b8dfd4250dc31adfd59da89185b614ac118eda9a392b4b0771d90831b2450f5285eff0e67f29e3a262a8272253c7e77ae900760c95adc9c3609d8d0ee08019defabfa234e48bb17b4b1be3eea3b32ea96586fa4fc825aead135ad76dfa4dfe0b328309770458487deb0d91a4e8c39b7e49ac64255cb95ca2e71c65e4244f1a8a04f8cc27fc3cc7aa9d7d2e926da704c390af531f1752f669b40755a99017e0d3542440a82429fa23782441799b9d5480c0c7c33bff8918ff6f569d8cecb2f1f6b461fcb021e72b74c3b265ab90a83461afe8db42ee5cf667449c4f4e87007d6b1f3b19e6157ce347d26285f4bea47bbfefb2e48c4cb30ee5d0c2e8524473587cf065247c339dd157fc8c76387a933dd342c0b940bc1c31f4cef74a1828909c864d16ca53c2421b3a9faf8fb2fe09d65daab4e1711d97a94cf1924ade24f1ddb874479f2cf6625f9b681c8642232036a8ca689d763b0bd7b88c4332afd9b21b05279e9c16d1dcde58c118256f9c46afd754bfcdeef2b8d41e288d199eee0b3b8b672e4a7e3fe723cb70facb106ae2d997bec9d02bf1d5552a28ebfda649d8a42b0f548e6fc9b67ff29fd7ff80fbbcd00accc3693a1564f74c0db274951a39628ff016297e141713eb9fbbf619ee246540a880c91a5b385215064c9b1d9c9a79f20d15dc658810670a0fddd0263bff630287ef6e4c2044e19ef0272b031c0c50a4de2cb9cfe84eb4aa770efa4da9b06f8027d818ce02c2a8e26b7788ac614e9c9b40c3b9d165a21516f28c9ac403b0929fb03402683a3af4f5de7b97e7254aa6cd7a2346658c8acbfd53823acc63ca2bd8a0c20c7bd5a14d09c2d6c3eceb50bb7063d65efa41b4dffd723c722e2a3eaef95b843365ccd53475335e9b3ddcd0b01c83f4c79b3397b779f704dbac1a8b60fc2e6db13583eea7369f393bb60d6c9dfc44a60b8fe69d5f64e53d196804893d939da31f5e8b8c3591eb988d77e34dd5d0b0e77eb98d5750a1c19afbf33d336f5f6f25a603219ca11262fd4808f0fa26eab6e3bde065d10abc6d3c2045fb745050e4983efad0aa3c78a99145ead0d9a4d35722513de85fd06cf140f5c47a11e8c44f66d6db02a459a94202a803712d9b9554be7bcb2fff8a3125c03990562b90e98bdbb5e1b0a2d6fa8648c295d1a4c4dc827f4896a76fff126d6e2daaf9c6f90a03a2ebd0aab8672f570d32a5f33bbbc4786ca06dc5e55f009b20e5831f346bf60b3e8f266b601d6f3d79cf15305b622aeafe2a4361865f847d78ebdb498cdc276330627dc478b3b0fbb8cc6a933419b6e5c6847bc06c94eacdecf65687e4628eb977cbbab40369843112dfe8b30f0454adbb42a70f31e3e6469c3ec0b8ce4024fb5084ed1333b2f9f1e49f31a20d74421b8805d0d745823b94d211cd47f87f79540fd7dcb5ae7a2494298ad86025f55b6855b855a1b00e6259ce6da73a29f4f048281e3592ab30d8a30cdbcd56bb8c7ff741bc9189245cee9e391c1c1e7104981c864e93bbce733710091d182ce7481eeeba62e515b12ee2229e5709517c72df2139f70d59e66e5b4a52f100341907aa572870b2a67152786afe4b1cbdf58155c958b1061f71ac8abc7a0978c26d94080a920540ed1cf4ab362837a27fad8634699cc728f25ffb5e190ed583143234541b8dc37930ba2dd25543f7afc51cef2d1c5b343f9f35a559e12261bd1c8bc90485c1d006b10cd25c43c68881e0d2b3ef8810aaac1922fbdc4d1b76b7f049043e5ebc395b2d1016e62faea0dcb41619c75857fca9ab6cb8b93f0b92788583c2cd15df2afae85278ef3595f1da2e3d6ed8d900559a95b7e0529940143846f028266de93179b9f4fc46bdddf1d65117fff397350507e61e4bfd4bd4583969c7873454b5326f97989644baae9340a85b3566c0e5999b91d8c912404952cb5fed030064f04b6c57ca5ceb4b5c530873f7b81e5bdf57edeb800824bb0129f5e198e969f6161568392961a5546d2135feb30409ee170bab30965d46f46f6a0a02900da8f174d050e60b359e48d06bbe783f2d48d93c94881391237696c410bb4fb3610e2e72d12291c2ef20272285681230518bd31e03a5820cc84eca811d7e2146f2f0bc8ee87128e2db3e8fbd8c6dbac5376bf75c963223ee44d426e8b1f1c49dc47f5bdacd7193c32fe3f90cf4bff0a6533526c08b08e38822307dfc418b90ccbbb9944ce329e89b1084c348fadf2df904c1fc3f59ea1103e3f67922296de42c16ac2a75c2a08a600666655a2a31f16c5d232cc78e8ce65507b76e825b90bf3c1ca058c3e00dcbd9cbd4db77cab5c0e4ee017b242e7f04ecee22d8081fcac37f33ffe18fbe20e3551408aefbcf97e1f6b7956042723a26fc690619c724aba49021aee80947aa08f2a58bb596e56882939ef6105621f782689db317cef9eb23180ef181f5bf75980672f0efb21c311a4429ec08344867abaf9e6e35de8d72206337ed63930ad68ec306ea22173080ad758d95810040c4602d9590191ea270b02345c7f29b2c21f6cd0eed639f571fc9feb0298bf7092abbfe8b039523795f0ed4a2f38bfabe52c685b3c4effa8a7a769b77d63b341aae790fd3a69b3090641654a96beb1e347b06818b4655d4adb810bc751331cb36999480912e324be913cf5e922ea06ac44af9d1ca231361920df5e9bd9a6436cecca6793ec6d293a472b4ac5102d7111653ee600754a1414eb5c05bf7f16045f6977e83c18b0d0a665c956d15b007cd0897ada770312b0ff39cee713089813d8335331e7ab012aba14e11ac83b97aea30ae06bc5e1b31382d27a9360fab9402a58bb70330c24d13a00ae683bf2f5ebc34b0b8d6983e6205870f1ae6026848035121de8d65572138ebe0c43eea4e607150ec776be1f942cfa8193c771270303a80b8d56a62fac2f6aefbc11718481de0d037cad3973579a2d49302d8889a2cb92ddd35bb44ea151591b934f1d5e4794bd81912106ba4dc77e747571aacd16a2b7e574512d8ede807919790db42e1365c06a0856dd455f47aeeebb08d4db12a6c798f4ca617ee59f87a050c2b88fe900820fd2de5ec33539a932bc3e72d116ba5b5656b75b367719f1d509dda2b7b34deabeebdf70d8deb81e62158b4583fc1a706c9ddbaf09861fd6626cceb54b67c7fcb81cc4a7980b55f093668d8b9af3a9fdf07bac86d2b2f3aa536dfc7772b7c485fe722a0b455a6ee59802eb34ff8086230bf56369e78c2dbbcaa5883e9db6215ea0f9bb5ec16b52836c49822583cca9b6ded3644076bc787c78ff7653d061dbd7882aa422ea16f5cc2c694f98588658c4c9460a8b9fc288ea6570de274e020224aef9a814ffdd7289f1643e15ebc28cd54f040636bd3d8bca304cf77f490dafc6b73bd5c55acce67b35f004db3660ae4d4c6f901dc0f216cbe23c664f16921fd47081353d1deb8dd913974dac2b0f1fb9ebc16439076cbadfb17577ac969eea20c9407f6e308a194c55f2d4ac477bc847de447e77e59a08fd52e83e31cd4ead585d65e12c392dde280b27259098c11061704a0067bb9e29778dfd6b80c0a4ee2aa335bbc04a1fe3cba8823c8c7d66bf09e0085d5a3361b5872e78f55b4ab319c61315027e19f6ccf72631bca5e84039a38abccd1cb0d5698c054e1c45c38a73066d28e33e1ed2c6ebf89928a4f1e8745a354b2d9bad4a3832d1a89a1ea8441a3e1f0131735aa799188bbe9d004093068cbf935922645f4a17c1718625bc36998e22e6c4e9fae02992716a74d7bd569d5841efae57684a8afa7cec1d4f9f6b8d656f5a21409aaa21cd3ec52207d84ee4beb70daed777a40901275eb284bbe4eccd819e823f00de5e87177ddfcb3b42b6563e1fc0450d460414a709bf97af74ed125bd094e6cd8ed45595da5fa06d234a84e22e02bdba6eafe790b8e8489f4abe80cb543d176951e46b4c0de99e672af5fead7d65f58101f699b89cb5cfa18077a33b97541fe5b8d5af2016244e70a6e9f9d88a9ab7667915309ab3a7c507e85127977ab68cfc9b111d18ee613a9a8045ca67d01adf8f33e0208221f6f8b79aa583d9bf6f42674bca5f6d482ca917401fc0adccd2e54664ad1394ff8c3d14207d62ed53eea8ad1c7b60c63e9e38960adae2d2981c7627dd56e37eefbe0967f8e90986711e3f6d9582ea84bad72739ef5c972b2b3b980c52d79fba1600b86fa91487d878378ddceff2c809e7280145d193d8c56f2d1e527de27f5bf27ca08f5c6b3733df77097308347a8fbdb133912fc5ed0be0f5bccca84caeb9b33a69a9ae309868659c7db8e75117043a3925998f0aa65c7f29be98251a9d36ce2fcae7d249f3ba2b21418d68adb9048421a0aef04d6a48ec9b2c000b2b95825b795f29d7dd245cd7fa56485a79e9cb1c21931bfd95fce0cf6940884b0b69717b6e5298337a1ec0a3c4a7a4c185143901172ba951ace137b527bb508068d09e7b52773131056ef89dc12f65c33b2e8d4f7dcb987d81174a08c12883b0ab4431611fb0819724aebfc14daed48c25ce3d0b4fafe19138422db4dd13b437d140890d86d29fb04e2b7b77fe4b8aed25e70ee42cbf867f5859d9686117828c2747ea88ba51a0b91b04426e9f318d0b45a3ba307548e9462ea0bcd58bdaa589e324df43453a43922c7bf379e55df5cbb163598a32bd26003aa65def1daa3154e330ce301daace2e7af688f340dc4a1382488965b41a8489f64aad9492d79402161fbbc669c9e8e8b96cf2a67413c30d57c961927bc1ba1b210e81eb076e52e1d1d62e8c36e852313c84f2461a83776f3c3d84d91343e6624b1bd2607e99e8797b22e6dfd8f31ba65f955d79ae38f706985b038881c2ee05026a5bc4b67348ffa2283f1b468e3bfa5e735a30076b87e2cd554aee270d848e1e29d39b9253add58c468a9dbecddd474b12d6018332219aa9cff4b55a02b7b32fa0237c52b09fc80fdf2a1320ca0d2cd18cb070b7c98db9e8314c0f205b8b73c5952d11cb850f8bc9b70f1f711de5a2da0ec9c2ef38a185a840850ce61dba166ef743276d078af96a855ddd08ce51e7a616aec63792761d75fdbe787411f33b61631b3cfb802684c737e29eb9e1e5a43b8700fef155e325db28f7fd104b210cd6e36a80917fe7f49aaf264360e0a463edb858f43af997bb381ea72daf9df39e18015ab5f484d94154a31d940c8d33403953bdc44016ed6e8ffe21cfb2ce94c6b4b2eff177a6a71a90e03b1f7ea27fbdfe073690e367874eff86c0b6a98f36c4ad700d9b55d861715c2731bb5c37c21db4ec56520060ca80cefb0962037a9fb016f9681350ba5a4c08a753be151a4b3a9c9934b4f503cbc24e4416d0d0783e4025f2559debc170c483d4df7328a51695fee13294b627753fa661cb8d82a2576989872649ef0089c51d31c224b100a5dce9676b02ab167779eaef194cbcd36938ca9660b10641d4054b7a01badcad306b3d2fdeccaa2474b310ec8b9887be45a914af2527a75a83dc69f0ca6bb652ff58e0345b0eb73da28debbf05f2225714994d53208700c9b02f2cb9443fa4f092f90b45ab87592757a54edb5324d99b7b6c05685ddf1ce6e844b11e6f168445c2515939fdf49c2017e6ec35057ab2d1022db1b926a90712792992fa5bc81929b8e515b7ba9f18cd8d64ae4787991a836add75ad0aca2185527267ca2a60085bef7a41e84d7c5b784beb148351d6aced1010dbf700be69265cbb62b93dc055188d378b95127e0bc5b7b6976a5fb77d708e2be355a24b3efb0bb222e7b12e391939c55f843051e1ddb7fb032d2074bfd47d4e2a24a06b9638718a82bd4ba1662715df490f7098dca77ab6fcdc82b1164e8ba169a034dbed9a48c01191a3a82a9fb51541c66cf1aa8aa16f596feb3c4a38d41b72912d3df81ff415e093735a7073d4881fc55da06b1b6f4c76d9a300827fe55712f9650d4640f626f1bc86a970d62754b7b2e93d55528983c3fcc0910ac40bc438df4187530340c4e899481ed04abe0cc896b1c4efe7aad02d08257c392c18d558c8ca57e85067bf15626fb61d9e7b3312b6d248a9b330681ba6ab1491e5401be76df6f9e89bea3f1ceae54b812c7ff557e1353b0fc747ea815e7453125955a830fcfcc3b6f039550a819d75b312ecabb9255d7ffb6dd288ff4a8405478d8e2a080db4be8cabe5ab733b844f464f72a147e18f220a6c48ee917ad0a739a61bd017b67eae89c8531856be1c23b274b492070fe1b769a343c639f18c0b76bbeeea68a519e635cc989d5050361418bf7a7156f6c1371ff231b09f5450b1c5a85a1f0f2231302ca8c83ce5455fbe96164a7e70de4c91816bd7f8e20d9fdb1e33e39ff46000a6682824b3b710d54d8260ac72bac266df8fad09aa716490a6a412148a82d2add9fe495b4a2a2044bf6e7b1afd6b2d16945fbb4af74b94feee5fffb8da2bc1e7ab14b0f1f26eff71bbc1b50fec6c6c2282f52439ec0328b45fbb2bce0fd0481de1ed70efdfe04073515efe90aeebd552fd25058049e817ef0b538e577d20fac4f1b598c642885170cb74e963507c6ec126958ce3cd65e5c06f2576edc684d84574dfbb0e9cb0c3c49db11ed79a8626f35516d0f104c76ecce93495218ef6af203b1bb702f2bce57223094a149257a645390387b6c6399f8d9818d24e65c641a0942d28723be5570c39ae1df5021fe3caaf0436afafa651b445eded3aa2477e2cd7299f5a3abc8518ecfe87b40c31b61d32a97b44f62a3e4d302a352b39965a1480380150ae4ac988c6fceabd2d3ababd0610a3fde8c59fb210d09a7f28b067668f400e6014b7424998ff6b7beb324db4bf71447dd9085128a675c97a54642b274cf758a8ac5c5b60e1585d06dd44b17aec0cdb478efa513e261fbe13382f9cc82c21f4c684c8434fcb29b029bca1fa01aff6fe33b76121b477cc807f102eb094a3c2b1f195b94d6a7010e86510d4473734b305ecb16849d205b6f3de3f544bb3e1ac80593ae538ca6169a7f19dcb7c64523df295d73ce1d5b6070bb1ff9874b80c7c273ddd6cc3904e301aff73e49ef03d54baa4ccaf12dda84e55f5d826724ab0096e28f85adddb8bbb756c1fd34ba54b6704fca1cf32b1c771c97973b32ad2b5fbd0c550a0e17271843a30fa8cbddbe85036102bd8777f0ca93c15eec57e58b86a528d0e319a1966736134728447c4116626523873cc9ea26289f1414519b2819eb0dc4649839d5696707e4653d668e22d44a97742c50da17ca2f4746f7c3f23852094816c2b4f2d3dc72c15595ba90419af0d5f6a21c4435455fec7a8fec994ebcea17f98726fa28d6994bb2af1442a7456422a28c3207f630255abc581f8ec323eb0e47511928914a6575108f1e281f48e317114960fcc0fdeee382493bafcc920f1efd11fc11a10b6ba39d7fb331ab502a372b5de35debaed524838f093e53662b085a7e3fdf6333277fe383d03fa7138c673c4edd723cb68a29ab577b4297cd48408fca165161427a1ae081a261b63d01f26f737812f50d75f040b4c4c3d005e7c3c67c87b789c91b450094b17d81b5bc970038cdd10d86c2bfbc659b22353a492e7dac81df0e1942ce722ed8ec8689f3bbf5f02f8f69a0b5bb0977a5266ccf6560ecdcc3c2e5a17877c24ef539443ffbec97562687f3ca12c495955320c3a6b821e67f26591e9f3becf16cf43307518fff1b7e9d9cf3f6469c12c27d3cb8272d6a9faa490d1bd7f2dd9e22cd48d95e19a41c45c97257a4fcd5c91251355827bf48456d92e3cf39fc1a11ce48693fcf0e231a0d1264237c5e279937981c02b968816b02054aa83fa9662f5a80791b28f8016589ffcf7848d07692216cd9452198e8bfdfcfcd43cbff7d7787881396ad23c4a2b47cdb625ed84efc8183e0d34a86660cf42826e872b537ce26778171a184dbb2a3e0eeef5915ce6bf2d8fcc75216d1a41a3ce68f1baa7945abfe8092192346f1f7880aff63bd6e94192dedbca3a4d2251cfb0115cca39ea653d15974a3bac2123b098c96705c8de12e2f610ff111f95bf235eea5449ad09cc62e710a9e07b70e7f38910968318420bcb351e200a02ebbb2fe5363e288dfc76f49d2a38b30ead9b16a375f484e8c1f582407655c5a6ff7354b6f471bd21c39d975d22bbf387508e8fddcb906a6dbd1ba3d9fe4fcd65187c8ad6b5909e853b9d5b70c8d736e97fcff1a7a84e060de189c0524b321e94cb32d355dcd3c809ac3d5e4ed5e68376cad1ff97d282e9fc4e36f005c8e9cf41a4f68cfd41ab95ae5deca1888390c89789cc3c507f48497b2683169b6bbd86bf112621c365a997e00a4caa9eac19e515063442ef63505fb00a6d6b6861f8195ecbb906164e4699489d01a72b75068027c73c637cd2d9ee99c2f6d685aa176aea354b714664cf812ed42d80af9c14ba2aca9e1550bdb79e17dd1decead1492396f723bb9d0b6efc3696cef866040d425329fb4972c8d8dd618a6c3ec839983169b4f18b97cec73b2e00ab893f24a5eabe6f0639cd35cda58991b0770aed5cdb702ce4a510e1f547cd2a5d42d1051f2974c26dfb97a2ba358c0d90a748c1d29340fa661a75c45d7ad369197d9b92fb9120348152258b98498beaf24148fb7deb90562fbf5d4c759410e2dad85375cc2e8190c3b5ae265232a49fa11845a338f32b836e430beb055b5655ed41b342ee03d0c47dcde5ee7e969f98cf1516e0b6fab0f4b9bfbd9329960f0196faaaade35e41f170d843bbef7d813bc133158c4dd995397511616063208e5d852bc8fd586fdfb22d8c48eff6dfcedfde5fc9f5e9b87d6222061a2071ba9249427178c1a68ed1368196a22cf5dd1fd8bbee173b267f397f7ed4704e0d97e52e2863c80d40c31c245b0de6619068e09bf27d78e94d1e5582752ad31a1b2cf4853a30ab5263f051f1a654b9504b07e36cd42bf164e60a04e6659be883f93363fdbf519dd98e013d9f36c99ec398691c079f4ef4c70f79372899f6255689709997e263d1a915440883eb118603a596dd9932401626e9364d42f2344a4e465e5facaf11b06818621d7fbbfc6e161923accc01a0fcb0f537cfe02441eb106095509fe90a4646b833f9c461ed7c49bd3ab4de93f493b0be0d282745b360a6cb93d62e269174b1d07527ba18e7d0997e6e6ef55689b8d6064ce3941310ffe4a462c7da3bc2a2c54ef9628e8509e738cc75420bf1f80d87edb3e9e75c3c5e826d83a05abe78e5e097723de88f97259a085ec51e380e6615c4cb37eb771117f46535391d69aefc981abd4f0d61006a2f86183fa133a8c8b97aeed7deae62cfb385c11a54bb9f37fd54c9115db0d2f842aee945a7a5c97f1b598a74af89179f4367e0189acb6bc18e7330d960da89466eeaaa400d5745fb6e803f73eed4b209922f2c4b04015676b97a86e978a58d6df36c53e6d196fb003def7ba9f9460129573aac1840f5201580563fad05f942727bfc5e507a97a58b6e0c9d51179ae079c8144fa1001343c727b8319f8227b91b27fe9cb02d4de6767556073f5b06a1c0feaffcdd7c6c32e6256e99513beaa8804d1fc374ca09995e4b86655e4c6ab256c1f3053eff1bd2a0a5b9e9516537b5a64891833b8746bc1ade2bc34d4b35faffddc6c0b24b74ab4a18e85e3487add60e8941d494b8f1a9f591d8d1fc621c1ff759ac43aa13f68b31a6f896d7119509e2ad458ace4953a71cc04e10885443fa86ed4086603a5c7f01d54bbac72782a15c88c5515d8f30f09fbbccafeb69369cf2037c995916a4718236d306658f842b9a6f153ad43f8a8fd66bcaf2a9125d11e514c705c017a1756b779a0ce25596fff8ea16fe22761af39bdcae0b344d27c14040118f3574dabd96c22a10e848a5a5161d9b53f98231b0940a97f8bc87340845f9cdb97255e5ceec6ac7289fa474b903fbbec15428ad4b0fb2bd261c849396970a35ffca9d4322e3aae291a6254bf7b6b8aa5b15ea513384aac4808cb74bb8c9f24f57e8b792c8142dd29a7d8b4cb50bc4b18b17368f18ef8f43577e5f450c8b47250ed283de5070dc56e92fef054b66e99cb5a923a8ad97db1d62fe0eef7772dd833f10de57b322e22b138c053c44fb521a0ad9cd2cc4015eb29b898140184f006874c127122c20806e317d1432a6c0c7bff0f6f5d07238c7b5d65c0b9ef5f757424da2438bbfb63cbe8109186ef8ae0357a53418ebe604b633650799075af466830dbf392803300d2d2c789b986ea8b6af5867d1759b267317e4e03a3ae5eec13ba707297547d4e91a85b18c5dfa0d8a4c6fe96fdf50bb519d4187e28d653d0a60c2b7aabdc677a41a2f8b66a90da2c7c4cdcf1353ec10f27d62f9a556f2bae5bfd83c8a1fca24b0167fad3563df835d703976d1877142535b8e138227821f4470f91f80ae7942c8c530628ced4931957e9b22be1531122cfd2f57aed19e234dee81276e32d5ac38838f1c74f9b08d1b67c0c92df00217bad4a3d9afc3dc060f4c7d2f5afc52ef8cc150b025885db85e5a907cdcea5dab317691e9845f05191f972ad32b3e7300f2b3291a6d14235ec5f3fdd1207e53871e0dfdc2ed309eb8fb49ee38ea2b09bc68961b4ef43d4b7446e9ae20df00b5081c4c423d2ebcaa9b3cecf2ec1383447fd418a726b9a802c1422e4ed6faf0b4e7bae78a43c22b6ccec8911ef9b4d4ef721150469e358b6b47024f7d340acf3e3364caf78d57c3592420f425f3513f4fe3f6b24bf5d0422d822cf05c88f87baaa774c084acfaed5c218c6b08c01726e35f6c9f87b5e84991094053d476477331504e513351d9e034b83836e93e91b1767898bbbb6dafd22dc9461c675eeb90529d9bf045bb3864aa47eb46cc58f3261883fdc39ef55101499e635e118e86e567f6bad3b3fea37b2153eaffe538c40e12f8f80efc0cb96f6c9a52a42912198fd59981f658728712629a2dbfc9a833bab3b648936adb348fc8cbc6e7e62c94e02b20f8ea26c4f4d756e39e7eaae60b7ce86ee9e11cc4667b655e1bf153764e49931ba9515ad44a979f0d979bfcc6bf8199b0b3cd29b613e4a102b379121bbbf5df33d056a2cbef80496e699e8c9666d94114931fd0edc10783ba7263d369e2b3b699e3f980b3806498ef088ed819e7e64ab834a8f6c807439101a0fddfe9e23a44bd29fc73e7957692cc67d6ae37f317a6b7ed22e0f94b7ab845894024e39528af4eb5f4bae802682312590ceebc4f59af0fbdc371624087dbb4648bcdba3a1c47d91268f1e7f2cad0aecfb364440a3b713ca0bb8f4781ed4ad18cc373dc07a172339216f9ceea0375b89333e2397fa937a91821fbd75a257f3219416da15baff65aa4c17337fe02dcbdd5f6b16c1b7fa4f1e10e6faa7f3ed032069bf4d7851dd2cf14e2bfcfed9e7f2fda158508f18c269989ed85f174e8113a699180b627104491e79697974b2e4acde3270a95af24319b1cb16f06c5cb75216e0d44997fda6a682727cc69d5fa823c6a1c3c9a159637e5472b6fedf0e465594a68dd29cc934ae26cc2b6ae71d13e607f0edcd5d5af343e53594bb1a1f08d669dce29d43f7ea6626b8a793b5eb197424a800a5a3d0b5c1849347a5032d72acb4ab3b633b8bfcd611705d04ca26db72cf7f6dca9cb89b5baf5a9180a08cba57be3088bb9da1c9b6773b6451b81398332e544b0c943bb547af1ba53710a624eb4066d1bb3deee71448001d9b1ead04870e7fb125d98c37697f0f012b47093bca0e93f67147f0326fadf923ea1fab042f77169add2a6e75c3072780cce1f1a405a9d07767ad4e374b423ba982b70604cad5754b2e9e0d4efdf2c0af0455aafe9ceb9b373bec3729413e975bb8c186bd588657206dafd1a93cf34c3503f11b458a2cb1e55a8a252e8bb3676d181389301714114a212f923dcc652e91c03e6efeefe0fb5d1b7f81fb720c8bcbd2f78d898b6d5d278678500529b4b627861280ae60f43caf91d7641391dd5d9956d76f38c2478c509bc5d6061ec57b86c7fddda62820c202fbbad0db452629fab8011b9cdc562041dc152192e49e399d099a427d9473e3cdee46c3ef8166121277941521cd4f8cf68c00c8768d2a7513687a87af45fc007faa2be98cf2b08e7ae55ead421051890a7ae2b58f51418bcc11d05ef5fcbf4100aa1e78a95c0c4ec024937db24c6d452f1d5f6fbed7106d3a5695e388201468313e252720ed0ef24221c516e9a10703e2f0eef8fa67a586e429dc43179f8e059ffeaf8f2222abf0545e75dca3f79b22947ae564924f36e6ea9b308926ffa65f6f0aa379a0d590d6bd9d6cfa09111fbcf2829df4a7dadef5107957b4e545a3b4458a3ad36f39ee93b546b6ec0f4d8d748e0c5fff8a02c4c65d4c2b833e2d328a8f83ac1b0fd15f2be19b0a00ae828e00d6e514481417209e55023f7146acdd730a118eb1d211230d58870fd71b768b4e97687fa293ab7c07e5effb90ee1e157b1d8f9ae44917a7ddc348046644138713bcd3430b272375c6a4e03b0cd92efa15cb24494691d5af176836fb8ab8386666006e63b4a62d930dd41bf06149eddbcc5ce1ba3b7385bbaabdc4da4006ca1784722b0e22551bcf5d053c071d3cad8a7fb52df119ed5d6a8e4f5e50d8dd19d5470c80dc890e200cd3d11740a73fd4f7a40370d4257efe63c49006212f4bf99fba43dd22de54dd884b89620d24a0214415709f71d545d0ddc6241452b0ae78d1c939124ce8bf744ac84569949102fbb91ca1463f8ec2df569482d18c5efb9a702b339d9fc840877c3ebdf81f51e61d1d7a83919586e68e856f58415f00837786ba2cb2e63a1d664765d96f9469ee3971be12621b45e4550baa35e95cee3fe4e00207701db673f637380d721e239656ebb498e7afa815bbd3c9b22ff483cc9662d99a48c10a7381e209287c14552b50e6fd1e7c149fc8ff1d2a11d24a2602c77c1bcef564eb512da1c83968408c00cd56aeb2f550dec3d2c4241f9792039a054d0befddf57dd96036df9d2a8ef22f908c74c59915c60069409c23ec038b255cf3b2a587a41414ba3900af92ba001bf3f0023bc229d96d35a94f388d5b57750dc960e0df2dd2bafa51a329e80b60d5a96800485c2ec96cbc85a73328c749235c7d9e82841aa53b7d7685f8b26f9ef9d581ead45974ac066ed8a589bae4c51d48c714fab0c65a3750903b96c1a3250c4719eaff447eafd1deee7123b529c8f64befefbec5de3954890bce78c2326cc2e37a8750d7e29f695d68fd6dc0b9078cd221aff297bcd2f7315f113696c824c54bc5f6c57ee29bd675f543ed1bd5dbf4087e92d79ac67c42bac22e672ad39eaeb42fb46bb202ec43301a9d35b801ef1f4893323f1f6312a7473cb5d9ea624f44cdcc08e18a20d039cc13efa5222c1701629486a5ff5d4c546eee90cae6e67fa191286625412ba274044b4b62013e53bf980df2008cda28093aa99a62d31e749ff3dd94a8155095c83890d719e1e2f216e3ed2a7775e8eb5792dc7f5b45e27f7d5a78a96e110b00caa7dbaa7a071cf96334318feea0a0492f9983c6a96cda27f071b5c9640b26aa0589055e7fd87c8e765636ef907d02b6d3987cedae3b451f6cca6830d0e7bcd275c8addf7fa2dbb3c5c18fbcbc8f0d31413a52f5651cbdda0bfaa10777b748b88a34173c6892046a1770e21d19a25f4071c4d2320653fa9ea36538cdb3075eb93e00450b8cd4ad7b7f24cfdde895ab0b41a35c2c1fc1790d2c6a720092b4e51cb072f090f371f4d3043d5a22bbd79296b25505d865fe33a8d2a94458598805743a9800177bc0901ac1334c689d9eaa2b65fb56d949ba2714e5641c1cdb28042662884a6ccb79b48536a54f411be22547914a94c8a4cb0765d65961d2a4ad40bb1d8843abe801a2cc18270a47f33f95d7d78fdf611d09c7fe96ddaaa0af9155fd814b5d46fec61558a1eff7f0c6bec9ccdb2e585e22dedddc47243d11bbb12b741b2fd49cadc82649fa51ad9195634bda6b5a8be36d1bbfe0e3f5ecfdec9bb1ca552fe1ae070c5c4f7a124e0525b086539592dd28a20b0a1c7d1452ea2b35a510106e5192b86ce5e9a262ed02df7b6ab16ac02f1760c55b11541adff9d7853aeba67807102d1b8e20e9fe8a7e2d3890d79c4a977714e3ace9f738d23e207ca3f3c66d4a803517afdcb46fa8d5db123ca0448163dfdc2570f014ecc8e72e776773335ec0f12a7fa27c550dd8ffd49b658afd62612fd6275ef27dce91515686713343544a867bd2e47d8faf81c61d6bc710254d9e930e89599603bcb1a424378756744ef2958a971ff32269358d5ca2afe2c67b0c9e820d1d0d7a49b6eb55cf6a6d19bb1abe7c7f57e4545e6ee995835ace149c2259ec5ba22c5b14300a3d4f515b7dad97c244e1c87940de75d3a32e4961cca849b5613c4b0f567165aa0a4a5bd81977158765ea1b06608f8fbfe1e9b9f2bb0d256d3eef293f40a5f64f5e5a4defb33a0f8de5dc6fc3579f16c5bdfaec1688f88e51dd78a88911c1dff6d6e0aaaece5fcfb77051bc7ecd19b4b1399c1ffb21af28b1f3717dcf035f163a760b133ea3b6e0dd8736279708f32ad46f22210624e6f0bb65cc7adf763edaa2eb6975a040807e21f03df8e7019fcaaafb27d0d24e353695a4b32035e94bbbdef85b0ce4b6dfd6dcdf6a381d9b4009e658554ebefc292f1159a972fa96b85f54185e51c25c12f528df479cc4268fd8990755a006dca9098c22cffd8753b7a696a459365b88e1209d7cc26264d2a3faf73d7b37c5318206d62b74f31ad1f3d871bb2ab195652e719fb1a6f914a27ec45fd5553cdc54ccba95c2c56113f03d6b943e45a1c3e5abb170ae3550d9316e363e0c65eb7724efcd7c35901a391413aaa6a9b34c37bf86d5e6807840b10cce3a22f58fac673a191ccd2645f2ede411e9a7ea4cfb47d4883fedd978a39189cdc324ce50caf20150aec275f9a839127e911b98a28828bf53076ee11113e43f5bdd4812c1715bedc829ddae8073fa37cde7d84ace05453ef614a6bda626996c6d005b5b51d7b369568723269bd8663d6757b529103d0bb393a0fad3d5ab614642b431aa84afe10a9a96da83bdf5a0e2ca42008ef8944af18b1916b69a2142b0f0f702e384eb50d64f27294d3b7eb7e7b2d3e0afe64d8901c185580114f31c3e8077372285c1454604906702a601e5b9081f13a6704c4c8e2f41af865038605b374b7629b885e7ea6cc19827a1608983fe513ab641cf4136c14bc3c3bed76cbdc0c2d4811b61281681eac13525a7ef01cec2668ee1d46264d48c0390821793392fe82df29d75a68eb0e61b627982526ee9ca785b38b478f626091d28d41dba51642b9d5991cc69473958a458b29b4821bc66bb1a0736481b18d6e4155c9a1213bde614c598a71084c3f3398aecd61f2f8a65bda9962bd80577d446cc3710ae2346ffd176c72b7e8141b26d2393bd495b4b426e7ee5948d9ca9ab7391d5ec8cbb03b8fc084f38aaff6f66e23cd4767a2a8c7776ac9dc6ad690c5ccc20c6181b28e1d3d4b4a679eef2ce87a267b82386b53532113fe2b13c7cc4d1e471b34b820d64095da03086d8f833f982cffb4c4e2b89ac67af988f46a3f4388a37a4003183650a4f43eeef9d27b604445ac0e0ef0dafb755d6a30c3f54bd489352784e15c555718a8ec3c53a9da533b4bf39ae35aff944c4445e40f965d53773581cef52b18f5b28faa3504bd7e68b20b1bdae413b173f6956b5fbe4972e424f0536de3b94826c7fa2467813803bbfefadb7cfacf76cf68c1fc09eb9e8f2d670d0ea28c5cb536ccd5f28668aac34cdcf4910cbfcae224d1bccae15959e0e715c992cbec2a237404bcffc0b0bbd62e4c16a1750d49591aa2ec1854b3935158291239963dade0fb9984a9bef9335255d78fdad1633a780dfffeed269ed354beb8a4e66c4cb5c94e3728f5b5b99c3c250fa50b721d41e44f0395ee7ccf91431c13cdce79a0bf3d9bb67b8c55f7871fedc5cb1b1f1409d220fec38f6225105effdb22644238160e02179874388eeb4465a7c610aa119163a076cc264afb749cebe6fc8fb7f186e7d48c4403094af6a2f4f0b4f51552c6363eb41c3e956abf379f5548cf29040d86f8cc4d61cdfe8676a82722a32a7cac689352ac4989647a31f35e53c5b71f510f9160806b3b7e25b100bbe1b217bd70e3e869d3ffc228b95801339e075ba74009d5f5dd659a86f32d7130dc71ce0e41197fe31c4d5efadb58d21636a158a3e9128084b08a6b23bd79f090b94eee15c7347542c55bf695cded5fc95e432e8bff8c3c92b3ef2074854201c4acec9b23dcf02e917050d9ab20e47549cc68ed72578ad27975a0e3a9fe6667e282e2937d7d212a338c307942e974ade4a93778959e7c2a762127d39e742ce4bcb2633df73319753f0c2b96f82eced3d26ef728f06238e49a193cc414ada1d20129903d15eac3e155c673d910d962e03ef2a190a30566745115fd61108257d095d2a2731811881a77d1e48d83d2570ddbfb91040b81a30781f626d7a9ae8eea4c04179026cd40c7a29794c7b7b4215fb6527028227024468219335bbefb14ff3f5a2b93e4f146a22f74417d481178736f975b6e35d7b3bd1faa212d8a7e07e49f6d1bec306a3876b73cb240108b5ac5ccd0d10e8c4e4ffde201a1f08411e00665799cd9d859cd78e2a483e26d50b714455b78871ce427b15213d148acdddee6240c33db829167d4730c79450250943ef2bdcfbfc1ce5bbf32a5089638de3130d0c056a380e07ed9ad393f93bedb0182b2d3ef76180e93911bd782497b587dd15957c97cb63a24547b94d58def4ce6a51b809edf0667e69a8f36e922e0f1ef890969374f8654fb31f4e6d193c38aa46aab662cde2ded4dd786ba01b40b358398849f3694c81843238a53103b6b66cd6de3a1e57b17028eed14cc93403642d1f1bdde4c7cb0bb7e6ffd3feba0fed6cb1aa805fcdae3a4d1af30084d46b7547be21bb0dd8baa28bbbbc72a57fe1609f04da921129611418679a0d703b861fff205aaebd80dd4d25e2b58c85b0d002b5f19ab3dac4c1b8b432283ced9695cd0cabbfe2fcfe5efe8436579aa740b72ee8047db31ffcb2eeb79f42d2ab55aa0e09bd59b7dbf147b4360b8aa2e8536076ef9a68ce42ae69cfef063133d889d85a8ece64f4de5a7533be2c3406d680f19e6e71f280bbc7da10a772c3360676cdc504b14fd19efba630b7898b08b12dc3fc365467c7ce6a17960b66353115e06c3e84d41e5f2a5e99bd2163b49a2f168df7431543cbd07c630bf6e2fabb2b7e597e7b3bed8caffd631d1aafc37144494b45927488f6fb05c2501a8aacae4a48b8be3e01bd2546e3608b356643bc7b5bb427320b2ec595ddf0ed3b1394ab6594446007f6870b180fa9c2309e816e03d8f2df2639e420fa58643ffeaa7f9d3b2db66a03586c4fa7697a4b024dc81b2398d5cc8aa2787d520371148a4fe96b8da191fa837ec137240579a5dfd93bbd25c05957e29c80cde19121aa95cd9e615444537a42905a5d1bcb79639edd752270f08b445e3d508ad53de105269464a8023106f6fe42e577e220ceca8f753d45205bb71f75cbfb222786bb0e0c58c679137b06fedd1890bb72ba9fbdddea331096e16aabdaa46b70b364f2e39f24352f10fa297227343ea35b7d906afd834728b40e73743464639d09b6b31fa4cb9307c217ee6a96ce989fd218c9547886dce91b70c474d4f30b479afd4807fff8fb9feb9c611c0babd70ee2bb62a1f389a21d39906e938c324347873be5f2debda614f51679ec908a17f266451e66bc58d880c6117f39c809fdc4ebef2301a1b3dbac08f0bb9b4984b0887a17bd3ef9952f58b87d8b661c747f0a4b2e22b5fc016ccc8ea03ccc07efef2c54efc545a29913c4d73ab3d67078e0897071a6bd5553803710148e43eeeba8e11a668e3670d06c6e8f667fff8d516e516ac3fda16b84408d290bf5a00f7dc5ec6382e3e2312669806d3d016f3756580fc66ac713cb17eb16c6f87ec1f390fca475b19e3136287a2f4a76c04913a4253a13ae519f907d8eda2395d55c6feff8df6ba3900aca97ee162671052af3ec57d95f4bc86c961085767533a8fdd84e39c7dc98fa9199b5c652c61ee7cb22fe252e3c74b5d9c03d3529eb2a706300f26bdc25468095d5abf82e9f494db43a331c03b7d37a067e210dc199a79851faa0947deaae9fd13b8e0389ebb9557e4db4205ca98e2cee1b647655b7d464fd66da690032a38d230e380e7f17bcf98913c80dd89fdb091b162c9d1729df79c9ccc661ab4445710f35742bcc9300cad631e6eb3a0b47ae653db9abeb7e44e50532549106f0251b17106e12e116e1f7aab92d682d4c6f293c11dc07e734fbb4de4e3aaf742c74ea404fc36bebb23e51ebf2ebc7c12d51a82e2535c82b4bd2293d726be778e9fe97c3e753329d020d533a9a6241323682a01d97fd155faa1831f89deda68db292c994b87433cd188e713a1003fb371b0d98b21aee8ed356830acbe57824bde3f2bf3b8f79cf2112087c0bda5bfad78934fd4b4f455aa9fdd2be574f753a6d3eb2c411adb958683ddce7fe2adfd9ccf36e2b2748e3319f4dab079deca597b271431ef52417295961a8a64684d6e0ec6226e88c9c47c3f3d569f6205bfdd1b300e5699b492b235a871f573aa7e0200eba2406a91d8921a5eb754cd1010a4da0b7756dd95cc9dc4aa779d1d82e59fe49730a2056721f129058615043d4a904e9d59a80734d1defc77c62847ac5f5735b8d011806071226392a6575f8832b1f2225cccacb6d6c691291cf0f89467d947d5a332ed89a2c17d3e9444017c789a2ed829fbee7071f04115254d017083919d22ab80bb4623c2c500400aa2e050481ff4b3cfd584a982784b9238cfbe2d2b3e3feed09e961cbeafc8888aab1dcf2331a283267c498c3c7abc11e2e6576a2411ce42a0b89aff6f384e29554895cf0f83c50a57df77b9e7140353b1cebbb7d289d984e985937236f3e28c13747f92ac670df53a7a0867406b039357ad44b596062a0d371ba6af8a6bae69b6b0fa0341095e85c86a672206f7ce2ce612c70f60634ce69ef2dae8a4eb5d85284feba8f39d50b69610522926fdf762c6f41c07103b3d373bf332c8a7b1d4fb7b3de4b0c613aca7f3a0ba0d08642b9f84369ff93e2174d0d156e5d3f4bc28ed1c3a88707244d9644c0ba8713343e8c531eca99e99c4859c7c900bdba5b0d1789391e7fb426159321fa0767076c92f4d65734e4027239717756cb504c612d79c5820f537299a487b43f6f24a839827dd5855d8ff05b52795fb06f554f863406568c26a075817eff9296f879576418c9b1ec125513e03f32bc22f3f81f4281671ed57b1299bc8115c98ccef5295466afa3ebac4b18bc56061d8c89a8d7e29e1e800ccdfdd92e562d23e7d2e7a5fce2908dcc6b4d0bd439b0978c0274bf6e9eef09462b818dfa6bfb01120072014e2cea1f7612a7bb904026d068d44b29bfe11489a5064eb2f6be852e35053ed33264e293bb1397584561b849d7b01000b7586dac27dfe3f4ad71dcad04e04ab242adda284850e107b7b0ee0fe38728643be87e94879c35844931461677fca46b07b3f69ff3e5a3e36c3c044774ff82b3ac2d68cfcf5257e2d524e73028cff8d4d8dc6516dc472751eb5009a6519177e5e074bf8dbb7c366a7c2c5ae5543d64cfaef1fda11a066f29bd24d03ca3957a16860469872bfb45f513b2c4d89fcfe23af2a82799d88e7c6b684d3247191eee9562aa27b6397300afbc0f843d3c375837710534fa74c363a2bac78309b6c760fef22e488c2a7efea1482054057eb57231a305a0613fefbaf7e5437651aa7f9d0ce5f5c6d502a310c65682cd8c42ed99793eaf7c7e2e69270835069863218a626598d566da5b96ca3e901fee2597a3228c8717a51f15f4a0d460ff8e52eef642e03f34a77e64763dd55c995db451ae263f4ad0ff48c8d75c2f08cb401b874319740936fea585de20b93112361cc34c09d08de69e709dfb44cc644e0b646eccce19ce761f9a8e58abaa60804878837ddb46516bfba5ae834303396056b21e1748e2ee8e0a91e4fbb479a954d504da006f74ac4861fe23c78111e0c5f199e588887984b2c7e3e0ca2647dff81c88bc0048bb0a269e3a45404250cef06f2a8d39524fa1d0f6d7a73cb0fe2dd15952c1471cbe3911998af76351afade8703586bc4a7dd6f9d373419cb94cf472f3673414e0cd4d0f1f1861ae64ff8a7f8d0445d332e7ab265cf2269e2496d6d66f567c8248a7a336cc30c3788c1ca4c95b08cf4380a158b39621c31c20d936e750315b8f0d7da1d3884860a6131335a9488d18423d809f5d72b46abffd8b331c9785c7e7e33670e8e1de0971ac838ba6dd87106ce40d400289c9c0b04c9471ca3c2ea0d7a307cc8c1a922bfab819d3d556c019a09e6411b3abc43ecb9cfb165a239f236dc5f2d90091198c4e68bd1f2d1d2a5d4da162d1beac5a4f47d21bb036626258b2ff464767f9113a85943c57dd145e1748263e9df52d5afb900817dedc77037a56fc76219bdba52b6cb99bd0608a7b22d19082a438575c208c9186d253e18db281f176c67923109161e4f74f75696cc203758318161f7592405d0089144e0672f52d75505bc131fbcf78df894bfb5f019fe968e9f19c75a591d6f92c2799ebb8946f288aefd0ca853463fcf0e0fc2474ae75893b8911c391d7b426bd4a212e3c4741c2dc35c0f44b9bbe0148621cb11eef12931d3836043bf719ea21753d1e377853c8aeeeee85ffe6ff478115a02e59fc6ed0cae9bd275f5deb18a03947890ea3d30460a3520f9f1b023ca8373089208fe1b6b02321d2ab921cd743acf9974fc9b87ff5c2e2","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
