<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"5c245b3efdf10216fde1a0b76aae3a29660668b7d8ec4de54602f71399fce6bf1ed2e444df1e08d60ae05669f1e175f4aff3c3c506c3eddd8cc0abc50ae2ac3832ed7e04b069af41c3d1ec6838bf823a4d996a98b03addb4475638245201ed409a33ef636e7e5ecc7ad98daa3c3b007d1787a3bd61ea9799dd81512b2aac60b9dc670a469e2de9a94a14c6f402e306315cc9c63147f8fe7b5628f331fa3ea543a3d6eb276378a0a5d17e45246c605893598761663ec0467fb24d124221b174bfdca0f9bfbf3b7100688a1d97807679e8d29fcdd69de31a061bc1ecd89b04e6ff91ffe92fc0615239e1e43ad296907f918656a2598ee40881b973d94092148c24f9b423b5aeeae0264bbd966339d494fe6788bb7c3ce83e98c0db5b8835f211b6c62ee7f70e82d896ffaa006f8f1730d4ef2c78f09d122f3750dceb228282c972bc7c31efc493f3d8eea7f9fe62e8a1ef4afe5f08f4e23deeffafb987d6076e051ed72c02c476aaf7bdf03a71139e0b1cb581285df1da2d8d7a3512272f3dc9bc07a52664ca183da93a8592a53a163d3c8e64a7cf75abdd9bd7d0728ef3cade207f819963d5c684fa9102725c2e39cc78aa143c6e5128d3c6b2d6b7a6e4aa3b17757d94cd45e09fcdbdf8fc0b0e0ffe51b836c6e40b0b767dfafa4da9cbffc15239a0622b46dc0705a6a0e1fbf2e737539ee5d9b7c57dc9bd6747c850b7e5ec522e30a528bea0f1709b6094c138416986f8690c6fec5e315a6895b920e2aeb00c8ca94a07300196bf5cfe635c2280dd9c9447ff8797b80ed19f3d50222dd02e654db7feddb66c13e6f14307c17a6dfed214218e4c8b9c18f3e1f9ee5119da5da7ae8e3d01ce12bcedbc766aaca34a4dc3b0d56c25dc300a67c19f99e0887e963e7304ca0f28b43f7876cbd7764d91237c48e64362f525bc5622b92d68c4cda3c38b96410c83e21c753c2296c172a2314da0d4f3d7ea34d18154087d2da92ffee2739c97f20ce7e95ef3700a69dedfd91c88eee86f80390cc2c30514148c281bd2c811ed949a4df269e0d66460ce90e77c0b706eec5b2214fa7e00eca8969e9363e86be94e62107625cd8ef84586dd900825460b667ae397d8afb4e65b6fe1fcc0df2b65721912941e62068cb615a18e542dd3157d80708d6b4d30e4a4d611c12ce90a62b602b684579023734a2b89d3a8ebac484675ad65b34a0e590f8dc0fa93fb9f324ed754eea900107c4ad7ff2c46235946980331510852b949f51bb5bbd4a671a66685605094ddac79ef7f74ee22d8545c927d0ae07e173ea9a448c3d65c61283470fe21e9d23c357ac058a3696e9658d76afe2bd307d08d5f561d593be13bbe7ad2f8d720d0f67c10ea65c86671ff1c1f490deb361f55805878dd765241225e850bb8ac5686b01cba9aa24a0261f4610cf81c52cbf833dc02b1e732c7e7bba2312a5a30c3b45ecf103f8a2d5ab68543bc19b43081966120eb7f2d6be69734c4800e233cda2df832077810a61a627adbe5e232699dd859583f191058b187e59e1da0c29f6a7f6feb9c3f9da62e7d271a4efb31d6b31235e8b9ff26456a845d1cb437b7f6bd57de7b545314710da21af74dffd3d442e266350eec7b95e9530c45985bfe19a711ada40bf34d7e24fe88785fcb963e780b1f3eddc3ecdf22df3f8138f2601b3652dd3fe1dc5270f505ab6c7f3da9d12c21dd4f27587f98b62b4d36e55486f2feba44538e2d138df30252fe26bbc8ecd9a7332bc447029061b536e57dfc958ae0aa6ed63ecf41ee1b0f6d9c20c3f0ed9926ef7db9c05ee9a7c070b0efe7881061af216bc4557bdcefe75569d5669a103b96fad57c995b833d435085f81418ce6a6e5364bd6bce9eefdffb2a80e1236194bbc43a2a91b5e5817ea8dbc8094d07a25072df3c28a62c5d8d300a98a3a72aa42caed833dc821617a43fc098a102096a544b9ddffb48105791e627e70c98e8a5f51a15bfd709d91d4129dc6f9ca2bbbaf6a0ffb37c395c2f4668a2be9e8fdd80df474cf167fb22793d7a1eab7c5c890407bbf3d621e86a557166c4dcff940ecfdb48b15c1bee931edca87de7b2839c59a8caaed923e036989b302f2b2a45d484be83c125ba743b4a81f97903f453b640087815e8920a2053af870765e50218789bad224fbee19edc3694c3b135fba4dd29d078094d7c7a5da00bf983d0e9695925e9bd002648d64650631cb9d6db111184d3892d1f1b8421f2f63b58dfec68f96e1755a33de2eb4cd570ce5698165cdc8d6892e3d10327ea200a77660700ed6eb196b2f2a2abba0f7008f9370ccb758dec80b16ef9e742c541eabe092bdbee65e838fe5026f905253fd1d6449fe855cf90cace5bc4294ac760cc4c9d1fe25b47702c45152520298e55255af4b90fd71d27b8267b9bd31c1dbaf81dfae52ab0f3f998557087f80206ce591028ceee048c479b5b2cd0f1973100f9d92bb3e695adb870bb6ea85954f080c41b0132704fc653d5c61cd7228cb994bf07ede010eee4af496f29523477d3dd43b788bbde1f682eeedc188bda48e6f4bb6b8b7a4f9d5d9e48a836f03934067ae89bb30412c2e7c1b0f873ee212ef3e6692b36e5265a6107c3a9fa3309c5fa05e02d82a14e3b6946c90a86541e9c6310b26d60a69a9cb4f455c83d77d0da0b3386cb06bf7adaa1b80216b19875adef902f2944f785900fe05357813fbb6b720a7080a5717011852e98daf73c5e246db8e5fc40a2afed3b69afb879dc7f46948fadb0f8dbdd64940da41fd92ba57936da1ffaf93c952eb3c9e9e057bd46517f6c61f070b92efabd36e796ec19122b7961cc1b498b7bfcdc166143e2aea228919e9242b3d1d7af3973e9223fbb3cc902d52a42a5e89cca19a003b4e19a9169fee058ef0674e53222ad7f46b21b93d2daa480cbd577b118bdf4b1f14c608dcca98415f6f383da8869533d5b4e0686308ee4ccd6a0de07ea64ae5d4c2d74af7b412734f6bb3581e338216694b494f31ec44097c1403c8d95c09f35caa8e5a5f4f399a3584132a10cad94991a6e24ff6adbbca667ba5f86e4cb8a61f00db6ebe7a715c5130e1857a19b046fc3c47d778ccd9d043c6956d8c70c143661909248836dcabff79adcc808828272b320edd22fd6fbd2427752d35d6b2204db161260810a470f41db04fc490a60a2b3bd2e57421b74f516e46566b7e3d334e088ebc94d047d6b32589a86c9bbc85d2a394f6c68a9d2d6d7f92369133d4a008c55cefbba32a00d2f93c76d7ca030017af3d8033310d5427e4961fc5b41a2ce0bb8a4d7be769128a16a3a384cc2a3b9e33fc24746fe7af28b16323e79cad2b37b3467f6de4dfd614c584be1ebc793865e567e79000f419cf2f817f27e28ef6890c298465d7d746bfc34d9740fd2faff0cd3276a2b9decfc2ec20a43a782172b5fe11fabfcf9bbefa79a6251a60f0209e4500c42cf3f6bc5d2c32401ca2f3fc87fe66d132b01e86ee12dfc518afbf2cb30af393b06d53eb95094b571613f3de38f9313693da1a6bf5626784a544eac4f99d93e4799bb03a750bd4f3ba212f22f2a07d0b41b1a3a02cdb2f9dd38f920faa1c8e6d21de457c94116736858349e451289a2b77c267d9ef052a51fb03858f9c3126f46ef7d2ec7d5c234fb5449c3cce53923e9e4ad889485dd60ca04da6bf670e9f2ac7ae8d8652bb8231e1ef85c08fb6ec76dfeef542bd73e354ba097f96cdbb4055df45a0fa48f06bb1909b6c66e5dfad4777bc78a6a9a02c9af512681e8b34a8ca10dfb7e28b9f2aea5fffce462b74f2991f8752fbe5395458f970a71ad977e309c7d51f8c3aab2d7774f3fa50e37e1f0902bded39ac6622a791118d5d56eecd119290f1ba0985eebed93bda3bd4a106f6fa75cbfb66a1a6d7f55f51145dfa83c97fe1d0e634cbb53928ba34e3eb8fb9f18fec9c98ecd5e1863649efdae06421247de75a3301831d10dc1a882f0264474c69caa88b4cbaf2aa5edf02f7f0131d8489b08d1246729245cb3b1d95e045945cb873a2ea10f21a267a7784578fe7e866ac1bb6ce34530340f5f9bba957d4120ac6dd9f319b710c5f78d0cad4c58dd0878182133c0ff7ec800e3493c2f9af9ccc11ba03a0d5090e6c483b86096a0c6340ec047369d37d81e7164e5e3a1ebca7e985354ba573902a2da6df272233defc648db632824d28c5dab04ca72cebf3731416a2783081b48bd7a0f8c1810b1896176fab72e9ebcf44430597735aeee7cb025beb571fe57e840f05e1c12aa5f3c181005deabfcde432e979d8aeb3891ee7122d1abdc543f478fa810633b3e2be612cbf69fd0b8d0a1d6d2c3efe3e3f8f18a497cbb1777a5fa2c9558d88ab26df729f775cf3bfa4b961c4df8cf110a833e2c09a4898d085da96baae2cd76a09e1df578c03479779bf68efdae81a467ce903179bb3cbecd4f1bbdbaef509db14011eb4c6696a1b94070994894c537c6023ea0187c28779c2af2f74c5dd7601372a2a394189dc553f8dd9097d738880bdf1d7e1ebe44c6d78a809085daf3a519625ee854711e27c720917312f76589b1408f22d6e92562879e52dda5a7b66a933f024b7f03eab55ce2a419e2614e794c06e770093c3f39aa71f8a87e9e038f7c542836ebe7237a3604ee55f7b4045c97a18499e32e22b3f28651dc52cb72e363ffe49ad46d0a265058d77427e6ab08f6c4f2b73f9941f746fab3be9d4826d5accd9b5e908d94b76e91ee3b8f1d66bc2fc217bcdd0d325a91054013498f14c786619a1ee009f067699607b287958683214979b7458374919ed6c0491b85663ce325a470f3b13b81a918d17cfd6aa24122dc1a9a598b69da9f7d408d65eb62b987dfa217349a8e4fd5a642626369a0d22ba02b74d77b08bb2835e783ea5ac551a9f2fe091bd8caf6c708b2cee18cdcde612b280182d78c1ff45f17dbe5b7cc7b55aa9efc2521bcf2aac867d445ce9157cb5b1511458ec3dfa6a6b24e4bccedc0dc4e98a29e699b04673f902bc657ecc414db54d1af3a44d8468fda2756653d97e1fd58bc908b25818a86689c88cdf850c35799fb2120112ed7eb10e45c1d494c1f8e547c83e1b9bafdb2ec75f6a7fafe956af2e1b7fef6b4600103c70bfa35c449a5393ef1b44f744f3f5e540e3212d260c979ba75784541fe6a3b3a175a566128594b3f168a914b44bbae76edb803e24a2b7ee5b799e9f1763f3984bedd7ea0e5a653cb430cfc33d67b57f59ddeada45fea00c29da08952702b11a684a0590a607da84d257782ce8bcae5238af5a92a358c9ba6b4912399db76ecc5165a341119a1463bc7f56edb9549708f8be68d04c7bf2e133f3710d8f03ab7797f2835f16d7fd215056b3c0f24039ab6fff858633cc47942ad30af19b7e55436ec0a6d9c077c2488a4168287eb02db51c4221c913645beba4f2730c0abb4d9c97e2cc2d2ba4e3fccf3f15b815cd385337c4dfd35c04faa0a6cfef01b5391fc520d6fadcfaedd6ea5ba4b08b9d8ac1557879399a2090c09e0e676f219dc4b247bc24501f4d8564168abab9a5fe4979e8488f50c92ecd566bae7c8a9ff93a5d252f539d7f161df7f5499a6ee345370c6436d91b42a1520fc79d73ba3beddd412c8a07b10fccffb0846deb18d15faa2c86faeea03661aafd2bdab8eeff614219e7dfea4b417d9be5df0731bfb67f78706d180a3d206037287c30b28cc64ced996f87e82c51e8045a3ba34563f460e0b254a70dc0bad3be850c9e21b39bfd12e250aa070e2076f0b1da4dee0d0db0bebf0d464b48202549e4c05c6cfea90ca5937888aa44a04cfa72f1de414c7829325393e697a788f588b188fd7ef9abb97351b2fcd7e9a69854e0e9fc8931300b5938c083c8c9686084594b1fd7f9527b9e1c6685001e56595dc9386d5475d3e60e88ecb19625318d4bd356fef9c84732c9d28db9d74dd0a1d60dab57db790331bc664e3de3c71a70171fecb661bd3fc2bfd3eacf9f39a8a1a6ed14717b497748103d599b307016d57a7fd680f0bb1ec49bda95cfb68af15efa45d75552a45f63e5f66c67628c6ccfba5848439a67358c0f2ac9b4566c85c4cc721232e9dd91991c4746232d6cb83cec731a5d5ab936373c3d359e1f997a48144f52528901e9a668f922cb9e62fed220ff77bfb9ca308d8a5235092fa722862c612598eaaac5e1ed3cc7cce46779728e9f19fecb7f1cefc7459b748aea7a8e7355d39d48f486cdb55232024bd12feb96d8e8f998354553e081726e60ad7db1375101db5923119b4632c88c4f9dbaefde1b9c2e905a52f7e49873838ebb2049d4305eea090d100282da4543a3a0ec7330a8e3d34ff252e65e53e718cd3f919804f970e180bf1d918e47ab70f81cf70abd97c72a511c4c2f44417e47b503c7ddf47d7d1695f1a192acc8f7839514defcf303ca98f5974e1e2c7099799c43429557b6475c6f717fc4ca24b50f94f31e2d10fc846d4ee118e6bbc7b151857a466b22c0474821eb9651c84d34b334e70aa7552a8d495f2b9f4f111f034882c69dcf0e88cc1e46c859c643c65cd534d8a9a8bd8ad1a08ab9f4fd4965b20531847e49704bc61074889d448266f1f8d1e8902450a7dc9a5c5f944aca78ecd6e13a50c1cb7a7db176c24070311cc7b1c05ac95073763d3651c3145b90b5bb3f78eadae8712e72423c1116bb655593f2d0eed082c942cceda9b65da7b896031e4453abe160adb043a9c5104c1ce96784a5bbae4e6507dec592fd060a880cf6405e69980335933cadf12ef5bc8a4cdcbe7245048201d227058224b85f12c6644719d433742001d7116c4e8d6b61d6ba44c99731fed4c413f6900813dca7dcf3e33f73a5c108075936883871912ec9b1dd4938a34a716e0c90c75e94b1a61a7ebcff4c66e9a80db60cf5731a0932f92892b42b4538b2a7986e8e5ae3b82dc5e6bd1466b10501ffb02fbbc224bdccc5044ee9d011bcb349db6de99cd5fb7f67381fd9748b15c0432aaa7ec5b437906957dc1bd2fec944f7054ca618ff727aef7f0f2a89cc16e23f88a6fcf4c46c10d7261121eab6778311e064a014a9db33c7a88b3e50047166a9dac18c4c4c7a9c7bf0f19caa0fdff54c0b3cb90dd3e0ffe7f855d1f0a681cb48cc27ed1169a26427dfbb080d9d4b85d7462d28f84701c76bffc530fd78db779a274dd8ce55d2831ace7306089c05fcd660f79023e959ef7918d9886254aadb913a9779a4f319a6e0b852bd630e876f7bf4a363dfc748e11724817b4fa737f43dd064c07838a5cb8afefee651966f18e291bc6d675020fdcf1156f36e6e73782b11c34304a804a5fb213e5ac59e6d300bdf281fc315940e9141369b6da29a2327b33d7ce2c93617d4159bfe940d3fa35fcab8ea2333eea2bc8f8615dffc47051577408e791b13638acd94ec67ba3f5bb8eb3bc1eecb15894e91cba8db5f18497bbde12e512b985250f1dec40ab773402614f258ac07413a812d874b29c34ce013e4d75a985ec904109fcf126eec00c3fad572a1fa80e917b3642c2aa2d3dc9d4377db15aaeceb6a3d6555cc149859a2a2f15ab48086b5b4c3784f0d5917ee50fe48360ca3c3d7fbd7e4642c2051c52c11f71ac3179dd741ff83c137145abf960331c78290fc6aef9a7f261a7b672658791d5f2c32f170cf445088d0d1deb9fba4c7df3ff377c55443a837dff76de34bf5a35cdfe9aefe0ae39739fb440d6f8c695e80f433f55c1f5fbee0755915c7eb013402d4e02cb13c65dda60b0185818c02c90abfd3c697c283557ed022dd41cb26b9e6dc602defeda7877d95278966e4e35088983fcae6c6a0a706f1fac28030b9bf5ec0bc61b12470dd376274c990b9bd6753751b890e9760241589b4c1769b297999931c7451272192e21d2b0ab5505872a5ad129c21df9cfb2121f8efcc05a06fdbfed8bd12921dba87c08e871cab3b609d2e11cd11fcaed6ba6a0851ee15607fd2df6c9de029547e3c60e400a5c1a1f1c270f2dc6205e8be1a02fb6e290270d82f84f933d501a23d290a70a3ec6aaa4e304b32b3ddeaa4eb5c515e26ea9ed2c88cfea3b8531c0b8f8d91ed434e2a10db24d2b535c7464bf41677222661cdfe086224bf978cc8a982de380479cc7b7bb2fbd83d28169d8dec74cf48bbf1912b34ae8fe1bca7f14f5cf93e0d51ee51979207531ab9a8440dd8eb753882b35f310437241724d2f8cbecde808b8649fd639778964a9adf988b2f150b13b74db02fc2b0ddcedf671bc67833c23d96a02ff65de7689ad304152bcc66f09b1468eccb4160f1c857c388d7309c65fa6dc8c1fb3205df4632af085725aac2ccba2585f8471c5e602dd3c29acc8bbb6e88db02b4b2bda738ed33fc72234f6e891ec25fb7ae7447aae9b12761c26313998fff85ac6397d94646adadba66fe85437a2f5189f0ab012c4351ef41de63efdb260878a0acfcdd245272764a8933d079b987e0cec6682c5c01ebeabd68a79a3023eb0412e461d36e78d9ba3e72a68216618e9ee0a4ba05565dbdda53c14cfb5fb03d493618610ee23c5ac157d0c4f619ebfc0f841579446e46caf3cb0e1d848d267bb78834299700b07789c8ae232a3c0a2564162d319f557fb5c0c2ede8bccdfdc20b1086732716ec6ff2963155d11ac93573f87f4147b09f9ea79b8dd367439c1f754001c2b8bed40d887017686c11414bb3d13531ac917b352e7191f1abd3439eacbed68ccca79761511a5e8b253bf8b3f2bd1f1710bf5df13554d287bd4d7f93f6350dbe83e18c1f0d176ef0cb371d3900442d2846b465f0a2ed1d37ae8999cc555f605e223603b977669c2d7600f5c9dc99fbad0785d9e9223010f43ec9a76d226c751719a09a20ba0a373ba37d1ddc29e91b80deb75717349ad1f1f48e78c32e7f6c143ef98069617bd0cca2b2d2ffa68ae0be9c99e08999a0eb6a61654b1a003c74f104b816f4ff9e3251a0cbed6a15b7c6f314e8cbd9662b0fdbca79346fdb6cf37d580c8ad56ce38c2d723fc025cc2fcb94cc852eb1ac38c58f802a565ee356b42a8ed067ab93fbe54539a369bcdcb8cac8f019196794ac976c113497652716ec6058e53e36c9bcea0161b7acf55835e968fc97c73f498712a24f5771f6ea9a1d6615e01503dfb4425cb8698a8ab9428d43db5cf3a696400b00f4c25b286527a9849441fdc5e3730d520b115340d54a702a28705c5b54e87a12941e39b66d9620b63b0eb4d89c8a88d8a7f32a537d2deccb0f9ed2f3e39c804ccdb20faea0051a5d82f29482500532b2b388a430ab95d6657f3b9041f6aa84d4c8085c13e11326ae7ddcb354af29833f279952854e14e98d0aa1d16e0cdd491f8843794af31a89fe66d552f3718bdf19ab1db592189fecbcc36f069403548eaaa75085fbc84a55c40e588987b39b3d6b4aacc931cf7a373113905a574979d614d31cacc90a1356829986ed2013ca420d0d97db3e88d2e56249ac552b6ed1c409b5a766a7fd63aa5d1d4518c209d9ad7bb9a2b2255af38f73ffac44671ceecff8fc0932ef35ff5ef06dd0e740b8d93284924c3b5cd2a2f8b60d7134f61e2124f00c1b63db2159ba3fbf3e3edbf5f1a0ffd43a83689eaa5d2d33410a2b1e27fda71a7a08fb0205db66111dc8e4f15650c531b5ff0f25cbbf1f761650304a9eea8146ac6256a4e3fe8baa71b41f6c9d36f808b19f112b0958af92a81e2167718684ea310ccb6f021a5a6836fb1696771f636554555c76e58b8ea8754b22ebc21f99da657a570cf665267f1d7820c64b99c1faad8f67ca364c5c98739bf14715fffd27c491885e8de2163b23eaa4bbf88d8559889ac1e57767eea60df38ed653823d3f3fe8a36f07242470fff643b586c66a471333eb7b1fc5eecc769f7638efeaca5e3b7f16f971661892c8b5061e5719f83f1569210c6d8cb66fe8811a8e00ceb50292c30cf64a8426b1c12bcccdd58c8dfff04f40405fc2358fda7c9a1c8b744aec03d6276cdd572ccd0cea90bce0a7953baa7e20f21590bfd354659a8adee143fecce58040ccd645de359838ffe6d28755c8e762657714c597b9b8c252776c939612a0355bca0d3e1b879d63d692c756581de189732305582406f54114d71f4a41c47e72d417e7dd0ea2b5a5325fd946475152962574a6121fba48c946f959041f9195cf632af9dbd7456887e489aab71f8441cba2a4f57deb995501c62ff74e8b85835cf6bbfc17ead71c6c543b5b981f6380a0174a76fd19d6d93b4251e05ce699247b8441ec6e075da5166c92c2cbd66e620c942ebb348354a4ad7b168e3507739c5b7ce69e8bfccbb144510a5c301a94f125887a093ea5f056feb0ff175bf8128b812864bd88df9e967d3172e2ba0d2a9a1fd058345566aab23ec24b19c678af03b85f7f794af2d97ec1d5afbf53ee49ebd056776ca63a2f915f0a0e38522faf6a269c094dde55848de98d52c8d864f7a2a6c48fed66a6338924d6cdf51a4341a7dd5248cbe6965df373d98c0ba6a76ef4601243be5cb86484bfa70ebbfea315961688485c9a11896cd87d913ac65f07a42924bfe7a638d0e6c5f8aca5c3fab3046ef9f91962aa0c7508fcd61136b7f189881533791173562c3d8962d1e0e9b085f5f4b35967aca11f8575ebdad23a709208e8a8a7571a376434d02c5226bc7bd1825e6eadcff9922edc2e3610a55b6cce02e9277ca471264e8a4d42d3c1a2ebe5c32a6f91b87a3ebd29ed9af6c816d3d740daef55ea842c49989964a84756a9528ca64e443c460a8716b8f3836a16a92ae31974abced8bdb7b2b9e8cc22deac9f441de6ebfb9ff103d5db7c1a7968bea2aa3ea3fda225231ee6a5224af204161f9b1304af10d20e52909bdaadd1bee05f6b6ec55a6bdc41362dacb93bb008e7db8f52275febcc90ac6661fd061136d07feb5e44dd185a90e2e2ce9d51f9bb1208d32884db58ea22ecd6bbc33b5e5219239b15ac9520d590b3f5fe81942dd3e54426cf9caf97a84aba8573f72b9973706c6a14dd6aa00f649540d7076942e7e66f012c10aae46429292891e2b47cc1ec809687390f45c5281075b8ce96f9af44101550f1b6a60e91df0b4ae4aa60994e2f83f86a5dc8dd4b532a3a09fdcf7817b6b17b1012eeb8e3037a6b108ef7ea9d968f763e35a30a336e23ac098d8053aff422b4b7feba97fa0f2deb3320e77f48ca182c8edb9818948d38012888450c54d9cf8de1e9d318114be13d98c457db1da485a0138ec3fa4ec0895d944c711f979e8db06f9cce4f36b2938441c58e29a0a800ad381f41bc4753cc10593b1bf00c7fb8ec92d6e396a480410d7886b0391e7c85b096ea9428f2de9cc21efa3e1f4c709faf5b2219df84178e622bb63f9c0487a79ed8df5170a31932601364d0c9c8a62fd4d4ecf927f6d91f23021f463926a61e05a0bb148f2c597fb6ccbada635504e1c082118aaf23fef4f5e3fa5d2979a6edf1fe97401a60644e07c4e2f59d7136b90ee20f3e38ce70257da40c5978ba5a0bbb9b2779787cbbf149906eb69cebf05c1422aacdfcca417c34f511f6a8c6f49383082321f72afdb1f25d20709c9d7e40adba502d8b50e073f221986775107fe6ffeb83fec19db75a687b0d4bee3b6b11d88418339afe03ae0806f4cf0b52012a8a07b8af7a889204d928d743b9686c15fe95c2dc74dc3c472c0f3e462533b1f1b0173e308a71c7e4bf2d80bb88f78f23420e952be1a9656f749109d2fb53604e91f678025185115a19d8e1d5076c770775c852e466849836e755f3be73a428520523ce1f237798d32ecd044915d9e7e6ba67f448781af2a71211fe317edd171f824c4f86348066bcd404b78820e53233824c0476af0b97e416dd0d344ef465cc05aaf5d46b268ab0613ced8b81a2ebcad1d45012c403f7dc3a8b38b2569b14c9268344d41be1e68d1b4a7592f0ddec0e5a595e78952516bccef8646c75bd4fc775c0f0a77ca36dabe9a24380c311a6fdc6eee8f462b9a13d13a9f705b2216e4a2bc9c0cef7a6b3368ffec2e720e1a694f4351b7b61684d4a71fdec36dc8e0cc8f7ba5e4b00c9e717c850c2899961cde87b5509bb8f6f09d476f0c7961a2454c823973fa65c06c64c62e2305faadc175dd8327a4b2d1838e82b7009dca637a0b2005e6e96ba93604a22dc1f241a5343d714f24737c5f3b42dd08ab89de892a05b1a4e5d00970081c0f7e257c9e9832e942ff5da2873a400f243d5f387fbdc04ccf917767fafc1e5a066c54567126cbf28a0a712c991dbacc68474699f70d92cf8ca8248990122e2308fedf23442aa1fea064184d820b2d41e53450eb2a406fcddcafef7ac8d36ed3578c3fb0f9e23bc2adc9bd04f8b3be9acd5c42c496ef53322d10a4fddb791f5484bfcff79c672f109d8e1ac703cc3468b0281746e7d816f50292a16a24534a0c13602eb9f1c94b822e7acc50c3cc077c23ec708bb30eef87a5ab842d8d95cea3b323a814cdc555164c72d903543b38f3ee192f0fd1c33d575f176d72bd07c96fb95af5c7e378106ef3bf1408a5d5f6c3c986c033c2ddb26d6c0c2eb6243a92c8445055fae6607570172ae68e40321db3c01ff8b49fc447eebc26056c4a724456e1a5c9a4cb30a54a6be00f1ef21773ea0e1123d965066986bc8bf25e589f92f2c19243f15fcd3e1c494c7182577c4b08b6745c3ccf5ad5ca45e4caf574a87dc4f64fd9c26111f7e0341b9949d1336a03af178a45265eb25acf2b0886908d1fa02a6b0fe0fcff5874c6b167faddea08453428e1cab5f1fd90af960c44f10d499d3d7b2174a14594f79f11a161b32dcf497196029acfcd0acd4c2c13e22705e02ed0502cd08eab473e053e755c0778fa79a5435dab75c8b9d97c7a822f361595071a4d149d720a1d2db543516ea6419dc62affe95c1f2b2f4a0cc9672425a15c2477bf835461ddd364dce470994e24acc1ac80c36259a121775b8ad8897e3ef9a3da28858c4f75feaca3724fafa2ede64e5fb8fe15362274af995a7240ec28dc7ecf1ecd0d6f715bb09a41f3e4ab10f8463960c6d9693305efefe8ee26aec96aeab748e727ea0feaeb67752e443a3fc7f2a6db3131372913ef463309b19fa9c5fe4543cbe2427d999fd2459a0359bde7ba3bce8006a473a7fb4cb724091e4d432b3ba8315dd53005280a446fc8dccf80d43d9c5c8e59412b698cb3819ff5cb71ba64182975d547825e43288e49c7b96dd0058a2e80d82cd3ff98353abb938dd0ec0526648172630655c96c93e448f6c6d2a830a4aecc5055a2d35143bc9f6ba85d1b6c17e55ca6e757697428fa6af401918e2c98182bba570ad6f98a2a1129a94dbf6e41a7d34bd048ed352fd1691541e9b86ca22d06ee9d48557ed78974d7153abbd398286c748044a21773139ffcd4403e18dc0d94929645726b6ccb55792e31664ac61e09e8b500254b0df08332d8591cd65e6cb540906af6332f52a9098e26959438a30d7581b262ca037d6f5aa01271b4f9898eb06a5b281e14fe6861a8b45674af33ba7db85f49932bec615bf073285b87e30f682525a7a1eb5e3c32bd716a835c2e46ddc9b2747fa78843aa0d6476e28c70cbded615ef8796e39a2f26df75acf2755afb82a82a540b5445e21ffad4b4198e8b56f9e55729f7a2938d92b8919c19602db6906a4ef80ca355184713c062da57736b457499cad211186d6dfa3684835e80849633b1ee559cf2b700463d171629794435be01d85fcfe0447d3a1a076249745c882b1529e01b7e3a4aaba7c1e8ce00c219f4487cc62be7e0c1aafa1d823b3302478894dfccf882c3f095a5333b9ce84f28651f1eb3d5cf62af8453f3718e658ce988bc3fe312e609b7f8b5b9a3e6c10562ab030fe49ea5359db4edd2cbfc57d488b6e2e2b2d4287807f94cf6e4a4a75bbe08e7e7f27dff55b67d3aaf3a44924b64c87b9dad17ec32617e1183dcbe70d3a8705dbf71bfad8cee5c8d3f1ea33f0d95cff93e368f43dd1a26db170f9d32b05705cbbbf1743d58dc05276ff34ecf47b73c37593baa3a9c7b75aebd1a8c0834c833746f11aeb149c64ac44cf75a6c334fc1d8fe04435489d90cc0ac3408c1eb40a4702cc2a1f170364a286f7e30682acc0b81c7f071ef1b634f2b1a5c83c0e5c6e28a423b50cf7a7cf053ad414998f897ed4d02a5c071a693303006760b02826f7669ef910dc43a3a07bd6ddf7fc10724eb0d74eb93dd86aa214f39c1d31ef1219819204d0a30461014df3c578c825f6883e7c1be8321dede339a9a56760f076ba2783de4f86d275cf322b92546cca84d492a09124f528fa1f4997c44933afa2ae899f32c9045ed747647ca3921ef323e57086bbf01549ef5d1c7f718910bcf5b9ae40d7b6712a0d240ab414f8416d4971afb033a5af8e9759bbaf07f9da2f3d937371bdd7ed1ae8ca5c7476255ccbd1c3736d8589a616e4653e99b95d832bdc2efa392d4385e5712f1e3714422c39564b562c15a15ff3f7d90d9e528820088c8d607cba6582a8cfeffe6dc57ff38849145c0d1962b70bd83e797727aacd2cfea9d25a4f9e5dd19bcdb460986599f81bea325c77a168396ba72ba6e37b547d04fd381bdf908b4bad1774f4a38e93979b31b5c58592690fc647820cea2271717603a511dcb9ffaef591625a6b12ca6c0cb5837af254a8102472a65498d11b037ad09b47d9e0d50f7855347a85f9433d0b79e4f50271e485064c72bcf2b2404651f46c2009ce2c7f5b859336fbe6dce98a05b85402856c4031c02c019edaf50d26219dcd4e4c8630c05b13f3199aec238de545358ee585f6ac8666feaabdef7c9594a6a4c62fe764645db7399ba25260df84cf4bcb963a0ed3f0ac3202a420c2a4c27b5b71bd04fc27bd3ec09dc979caae4c7d662c1b9cf8e9f8855afc899c3baf8edb880624d8a6469bccc9495967067787853801f99fd3215eb05fbae6f5973ba460eabef02baf106d0e54c650c4759c61f040f8f6212c118d9eed3298f45e07426a8e44c9c81dbad0df2d57a4ebbffa932ec35e011abcc20c31f55dbea544295f41986c14c13974d559ecf8ff9fba0ebcf71c96245751173297b3bf10f8c4ed155a5b49e6e68834fd56f013366701375456f58355d63b02e561aee82338ab1213033f39021f96ae8487d84cb8be9919b4be0b537fa443b666736de04b6fca2c7dddf1cd66b4a6db5b6555e3642b445f61175b6213ac8629efd3efd59fd6994a3f0afb596e9240766a302672f7e105a11d66cc0a31c3a83e896c34a0e6f16087b7dc129c2315feb574e2d9144640d61a4a7598e8978f8a9270e5165b6350aba215ce6ffc2c25ab8c98b409be8d272728d4b22e7e3e71fc4e0243ffb427831a3ac2bd88d9f648f989fb7da38cd29998654176553c4eea1c6e8205f86b745e4ce742680adcc50a34064a7e5c6240f025641699b948b1090110c34df1172aef7533c62e1c8e7324d40b699e14d43658f74c8bd7ac78d92ac4a15f968f3cd28e73ac2f545cfe2b247a18a5816c0e02c1569a01d2097921ee26f713450025212aa1362689f7245b5dbd8a0da67791938c3448455f172fb26d293316bbee5d3a6443635182e439284fea98b59647aa803bf891a4c01dee8b3857d14ddd2269a4570edf91d5579a4acd39eec674348976c1dcb3c9cab2d837bcbc5cf3f6d6e5daec44db96f2d688c9f93cebe216643f571803fa94dc9c41d006059fbb2fd427a22a7d66ebc9830252db294991de83f44b1fb4caaff666410d4677151ee1b559d69231c70f03dfc20eba4bbbfbd61e52cdbf75fd6ccbfbe81e51b6a92b7d62034d0c687309817c1dc4475a197629841d208c48c33b28fa3054ea19be2e935d41ae7c9611effe3470610e15c181d8a47ee412fd4d365f5d5fdd3199803032b29105ea66f0507b5b4cc3728cfec0ce9d2e15f04d8135ff805b20cc73b3d12902b75eb6e42ff4b2ae8370f093530bdb3d1c638aa108194bf679fc393e9949cc66346319765d712aa6d62809dbbff6d5ace821ddf8fb74fc19cbe0203c7d9983fd57f3b7f9fda982010434e95d0c5785e2b807a861afacec5fadfec18127d8a5f81ee00ba4812056eff13e6e848f9783730964c9f7ee899bb0b18d714a1dc56cc4a3d5086f73541cb9f0ac093313947b8e2c952b81afd3fe16a3d0bbd275c641f16f518d506598f5d8ee09e868e2cd8fdde9a621682b793b51fdc1f39c93cf2413e00f7a0cd83b4dc10362f070e01a86c220ff01249916683c7e5059b6035529b66d4f61ca326714086e0cf657aebec9678e33b66e8bd9b99e8472835b3914a8fb741d0c02d9853fabd5e2d87e5e8741eec43515ab6ce879d82b6b8c87329492d867601d842ec69c636d60587cf6f798b503b6cf324dbb393fab7e80a7d25dc4048dc4c9d99634250e8559d90c723fb3c999fc72bf7d081e714dac9925a0bf82c9a912d4e3cc7e9719fce5ac40f624366f2d87dd9e848c0aaf17a2fa49d6e04f9d700384d6f0c354de97109f39a9dfeb55c79732e0ee20831738f6989f2cdda3fc1426e32f750df8330d0f4b561f9f6fab518960e2a60d834bd848dd32cfab72e11024e83625fddea4376b7fac1491844dadfee32820d2a82983f8e0749588eba79c693559429b84601989539c8594dd42924708aa508d19be95b947c089e76c46267ee7563a6cd628cf168c470721b4ace64aeec7d9cc1dd16f34557c47f5aeb9ac336eaf429ac957218ddb6b87dbe0b0844d5ba6909ac4cd63fef0766e3de6f7fc557d825a7909f272a8acd057953e9b900aa49f9d0b3c2a6d86ee2cf21694a9ab40216da02a3b306168cb4df450556c44fd1ed73b4c6d00287879b141b92825ecd5a2282f17cb678c9f173e5c8156d035523195e57f36ccfbfbab1adbd7633f29182512dfe379e511547fe433008691fd8678c9dea3db5f739eb62e7457587a4f5534cc63c92dba5a01539994aef9ae2e018138cdaa829c557ed4ba83eab4200f9828fe3dc302c08b05d82f09789cd0b55baae383f8f9f111eae43ecb265b53ca93b418e97b235371d5e3758ad93cf15706cf67d9edf8f112e79211a581fa9dc846a65c376f19b6799d9369bf56aebacefccf58239f53e34fadca605e480e33e761ace842da3c6e3ee54cd43e3ead5ecc7d10fead621a721faafac7ae342183bfda187d670b24540ce396c2aba4778740a554170ea7a12723ba0671e4a2588b138b34b6350b28607f1c9b56a6f2a5f3de98350f6c7aeed66c2822946b0462bba2d1ca865efc906bd69187e4bd5295a4e43457c5d8e0bce24fe00bc8027226bc3e4aafb6188bb5e934b731e4ae9ab70d7505ff00e5d75183a2b1102c73ef49ed4d7d18ff6d9ef19f0aa37e8f024401b30ffcc27111dd74d0e703911f205442e0c01d79469664b1db0568f6c55c58cf729d7065fad2ed8d2ec9dd4d191edc0d97d732c15298e44aecf8d11ccaedcbb58dd9a444bba1359b289fd61d26741d7a24001df2a708e1b55e89af8ca50c649c5700d349fb476fa105d219719a458c83682240cd8e473ba41eb07a961d5d3adf3d556d93bbf8239654bad9be6d4b5ca8a86a752efcbaa1cc905e7325e23459ca9627ac82c3a2062bc27e0b34bf8148d491356acaafa9b7228fb4e21ac39a41b972f8b3f226c6da0a6d656dacbf3e770a942495d041e05e7d72f3bc06a5ba75d8f0f5d4bf294fe86450e057f5ce0150eea1579f8fc86d9f715c1f36e3eeb9f41e9d6116d15efa2755b9683b508bc8eb32302fb9bf26d099d8e17f061dfbbad34eefe243417090620302c95252c95452749f1ea2e081db25e9713411d71d8c1845e6cdb615e1f5199838e119d7570ca46578169b5d2225d10dae9afbd2abdc4d0ab38898d375bc8ac14205067896051fc92f455ed06b0723dc162d752c737cc7a1b1f478fcecf93dfd82d44fb6ef8d38c3f899c7cbccc32bafe8efac3c4768d10e9b022affd1e6f2c463c84f137302cabb1794e122c378f6b971d18c9d855ba019e0d38e09d77ab31c40fef059bb6ea762f38f9b9bccdbe6779ed6baa7850470279a736f6ff307e06e13cafa5bf0696a4fcb7fcbff00365a42cd8b71d377c0f181581511a2d91e8a4392016340bb022ba09a0491d82836536d54cf3397e8617af7e730ef34c82955a21f02d8f42ca8a611ae62d3cd140c4d1d7897ff3dc2637d325b08d4960822ff9dbe744f8af6143c3bba032240263e15a0a895df550be1ed8595528f98766ee2b0ee5fd6a1fd0e5c3fb65dae6066e3876d027ccccad0e9bc63319b8a6d33e5ca5e0c88f16457c83fceb61a02f7264b0eb671c2d0edfc3566c0a1b2db5c93a59855ec203bb13a14654a1ebaf0113ebca617f2101441cdd6a031208614780d0917611d94637304bcffb2df4260fd05b4ce74c5ff976134d8f6825e5930b7735d0e0146722a88c37bd8f8bc23f0193d5a11b2db8dbf30e24e383a1ab8363d0076f59eb8e25d3fa93aa9c206670319026f0a16db5cc578aadaf1eec713562598ba9504e918f9e2a855f280bf5361a7f2de24ee9156d0fb0c12440e09e6c9df078856ff1d85f6e9670cd81a33934305bc40afd75cf1ab44b819232c18bbf21d931142097b1230a9d9d983769fb2f4be963ae42ee142dcc0b7b3dff4a48ae033a13d7273318e2805c27417399c32b1d68ea4ff85805f9477465860a24c756849a5bac814c9176d0aabf95c7408827224e55b67e2a7e9dc4d7999fc7ce0f94dea7857d33017a6de87a98ef32c6e565feeab2ca73ae8ac8fa06a7366ea5e6d9a733d3e2a83167300bab9cc61b3a5f1b7cf207f8a76cefb9d459afe45aa2b2a0466abb1a3b62b3612064ac8775ae53e2221205842337a41512fb7a6b5e598589df47eab693212166c980c33d09caf21ead3f471003a63d8f309d0d7731d1a07b07302cc15e462aab0018549056d8bc26f52f997098cd5f9fd844df039680271a0b31d48fe212918f5c4cec0fa3a1f7f5f66349f809c33c0df9432381d1eb20e194293cec4ccb4b1fe2b99d6b3ab7dfe33a89ecfe08e301e5238ad8596ed244f37fa3770a43afbd8a616ccaf023ea1a8d57d0c24cd7c811d4881c77d7c2e749dbc51aa822b3d1ae4c7d1a5e47c9275df4c33619ce1df69793c47d9c8933c286d35988ba34afa1e693755c665f8b5ae4b6b1d1173a990db9f51987488d90900d5bb855efaa82bba21f645ee0d616355061cccfd5449224ca4e7374804772517a0e06469c514f411a90d20f698fb183ec8e2b3395453bb25677bf77d6d69adfccfa650ab50ff450c12693a6854556936e6152ed36e7e2ed6e4c42023b53cbe4c9d05388a4c68c78b4182fbc7d0dc7ec39a7fcdc6b8623c178b26558900d6bf523de6dfab71327e6cd47c66e0295da287e218b272692899c63de37e7ad78366df0d320e990db441781ffaca778b27d602ad4c2b85763c85479d949f7797d62906e8a7b1c4e2f02c5945c938189d162dc5fb0aa1fb888cb51ce0ab2cb3051e1ca3ff0b9ee78f7eb4ecc38f1b928d6d5f4f69e1cf64aa3836876973252589088998528b889a7820923ba13970f5920bc717c880cb7d867f74ee4584459766eb9a02e3e102f8a55784f2c6683b783e26bcdd59642dd4fc9773b5c27aff462a1896ba1f51aeaab0b847bf91935751aacea6ed72daca4314b0b48e4433bb083551f9597af2032f56772446e38f040dd233d7f062ae03ea1fcd143c0cea8121530721e61f36347017c05f713a7c20270bbb4d2d7c587ee179631d16d70c4a0f51b31fc59f38c41e95639ea23434212c6b1fde23cf8aef58492acd7ba50d44f5687d38f4040f2b8a65738425055316306460f3d8b8a6911b0c6566e256512a9142357d2f536baa262c3a8b1687dfc468b3b0f043ab24929bcd5350ab94f5dd32dba7e5a033cc215cbdd1d69d10be0451f9a43cdb01e28b6b0e6dfd150e4d8e9268d45fa8ef0e3d03db42787ad020e3dd6a5411889f91edbcde9da2a7b36bf0d53085eeef81d4531cc0d376d06df2f79ef6f9d122d83666549473b66cb13ae974c73c2ac1bc0f136a3e5659f13799ff5a8efa14745513c62e2465f037e0e16de99ad45531be9261f7cb748167fe797acfa2f9d137d6e168671c3a270a05359a4552ee74ecb987f03b90e290f35346a1893f2ded5dd9578fd11f28925141c06202265a3654355fab4a853a2a5d36af16ab5ace54ec6d1857dbcd2edb2dbc46dbb71dd5d517153ed47b7a6fcccf7d0e63035ff02e294c6c04700c3d71207b33784864d546281fb3c5f953e19e56716997eb7ce98869ac581265b4b41c928a0c63ac25c77338538f8539b4ffcbe601d63fe231d26ddde40c5df6bb7f17c45ae488d8f3074307e13145b66f389df2ccb56deb5c158ceaee80c9acc005b606a3a1fce857964d733bc9ad4354ce78f0f5402b4e50a0a3ea658366f3a2543938fde2801c267eb0d22bd7bda50fe7c6ee9fed86d9ec927a4786016a798ee714e590e17813719f1a3190ebb4d1abb2fa26fe89e463d15fd69fa6ba9974c8216be0bb368e270f83732a1f10cce5472fb99bf845e76927a538322568bac0a893ed9f0793c97846709712b6f689b9ee428fa985c397a9c2943d283c5c488143210083ab6ea6d6a8df049781476a5e203b66301b01b84e3f368fafa23d1256d55299db71f40111cc771c8997a5230df18a98fcfbcdcc4b01f1180b92b0ea5a777cec78f32468271f5cf901d8d1171e901bab865284d7b2703f6b04f4964b6eb626ecf9e3af5430ab813988c0c9d8507bfe594ff83069ef4e5ca70fb4b72640189e7452ccba12dee4c2784695a6408e12bd79239ff454c645dab998203881c21e142b82912ab861208117f01721c6f1f1db854d041eaf97ee7ad14d72ed814b57123015c123a5e613ae17982ba419a7793116b488094dcddd7a311f027c85bd2633cd28553b071a80789653f2707782d5b4c05fd6325318821be5f13eb08e5f3e00a89ba06c39c76e022c99d9c42c80ef6affb4a17574a5676eacc1abc474f97c611c6c2c3369961858ec3bceb31044a8bd24cd6dadb81a192e665e1b0f67c17a45017df691295e1421ef2f5413e4677f8c036079827d4a56498e3066de45534aa050e8a5b16c215e815eddcf2251e7ad89f0bf1c14021d8866f628db11d65a68b55eff68ea7134e8575f940150e7b6794b5128e0845db19e9aaff47298a82a10ac09399635c193d7ad893da3955ea9eb63120ab0721a29e6b9dcfe8c22f725afbf5623366477f485dc02eacfe83c124cf3de3faed74d2d90beb604c372aeb10e83f6bd3694542c2bc5f899d838e68d0d279693e95c7d804904eb39ea9df64588df3b27944ddb09dd8666a4d524c355708c559ef9470a970b0edf8ce34fa80239f6db29e0e54ee359c82d7df8f17e4c4a76a02d1849577f11249fbcf72b92cd467341e0e02101ecd7c30992727ff17f8c1c3b8608ea6477520729a920579ff33f7d68e3cb1cb53eb1414da7362b97dfc5c18c7b1e69cf22e17e4","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
