<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"9ff496ab8a3245a41b30b39f739111fd5dd4b1cc1a31f8fd254208d221ccf32b76df9004771834ca04f0679cc2196f63b66beccf886dd6904abf367d2e75d3a950b95decd2f53902fc4608bd9de0c273078133f508dbbe7ff151763855754471daf9159906e3acd5c423fcbf2adfce260fd2144b4e87cf9ea56130fed197e8152c3c6aec5e5e2bf0e374c738ead3a91cced3b734b0d1b28c0a98975179c868b1ae826b59ce2b1c2537bfba3ef14534c6494fe7d2cf8d9f649cb6106ea061f0a18a5bc08f727bc45550292c33d0ad2e3443364279261ac638af01ca5ed797144396d2e0361efbdb0350146b859806302ca4a816a0f418e44b0f4cca112c84007726ed852b05191942a7e7db334f42fc373675e89f7f873b49a944f871fb51f6f1e15428058a4cc811c192955310083f930c0bd2194a119a3ff3de24853680190496e0fd00a80dc9ae8d5f2808f285d3be97a7730603782c65ad49667e4075132965433ff0a0db2ff1c55a72ec92422368f12a500bfa1f681ed722c6d716518702eb7a57b3f8e1e230705af6ab4f12623e950046d5c174d9db96a5f018b8e31129a65b28c040ec4e5414e4f3a8a677ba4ba0b46e401d359a66457298b9b5c51fb3f5b6e5c31ac0ebc23e61464c403ea91dbf4c1a5b1633807d4d3655247eae008d52adda1d3cde0d80a7fb53717a22ddca327b3091bf3df57fc766aac1cf711c4f6d72688826340aed4b8d29b86ecff2c9fa32f9df5e296d2671503d638c5cd4a1b14283be6a11bda9503a7bbca73707d6ecee1581d1c456065409f9f1137a4c72f160393ea7a451c6dc968aecf1f2aa513d9b12d89514ba3b71d06b6092a161930d554edc60490608e506fbe528e1209182595c7dc4e71f7e0a050d89a8ddf5dbdc73768c4a7910eaed2395cac41554240226135d879d67a5360d5b93d67d0ed84c07b591755056f1d097b39c3e9720baa8c58599cf56689b274d2f5683c67c797c0eac7528ab2417805f54c5f0a5848373d83d83bda9d4e1acd1a6ac13c08f2d159b6cc7fb59353b23e7a474faca3b22508885d7374f7ea3ff6eff64c47cb0c5d8f9966d9e36c186e1965b8ac9834daa09207262b1e8280e05423aee0f1e5402bfc2f409896c9c990f120f7d2bec42b42861c4e3bd7d83cc4654b7bb1df137e5eacc865e1efc97adeb2bf641f0d66e623f2f099db3354dc3b394140e9c495f37e9be25b8bf9be8dd34ddfaa507db655bb0c5065ded4683a143aeb4ea7abe341df9f458602f1d547e68cc50f84b9748eec58f591d99f7773ac8a9462074561ff73df8e96b179d96ff20689b6a41bc112af9d110fe28f546f324f523d3ed2ce225762327cc61ca1ccdfc80f6a05eadaae5b211406b1bef19006a624e20407d07e5b80fe0e8a9f200749cfffa8f1850fd30977b9f0e506a31dd698c1e56bc64e1dc9d6e35dbce3a5dedb8d950d941694b1d3241b69e47e11c49f01d102f4837267de5ab791b1406e826bfaf596e2d5f48f98e19c189c7034fb611a08cd06ba793c76dead9b7e9890ebe15c873e4cdea7f7b2b1e95419d4cbb50a547cc5d2e11dadede26555ffbf1ad37b8b7dbe797d172e0b06eddab2302e347a72c790c30fe3663aba3ba841028313908554d56d17f53009b386c374c7bcb4872bba08039f016bba2df9471b5ed4e85645dc2be0acab0bdae66f35d1955e0028e63609a33644533fdccd1b1dad196ebb663f7acfc2c1a3ebf498d24cd49fea90967b99cf01002f948b50c10ce345a64b67785eca7f4181f37eeefa5e5e8940abd20efff91d859a276e053b32eaf4aba37be2dbd84f3bf5aefe2e9c8edeacd7dcbdfee2d8a4939b4d79ad70677938b5970a04a9c9cd92869201def296dc7c4ccfc5a25bf13cd0c7ec6d038cbc0f9e2233e8df65e2d8159c2048c3bf8a3f3e2a24238d0bab1f8d7905da1e7e16f7b2dd2f0ab85ba95b99f2f93ecad194d7ae567fc8c179c289fa1829b2e1537f42f2c8d8eb97cf35de5cf32a87c1434a596f879b41ff2bbd3411aed512d66e741af5c44e5cfaafc79601ea7c1316d49a149210524f8a2de8c3b332d053947119b7867c60d71aeb759c8ba21f7ae02a6ae39dde589458ef6b7daf1f903529ab7f61a6734300b227cef40479c7f449cde5c31d7c066a5872fb0fa95753ff37eb800b3398dcd9f4f3d609dcd80ba8dd119fc769950ff5c09d7e6bbc43272bd944a5be3c9982e55b7fd5c33047dcee5a134a7c3ab767927e62920e608c295ea78191bff8885f61c3ce0b4e98eede18bf06ed22d8be045c5222e4fb95a7b3cb2cbfc576771d8630f23f6bb546b8c643b443d21e31a777ec1919e06fea2d044cb822dea9f6c74fd43f33697b4c485f3fbdbe53349a147839e79a5468900835db07ba7bac36a7f44175733e901c0cb58b915df82626a8f063583dd7ea36041622891249fc53995a928fb147f1d3155fcdcd61814130b1df130d3335e69b901f73d84a31c3eecdc4812598ff16e0404c5c823a0b760abc8d79bd5de8f4356104cf7452deeb3ebd65ef637c4aa9925b6d81ee512cf3a67b1a62eab7f1e468eb541c7255b3aa8c14efe08391d4f91e72180258318df469d10c744c96330697c2b838ac157e56524b5be34ebbf6bb58024a6fa8ee26988c2886a775f27a134e9353613fdea5967937970670df548e7c2f053f4d34ad8c1b93034a036a38dee92c8d83a9005492019415d98ccdfe7985ba4ae98bab6eed8ff57acacdd1ef46b8694b74759c79b98a7916e846ece43237f6a7561d71e06a4496a631722b47fceb86de71c0fbeed1b76409af00cbfb99c3f4a66cd526310ac70f3a7b0cfef662c4aeb02c8d5de07db70882758adaaf546810b4c9e6583b713dc63f9faa3ca16a57ba052587f9047751d1226d91aeed5845a8efe0f821a9cbe92d26dbb104993a77b2c7ad4211d0a44174b4c9c72d50091c1ac8c25853bf3f1ca6143d74199e3092f8c74450b01eb386f3a4cd7ab0b9c8bba4938f325b6d5a9c7c52f245479649d46f84d95d2410b62dfef5b4bf3c6c8b07134777ff5337ad5fce41612528c69bafa4afe4e9e787c1a039352c8135a04c8a08790d0b382dc03aff7a94405477d7f5316b643a1b1a38fe4e2a17bf2cf35ac993a4f656821020bbf2b2f052ff603d0f71f200ad2fb7acd773911406ad633a4399a6b69a7ad9a5329a3637d660b9a4d973964811a7323ebe89d3234686944ad6efec40e856ff14e640487924d930ec67baa25b025b34846e8e2c9baed38826a7ac0a89efa526b8d58f486b26b484c3374dc031949402075eeb10854de220022c3acbfca3f8083555502493dc499995c6d9fc138e6b87114cc7fef04bafa94a3ea409346fac2a55baf0341705ae0007aa68c97fb290fb9af28d9a57827408452ede9b50e344a39dba014a10c59aa8d120a05398b0844e59e928c6eec45f59e579a656bf757e9975002b5470e017bb520e669b9b1465aabf4d347595a1162be2c69506e8ee88bc8b2a5ab8a76f608dc105b975449b8ed8cba7aa9fbcd8ef0e62896bae2da795e5a07c162eba8e20bac66d5e73fcea5713da3ab1427a869d13616740a68c8af11445d35afb7808a2315cb682e3aca5b883e605d1f8f22ead3778b6500ccf1ea31fbfeda550bc9a7e469ce2367de12286c6b8b73f3b8ac188573229772c6f0701d8ca478e82249c91f36df39016d7f97c40cf790afa6444960b5bd05aeb57fd412868e3ebfeab72a055c5f4c312bd01c110a7d29ec1926b0970f0b2de2ac73cd94d1c5607fa83efe8b6135a639da0d04963edc88092acdb849949675657c8a7047d7cc3817937dbb71b579ba907cfec4e155de3e2d57c4cdf82acff607becd5c0e09cde4d3d421a013643d96d6be817159bee61e9ed0e6d6fb7b9bde44c22eb536eac96fc2eedc3c0ef649c3f89a4f08b3cd4222480513330746c82c1fca9e71f3a46fdfc80c377245dd84d2f0abd4965bfbe38a7b461dc928b0e4aa5512b2ba0390957a885d3edd7689ac78d226bc8e3faf66e8396ac1fa35e512b67eb79ec1131948d7fc8dce8a48f817ecc201320c028612d5954be0e622f66feca1195de27b7150b8c37a725840b0deb536112652ea3520af4e1f194c8c716cb3cb0f4d9f552a3fffa550bfd14b65eff5506462f748d610eaafc234ef2d928199b51503ba958cafd7e8133f24dd9d8a0b180e0f6eb78569f94e8a9f677b905838bc61114f573c2d29be355047896f9ce1c2bee1616b9d191d2eaec4056119adf15abeec75f15ab2eb16d5b0b5f3cea72b5f51fb1488b32c5eb8c413a902d1c2151d5db730d36bf3e1979ea3c9ac07694be4f5f9df67453dea87221cce42a9ad235a8941150f7071a1338b4c7e7eefb2fe4a8eb6cd9c279b93d279c9c7bb8eb6997c886aa738fb260b76f0219a92807e7df13a34004867d8c14cab57174235ce4b766bb24a8c094f623b3985984b8b26f7b8b163dca15a318379e46a2400345387ebd87b80a2da09c63ba5804dcb2ada2ed4d001aeaaa885f19101dfa7f0b03dec2e4c371fcf0247178c8ff784acc92800e520e3b08e57076bf23b2c6ebba7019f10275012638039639883f7d7f709fe3417f3727565f027bf76e18458066aa8f1c11479d37741222bd51c58a7d968e07210845bc7fab8b35b445385e39c0c4b47ee1216e6eb283ffe41f4d179e8d2b88f8015387d24e29470ebb56ac4e9c037b2b7090e11085505ad70e3535094780b1fdad708472b8708246a1ad943e79a63bc04364d4051366e3342f4d3627bca12f1181af86b88153edec182b931f888ea245a8c87415b2b9cc4975e60fa53355322b299a16f0baa11db6ce811ad928b1a94ff58b1a440a87f0a947f7b29cb1735747258c2c47ec2633306a7d25f9f0d7a5be2c1364cbaf3acd20d79a0b75a6b9f021be8a771ec2dd28cd36847ae3c9090a8a9e2fd6c0e2ac6b7f670573e18e98e9c3f536b897ffaa73e090007d1e2f096996a06cb66d16a42d9bce68b6ded2c0979fed6481b7ad42a75bc8fef0c809f9e027b58540489e7825daa0c1dc83b41167cabc06a8fb3ef8fdefcae2066e190dc3026f83c931bdb3c38d9578060b86fd50468c1bcee7d1b7c4892f12d7c85af0b0af0ca6b097705868d8416341a01e8e9e86dcea38f1ddd573e64bf72023962f99232a16ed798df3358f296dfb3eed24c1ced200179687ce243c3f5e7ab23ebb1db6eede61116fe23e8bc25d0149fef408e7f6a4b6f2354a8c78a59aa57aa57b5d3f7cf69055d179145a6cbcb612565f70f5dd175f820e1611f6e8fcf5f23c49b17117fda8655e417cda616308ada9c2aec73de91f31365657066770b8d18be548970f50de713400396f0b17a90d2dac56ee718a62b2c91f069ed5989a631c85a3eb5097a8238bd6250fa099038d3ac837966e4d07850e0707042c1758a2f09c3ad3b88b48151caf17813a8212ae4cff5c780f928265f8ee9145fe69a3025499a75401ec73674060e454a87288fe25d7c667e4018cb2aa9591474e3944a6880ac518e88d19707af2acff7c5cc2a55e28f5e734db2130deac1182aefc67e586e1be68c621d55ab6560f92f2afc6e8691a49800a40865eb3e83dd054ee6df98c25512a599c71524b34888f679876b1af8bffb93e2786c82fd072e61254eab4756b0801a63b20ae061a320227cdd9b5e4f6b75b6f0bc703f153ef6eed7e0afb767fd1a22329f3e6e1d9aa1653328868844533e1289a97071b57ac00a48aa3f9eec219f65b361ad9bd4c8af377fa241dac6c0323a7e30f745100f286938039dd08892265df4a7593d03386e541d554316296ef630326ceb3109f97eb9e8d00ae1e2f34f0fed5aa94ab576b4ad63f38fb48237c7bd696206c75aafcb9c6fd5ace9358535566d7b2a9534d3c5a1baa5da9975db2491f962a77133fc5481fc9736ff33e08767507c53a7c3a018fdd767c05599fff5015174416f6989e8458562b48166560f1e5b74248d977803f65e292ead239c0977a03349cfb8a1b666184d16aa1d6afd1e7716741afa0257ad488e5f1a13c59c34f9776c857f73db3f7329a8250a40768e80114e884da8bcc5988eedf8e8d9f6f9dcad9bd8427c0637619187dace55ad1bea698aec580a44bcaa9a123e8cc68a3648ec99c04f0be556982916f447317a9277d6fe8a8278059d198e76e22fb8beddffcca807caab2d1b99c1f5c330d93e6a62d575fe39095a09448d158eb2ac4012cfb052423b2e9b0de5ee64c064d3f150e89f096dc225ed3d143f45540b450f465a1df45682e3a680bb648952bf3a663cc8b8688d9b72e5760dab8a6a9b7b635e7d65f132c5357f970b002cdd5e936e4dc1397a794057d115aa6a373ed0bad85f576bcf8bd5c426fdea81acc9ffdc6436b841a8a09445c41d7d9f48346e3ef880fe898cab32ff386902a97f34bda476ba5c36f17502367443bb54a9a4754edec85851dfc3571a8975ba2b101e867cdcb269851b36cf8da84336b420e8db9676c6767b2917beac4df5ba064d949c7f87f57694e1fc3f05c956b0a8361b238a47c6ab7eb3209ccfb8aa4212f1fbeb80a930079c35a9adff1939ce269b7eca0bd8252a637a29416b64b90caee16b2256a6c22e1ba00162c8345c927c8e5da8ee4815d306173ef3e27617ae75290ad98f1e1df735ff0bd0fa59ddb9dcb4d12ca961a961f82dfbc878103fb096dfbcddaa06c7b96e2518748a1ce967e47523754066e9715f70e2dc998190ce3adfadb645deaca1e046fbea52ef801bd1e4374f57d9cd5878c0973200b7aef0185493f17739b384587913a74cdb847f02ac14e34bdcd25feea23a5efd0b3eb45df8fa1f604ec2a3d49d962bfbe2c9f59e610b461e13ba96ab39a137a7967cbf304b7ae10c55f65d291bc8eb66e4d6f58ce02e015817699532c18a21021242505e3390817b7336d690bfa87f833e951bb2aaea02f8db43855905d379a28c51b467d6e05e38347107f0e239ae43c9ffcf668f1b92755149bc56a691cc2e2bc0ac9c54d543b7d7ef4ce82a60076171fbb68607b7089718d83de052d9984e93b2c497d04f30fbb8de4c0b3795e8e6608c6e787a9f1ea68d1789b67a29286568d577e2f068492896656e0f8e96475c3bdb443ce64471a0f08a5a3d27f9c9000f2e872ccf8bfc293f4c3927951ebb713ecd3536a1a635a3fbb62135bbb5d23995d05f861cf508f99f6d20428284349287a9d6b6c3250c8e532ecc783690895997c9d408b8c2e2bb55c8122330cfb0d1c4038add3475c176f44f02edbbe9e9c573ec04f9dcea82fc846bf52244dad83149a57f981217494e1fc1b55619f3c4cd492b60b8085ad695b7ffac2c7ae662e3ef6edace60901c8f67901c79ab0638d643f3b970192c6f43e99a975abe062667dbd58ba7644125d46e8081ccf0b549cba83fa75ee45fd3db461471086237f4b5d31b176bde1cc251a93f536234fd12b4c6ecb40b0f25ba282956c22d604dd9706177e4a7721e4eeaeca6bea47b05208728a54c73aa2af326a74135cb3df70aca0102fdf8e967bab92254fa9632c2475a31f3f569333817c03e19b26e5918a61662af9e8ae619ef152c00175e94b0ca42e7cc07f75917cf228dd8ca01d51f577961efc8ffa201d42a1568d83eade0a9274f271a5ceddae01f09d5bd8839fc4293abd241532154c2eb0d924b37ca1883d1514f21c26882365ac6a701e00c4dc1c41588c884220e506d2fa29a198682ee8518e40379ccb627dab23749d9aabff57878c6d476ffce0da2a0fdda33aa522febdb97ea2dcc5db97406d9035f30b6d75c95de21a7414fe69736d2075b93ad3d92839108068f16021d619cf4bb7bafe0c9fabbc48350b52ddd50e86ed0c2645416efcd0dc1a270f51d59ea0fd5b70434e5ad4f729ae2154f6517ba53f19e0ff4bd70a188e3a3f5ec08fbe77c2c9fb087b09e803caa17950208623262f515a41f22859a90cb419080009e153f841ba77b3928f6598fcf5242779d739f19c58777503fa7e2a33dd7545b3fa45ff0efcddb954e19d2ba05cec19e4a0611eb5403bbcda35e44bb4a1b8ea431da7ee25c4b559f400ffaf3f99794d89632bc9066543ec24fa6c06c73a572ab5f658a42c35f269b511fdf47253f0e64749a900143beca50c95132a00a9848e1b4ed6777f0dbb9e15d9581768452a9868250f87a7db93d1c6e84ccc11b1810944cb053e64198985a96a5ca51c2faa45235f72bf60e1e06f62c53136bb104d3080210c322de00ce51ad63ca1a4b14bc9d02d348dc55526c3136208e1f604beb3201ddbe674e2f39fc9d1a0e36add67fc6890afdb6fbd0bbf3ed378ccc5a04459785d9cd0dc51e8fea152103b181ef2df19572ddd461dff975ee043bae78b7a69fe3cb7cca0a2cf9541bd39dffe1705d0d9b9f6f4ad4c10d4bab6e89aca24be5a03dfa7f97463394a9f2fcc818020d357db55e41907e3c16262bc4a3bebdc45894b854f150d49448973bb947a1058ce896accd36225b44c1ea0272d5ae5461889cb4f8e52a5fa4830136723cee9595669b0694b40d3486383b527dde3b068353a249e99e60f972426dba03b7d9b55dee06688f924109c72f1349f168c9db4c3d40653f795d6ef06e913ad651d3d17f77fc7c5f46456b4ba4654b14a2cfa47e1d9cdc5e01e4fd4569676d7e17b1fc76d9a2e36e27d8ff0cd5ca561738b9805aaca6996ebd39e298a9388dfdd4fe1b23b7b10b14827d4f99089542f3ccba3616e00722efcd382b46ccfbe432bad0b91c53505ed23994486771c7bcfbe416041cc9fda8e63963af073d320fa710818b0effc33d6673cdb4d0ca2e32777d5506574aac1b8f08c4d664789cca4c89d501045a6b86cf1bbd875e7666a0803193fbd80be2938004e5c5f566f8e3bddc8292de7a35eec16a11fee135cedd09e3e776ae03bcc031c63d0e1707636d507814c9bb5d8434fd6ee69cbfb2f447a77ddcaec8ee340c0d25950cddd20c0e69429fe6d17542272f1de3836d5345780fc3c7290fd7795ef29415b97225b0fd490ab6b3f089e239dbab0ea6bf3c270657ad6b442f6a1cd04bbf0ce42c501c24c4e5a88814f51833def9c0314ea21cea486e42d84eec087e2016f8919f2ba726b556d717c6c6ca99344619a8bcab2ac472f23e0115d02e9e89cfd17bfbee72730284e807ee7dffe60ce6785dbc362b83d18f0580349e0677ecd0623454ed51d38de4eddd486ef21d9ebd912527a992ee02b7b01b83b6be7176c92bd5d34f95dea758527612069c72f20bcea03d62708572b19718198fd9edc762fc4056df068e76b0ad7f64d60a3ede7a11b18699e3a3c48702682dfb2d33c6e6674dd971e2b540f254f0b9d6b929f5b05198e0fb17ad47f70d4e3c06555cbb170046ffb94ceeb6fcd27f57de3d653a6c42beb989142aa72af4aa7cc8b18402e6ff402749f1902aaa58fcbbea4f1072906da24eda4f9cc059b7139a2c4dc7cbeb8fe451cc02e373181015f20501065400c0a41415b2c522e4caec03e0f1773bffef9d87edbc606ecdb11f7de85337152176ba45da616252f373d3c3ee226a9e3fbc647a0ec4c9d5478fb57983bad87a02b3ef6e8043f1180b7e11e3614f77b36a0cb7105a7cc381e5e832e8ae99804987e9426c686b5aee154ea64f31941195062967c072e58b6c740d49a0933b94a10c6da8a3cbae8c4daf264de562bec2d189b3b7f61d98fd9547b49ea57531d48c71c9c55dd7f54f92835de57b504ba61ede628b37827b95c2ca7a21a085faf15f4c4ef33b9b8ea773895e7ffb44b92cf9d559ac20f1a24df6bb579aa27bca8e0f2575d534aa49709dd845272a841d2f4a7011413c5fdea08907345049f38781823856cdbe3f6d1583be7cc516ddf831734e201acb0fc9ab443cd01ccd027bc3a48fd303577cfcb578b55ea3ed67334ad4ee800621914a77449f505c5d78c991112ca374e40b2de89c4d918a6f7ea24fb8d19dc577876dbaba7b2d1765422e2d98ce51c428c2ed700659ea72fd7d61d32f8783c532e5a79ef3ca0b8644b153e720f5faf1e3d32233d024d6914a149ff8b3c4df63156d862ba84e7b4211f74967d34c0afd8f50f0bacf66e0fb5b55a62d24b997ba0fd94609669dbeec4d9ceb55fc754d91c5f9cd48ffc205b3158bc4456e5c33798110bf944a40cec0bc57a019a191097564ec0d9245944575f82ab95ddb814b2968e98c437ee22dcc6ce6389b4d8580689c7ed8e47bf53b5513ea591b3052fb1a8d838c8e49c75b4909c6e40fca21f08e62be79a743aa4caef26db01062155543482f1c871172fdf60ce791ef20dfe77f64ad8f0225f22176b884b8a7e2434351c6fb8c1edcccbc465752218167ca67973946ecf172f231915ea1ff4d86a277753ba79fe90594e14e0620e75cba1b5d22865ce0374fc3899b55d34245251062358293b917a8da3e8ed9f68f0d209799b1ac5a927bda57b2d40b0b5141569583a5aaa91daa477c506933e0a1fbf5ba2016a43a7b104c43cc8417137957aa2e3ad0891b286e85ff06c471ea622b17783d72eb34fcb59f583b2403acf4663db640d26c7ed9f849df2b62f5a6819773d4f19d5b046a15d0abec9a411117e5914de4b92fa9d2826a4f8cc51ac665d2abd39ae66aa991ae70a5a5104bac5e93457d7d4b6e41c9f9e4df26d5d6045f3088611e656c5c4fd6f85bd4d43f3dd31244c356d843f6516626b21b8c076b5ae29b453f444f718cbb3da4b4966b162ab07fcf9a39779ec6c54cb42898f4a3ba73616ffc0bfc9671ef1e1f395d391fe072b72286ea0becc7176d374354ff235a978a639e5dd5b661e69394a84efd77302b9f0663bae3fa4caabcf0664beec0cf5ddc832d6e1920e4cfd10a2664ed009cb9b3ec9b90b47248162fd65363ec103bfd8d25ce8a498993aae92f12e959a95723c7627327f278205f46d2b2e80dfe985e4d3e918a8a6e466b772974d5dabbc9b469d7211772f73f3f29984d1f26ad3dca27ef85bf070149d0019b4ffc552f9c4b5ed65dd7fefa22ce9466ac572f9c0bed971008dfe86aefefb59765f739d79a5eb770f4e482a4e048f061266f3fb591de3891f8f0641294b7ecbdbb3771e0cb5f9783ecd72726e69193e2e0a18e177aec7a753804ba454e257683c2bde0c91b2ed4a49885fedc6cc2679e40f0740e9b8441b1b22180d59eb8f174fb699bf70f8c1898b70bfa2e0e8e9f4a2f07c00a84b3cd76b80bf6a5137c85d29e3a89704cb734a11d04b898d2f0d3bd4db24f8f7052b6c149329e0f46d99fde2e2c56f16be1bf48e1eebab8c29183a83e9eff22874bab99fe144e279871105e2729b68f10799bba7f6c20e0cd0633f99c0fc2f9301edac173ec12fdc563676cb2a6039974e26794db9e2e590e950372ed93f5adfc922075beb239c244dc81dedbb56761de8e4c330b8e919c84b64467d2cbc8187150a23d7f6d083b74054f324bf584060d06112f007225f87b0e0c0ca2d143adf0ae9f0f392ea4c54b8af12c9b3d46abda4ec6f82b416ce1679fea2176e664b105d0c99ed612fedbd281b5ca6a50f323c5b2589e950371ee6fbd774d9e93dd7f6c702f6b6332d048b3b87d34fde0ff5fa746ecd40a3c186802c7cf369d108375eb45880e2d948045d536deb4912b224d50ff45788b5ec49edddd59e81e48224fafb64b9217cc27c3cd809756602e1bf1b00d271b6228551a6f9a519f24281fdffe481b2a06c06b62b8266b17088b9f71d0a5c308ba608707f0cb5a7e5453fa3a90525bb4cdf423c3e401d463a6ce7bd3f0ab83a165ab676115fb70e707915741954ace57d2d1f9464d1609e53ebbcb9a5984b6d7c9ac31ddf7a6741efb4a5f417f4ceb385dcdf1a3822ed616c4c967440a80bc0bacf3417048de1f2c41772600432a437107447284a62452d1b87ff26e50bc4fa6b1d6c810b9e59e33b360815179d6a8c4326ac69c8072817b8b9287c5e6390b436f2d509256b0d196716a5738490464000fea37a84b2c745532429b58eacd26f47d8f4ef105833f1616cb8dbc257b43fc6b9387e4bf215a1c9772ddcb06a0d1b1e5c79885745642ce2486b3dd7c5fa727c7f5dd3c17acacce9af6b4cbcd51bc151f22f0f7a1fe1b0014aa16de946f21b2f87e03101be845bfe276a32065daf37fae848e4a05c2717ecc2fe318431d14ed75ad4cf7c4be7554e0aed0766a6d2fa2c6810efaf964bfa18ccaa5bd6c956adf385890e169094402c6761743b632c747c0ad0487b4a3164f5b3c68e6842124ed23945dcde57d720b68bef3e85d572e750479d56746b171bf3c8ed579fe3f26406c22586195750bc9c100a575b4f9d8adc618b9bb4b84518347f1b971791f0aaf7204919341734d481ab02b4a9231c04ff22d4aa4c8807683af7e73c424b509fae01d01aa2f377626b52a48e418c0616c715cd30498d69ea17f2ff4c58079800145becd18be3a8090357f7053471cb8acd0205e66decafd49eb5566f9d5de91b68af2b92f533331322e440c1d4a875f2dba0156b86c405992739a8c67412c64fda14361b64b16298c0b1d9bbed3568da21d119b40034bfaabef1d2e9c1f1e8209649d4911dfd1141db77f47d9a208bb587fcf33b72c288462824969142fc03d564de9dfb512dcf33d5d5fbb05a14815a178c587ca19ed219fde6bd986bbac462caf618977945a2ff31cee57cbd5850b420d158fe8b6238b68792134e2ab3fcd3bd5c27b4172ab1ac1cbd62092373026bc747337c7a4523d8e79e7cc1aa691a7cf6f3d62bdcac79789519da66d66db02ad157cc554e31bf5c2c72b86c72aa071642d589690bfe5843fa6effa69d74ff20dff77f3e309a9c59d1acb3c9a37f157fc2df03ecdfa06b0a6a67bbf1ca8fa57666ea5dc5c9f058402e163b11b17612e28893627218b1321a5aebeb73864622f068465b21bcdc897bdf1119eb76c0880e151bfcb435df8d9f44c55286f110ffb3e6d096db03ad1a97e7b2f47303ce2f43854d761dae48ce72c67f25327b42bb354d1dac019e95b1273e1301f6deb4848c4742385cee8e9f99d5988662741886990207c56c0822f8d4d471e129868b1e6a114b2ff38b23475cba914346daad4412485a89ce7283d17a4f72ea4f118e6b8caf73ed2114ce6fb168f2ff46dd2a97c1ead29815525cfd6b577e9de4aadd76c0370e887a55bd3708e004d32311a3c3cd9606666a646118b615a5728164812b8a06667457f926fbd79598a9e8c34e0300c922cf8d3863743c20ea6bfb974abfca0cfbfc5f71f4fbe7fd054149bc7efbc9299be7df58c2655e1254192ea00ef5e08d510021b06447e5af8e422dd9ae8f6b40a33e585cee4eccb91512ae65e4c9d6b5a0f4b670107ef8b3abcab3201bc0f231b7e08371e8ab5c01ba2b5432dceff49fc2bed509326f1c0616ed32dd3c5d655213f2c749f1db656ef11f65a59a9b07d44cab8ee79409b49ea027367cebed74e00b68ffa5692cbe9d9b5be2475a14be93ca4b544bb0bd6c060058ebf365ee79318bbbe206e71410e6fe5a1b12d0d4b7d9c04e76d958bdf228cc607e8e3e84bc43ba075b175c0918208c05c095cade6eb3198bc1ee53ab0e5cdd2c07f7deec560447a79a3c8a0d129dae166f669032691f0bfb23c82df865efdb7c7485b1660b702765d5996e62d76db9dc9a2a1054a39d03bc83f315fc62f91ba5c00efd14fe1f142608bfcb94c9a68fbddb638fd865eaebe14e97c180e16253164d0e2f90fcbebedd701e584f5772ae5252495cf115d26edeb3452792d2d89b409434e78fddfafb35a8f09f8cc88b40bda862efd9b5ddfc97c70129e1ab1c4dab3630352f64ad7720f7e649cfe248b7f3f22a48b048d133d43bdd2fedaf584b8e4826f42da061bf0e59357086d7a972d77ba4e164c8ca7c378a8c443136085167ee5a9173b09da7e0efca9270e14d3c875340951e873a2f3c54fa7fa73c21b920c81fc14d468c47b00f0eb7b73c93715598f1add447edc14f721ca37a14c0615f4760f0c867fe121e15a80e83cd0552b9fd4a23adbcb86032c437f47186a657c47384d6efde65b2d575d4fd06e8ab8a74cc53d75aa0d1a94afa5fcdcaf6e167d0bc02beb988a1a9b5d34479af67ca85b06c943cd0c471bfc5ac3d4b48599695e92507db8d29f2c351f5d3e92622a00358ff1cd0b09cef4a479f128a6e1da142c87a99deb94aafe20ce9e98d768d3892774925ec81e40a5b7966ab677ffa649a9f8c0768431dd52660f9f87c9020ca63d3c67de56b1aad7d823647cb78e60372f53f52c61e2b730e4fc4c55d42db851e5447f456d76cd43837862e65468ed559610844a3fedfcd68e7f5423760d3ee1b60fee266e2ce13c3f2a5ed8bc769f9f6a61226437a6e6bdc8ee00ce1319d06a504595cf915f1947164361a422a6e4997f16e131a1a1da21b48530465f8127f6d1eb4c18f6879eb9f6790af52b3885833669dd4a9afb2f38b8be5ecc647afb869c4dab0545c14442a3bfcd013d6e6f8ea602f80f0dc6afe7bd4602a48f274b45e7faf0b0f38965278fa52fd9bdd98c98f641c8f22fa37869a98cddc490febdd8c623b76f6b32a866e0d0d5adcc4b55be01d57c31cbbac003cf2a64ecb3991b3cb67eb03a66e396988135a3840e7b2465bd876b74fd3be2c7f02640dc5cecada0c43ff46520832698605eb6023e731ff3140e9bb865b06ad5759c6fb846e556e9ad5a187918102cc4b94d70f8de781cf69518e673c911cc268c2657b360f4e3be2dd9ad4aeb42d507562590e5a22a8310e4fab0a0147f656781b7c846037b4d04697a297707bb261658f33afe28008d861e295391d3c4a43901d497f869c26e81e4c0105f5cbb987bc5972e78d517b1ea2db1131fa975658ef36396b3bc18b6032d94d2815ac5f0c0b1ef8d550db865bf51f8c3f6d9e3818ce151a4fcad66b6598ed474b924b0e77e8e2fd0ed1b1a9dc1fe9fdbba9e23d6f130e91069b23f428c729d4e99ba5da8ab84405efe2180b691ec9e1bcb3174151d42f44b3b1088a17057d96d1c95d128fe8c3a472c6150fcd935dbbec0af4fdafb36f3e8d79b8cbc3442660d550ebad2eac6d883655f568f6f94c6a5c7499dd5561632ee9c81d81e2a7ddbb813a5b22340478e7c8a42d36aac1c7d8829f54d90d55296dc53b6056a8113de8bb4c8c1e8b080002402bb22c4c1c67d4c26fbe3c964d0ccc174044b7e3a360db50949c794c95e23c1e2e680dae13b379e96f7200766bdc0f8354e0ae8379b3b9894b1396342f87d204f5f54c98036b933740c101e0dc816bac5319b6866b4875d0d01f88a3e80453fe339cbac2e226cd5b1f10e53bee059eca0d34c18a3c4a0963ba39ae2269704650095ba4550940c9394550a49f272356a8de806799638d3cbdc744e05b820ff66e2553d4d00661c5eea1ef284aa6e1cc23fca9d214de426e5ac56d2101ff28e048d675746142e89fb031ab30d2083668366158d5fe10c6d0fec01fdb0e42e1eda0f0cdd713b5498c69fdac56575dba7fa0f4cc3fc03b2e64014e2aed5694caaabc44aefc2a670dcc459c026f1c758c1de524d9b05b4e1d67de99d63c0558046001cadba8450874f5c220bf8079b8e177706186f9ec7d462424fbe880c7e8b36bdd61101a4c08485849696dd3507acccb5af13285662e1e4a637bff09d51e304c795f8482279fdcbd0d8c049d7cbb5d459069420dbb85357a37e0e7dc0e685f73bda5ce9fa5b573f68ab1c07233f56e7d5ccf1377d90b486dfb8e3ec5d0adb7b35b0bd3562536b1eb1101696842d4d16e25c8a494d6ca5d26a610c1d81718fd7af404970eff2138829b64c2d6f6f0f4df94e80cbd8446b74784c58029c7287e4cce6558257b4f58872a8a742ba5ac7cbb299ea725dfe0ca3ad723b41e55a78e7cb4832fdc012536e224302fca69fc5ce7e2796622916cc1b9af6a62fc51ebbb3e7db21634d22533301e237c089d81eed74fa9130a0d246d5c0f9767c1a0b10c1eee2498fe670fd2a3e81c8755ed0b1abd461e6a34e21981830671e971105d444a7483e4af4a14a1021791f376cd0ca670c3f5801093bcc7b31f0c572dfb3dbc1219063665f39e798fd38b20390891696304b6a7f52de258f610ad4d4d50bb89cabc816aa66d2a505080fde0bd2faa760d0e321b796ea2ecdc10fb8e0802628dc5d8840e1a1131434c6690fc646e41f9e0e815678447ffcd8735908743d4bee941b3f451f844562df821a5aa90e134b5eb332b85371a47ffe7b728542439a8a290bd8bd0a44d23aedb8b9bba9d5d89d28d711b90b7bd17672b78562d53e3d9e900363110167c6c1b60c7f8fd94ff1ed447ece1fa2fe8a385979d02303cb658694e21fbdfad4531f0c20d9d55566f867dc31b0d71355cd2032e0a850fe1d176cb520e39c568755412f7e9bfe3589cb65594c649fde403a83ba61cd10b7d5dd4dc5ec887e65fadf0da905e1b8f022790a974fb9f2f450e4d54ae1eee510951cb75b0851da95b6a5fa82a6705c7c66c7f93147d4281416fb0fa6694cc651817175fd689a13f10a51cedcf3faea4514aab41646ca5d71f90426db639356452167ba8baef1f0e2a1f705898c1eef8687eaab96a543fd99a846a469549a30d9fc8db53d6e10d71a7faba5898ba3112341ea53a67c3112fbd51ec99eed63638e89ae5d06bcd7ab2c9744e6a291d4a1c2f5536f91005966d97ec2b5056b774474be46444602d6e6f977aa9ffa9aa99b99a29c954e244fc4571a2b49b03bd4d1507300bb8409bf14f17366d2edd70b697421bc6d249bf4555f1734fb28886971104471d385744e684c4ccc9f49f759b0ebcd52f443b20dfc8c3d4992a1002eb58f58b245a2988442bc73927991a62995ec936e8fb6ab81a4e4253e5e8a0e2fd40b77cef64ae4e8d3e271292aba125a676b00fab60cebf92140b5cbc138ff7b1bee4aae5f8babea4180555c654c903a12fdc2798676c62041b3b83c933920615d799890f52bf0f0cd78fe3d36d67dab26d509d7b3dee9a70d57bc6f497c232dec65d60eea4f74429752c080831aa8327c6f44b054f631216d0020569fbdeea32185f69ce441721397e6c302bc0a5e07e8cc859ed9fd266eaf627a9d90130d994bd9a48f19eda05675fe378fdc230d40137e7fb9bb5ab5be05913186c4c579662230d61cb00bf2741dd15badfd63339e55f6627ab9c56778dae48f7cbde7999e87614c32e14237c82d2cf5cb23fae2e4a26d27438aea29c8d9e92806b10dd77702c627f05ecedf86ae15f1bbcc6aa66227674341389ea8c6f38ce398de0c0d1d325bd43fb797c06e05c9e6d005f30cd205ab2035027d0bad45169ebb7b38dfda3d94e6ee9d82ebbd1a20a987eabdf721fa9975e1354cb737bb4e84986db81c979ea63775483477db3db49ef11a55b1211b7ae8c090837695383ad9abcc9ea376a9f6f6819ca7c671bde30e84967ea3f51387d4044690912d792c78fb9d522fd4c7a3f78730f9825008823d1c2b895686e2755ec3026d2de883d9e0e847642c9667a587ebf614c1af2a3c2c96db9a58bd37d60225f9872d9e49a3a789baf761cf46ecf4ed85d05160384b6168a62871a401bf5a7b8b47c1aac338a600b146650333b650732d8a21f09b89d5e31eb38cc10dd60beea17a100dd19fd08ac496bec51549eacbc0f721c4cbc9e8c258e9de1b21d61186ec9f01f6fb4f12e48217e2d90c1198fef157eb1e537550e3457b0fc0808efba68dc00becb35484e348e5ac77bd6a5736ecce79a0c524758e650a7f0885f714c30983e89d4a5a6381ca60a898349713d9d0c444381e0f945fed5def35c4fb52a9a43e53a4a2b1c53af4e42710971b8025a32768858c1de8d950b186998abc171bbc013d4eade3853072e2ac34492d8e10585b64d75dca82b40fe31014b77970f5f8d83902411b891fea68d9bafe8363f7e6c5e42a23b421a928a2016dffc91f481793d4c2268dab8f56b6c8e377f173590090306130b2fa0d6bcf6cec6fe8776689a820cec706186a9bf54ef2e0823ce5fdbc23c305a03b869441cc12e2d9def8065b2278dd33a1f032aa832d5dc39eb7d3de6374c4181e38880b2687c4d527548a1e5d8a60e292075909c75d5793f465dc257f1aa967d8f43da5d760f07610ff26364dd05990fec791ba87d4fd723ea124a74585f70dc6661ede161021b0b7ebba37f5bfe36df3aac4422371d1940ae2fb82ebeba89c6f23054c56478c193f804930d2159be34a41b22d22973643c8c7f72e566d97edd51f41730dfc3724dd47b7b402279c5c60a710fa8df841429c3c78868441a1ed7fe8f2e11c0aebf4897bcb73685c5a1b91009aade4abf19becabb9e5fcf4a5edbe1461fb8f92007f41f7005a3dd3627d63c69c0909e34b6d904b4ffe2ca3be14d8d56d465b830f801ec6758f2fb9d4466b9dce799984798524a233336ecc071f0149e39144574d9428b26c754e19db043cab5440a560165eaf60fd7c5d583684c4fcbef7869c947e6a1ef2b2669d35d6a4908199f5ed4c8bc94f0a1b8a253eb029d102a5b02ab4bf9f64e4924b18851ae7838210d78f54e1e8f8cfdff2f1e126e1cf755da72255f141d03d953d2b197ace84761bb7be91ad6b9d2a531312678d939476ed666558914ef8a09d325bb1838c281f520d0622bfedc040aa26317efd4794760fe53d2237d74796c49ff059d29332ea7ee8cfc598482d49a142a7e9a56b94c139b3fc3d11d8373026c9e7cc49334d643e562a12546aec6fd8a70bc69864bcebdef4568e4e1fe4cc796e84ce8c9274a5c73fe1e55398652969b9dddd411ed791c8171d516dcf1e13c9a0f4fe54b2df545cec2e14666689a891a77ec20bf346693a7c606092405a55cddd299cd9711b0acdec12436d5dd016832347ac17950f4d6787a37dae3e0e176137b2f642d8abf8af334cddaeecdad62c68a520624a7b30151959745eb1ecd4b185ea151695e3eccf04d8d9801526f6b672bca781a986c296efc543564955309345918127c4b059e0eed3553aeab3cac1c552980bfe2e0069fd48756e5cd0c5873c1311c338d3a7e18e81df14bfe3ec401dbb967b0e5332a180ef77cec316f3106c04e6f50e2a248d4ed8e7efa99dddb58968e61782c4341598e43a684c98bac7d7887aed1b57eef182213822de6af34ee04565d16567b6e6021f0da17367cda7fb52b94c592f46c38386eefd49555c6f56b8db413b091429469e34209d505776e4d45dbd819585b67be256d2dde90d136f54b0b53e460d92dcbd3c53d10fb3acd670f507bf46688ef184c4087774ce6c039e995166b7c9e8596dc8dd5cbbaa95ba1cf98bb5fef33d9bb44bceefb34a8706084d343a7c781d2213a9532613926751606222ef03152f2888c9aaf27e4a96d39801e854da743fe56b9113c9f825665fcdd2c5df5098cc27d76df28428456d625f89328df09b91816eafe5d9e9fbb44d41374fdc79d85e9cf68d82cd4e5a1083e23eb353c8eea7257ecfcb0463fade2f3e46d836fda183735261ca53abb7edc583d3f602754474f96f9960cff2914691af478b4cf2d6d6b367fdfff82bfcabeb14d093b74968931083f3998ea6eee5ccc2b6cba94e7cbefb0ff1f21a10448b0d8823cbd79d05e840c845e2e9fc6fd727e5e23112b824a4280216b8bd5ea4ce2864b9ebb7190fb9e0964b5dbf08083dfd019cd682aa691bef5565a1f92b4bfeef02afc899ad28396fd3a0e8f0655d9809643d0c3771e97e963e39071f75a113b82502900b34b50a500e64ae71e27caf59ee870440efd00506f1e4caec91e50de09d6001285da699867ad431c8161110f56c99575977d5d577a88860803ed298037647587ab1a05ef096398f9028c0a062ba9ea7e00647381f94d7c10a1498c6df4cdd42d07ad343bca4962dbefd240ac4b9022ae406155002a53368f713585971852390488a0ef8724daeb8a4ab3ce74fda858939a22ecb4253e1c636783fff4399bb8461c69f5642c4f2b93bdc3063636f94910f289d147b717fa4b0df87a8f726052ef37b80bc46be0ee77ec7b72196991615e8e4c4b29c6601c7b1afcf6996ebcce33e2fbcdf98147b45142738d7202b138fb664d41385e2d058e78e2d4bc83b0d6332a2cf77d9248cf5384a5a97df1aa63b7bbc6a11e15b3763d7c05b84b36c716f7208af0727462154c86435aaaa2f512459db2871d4058b01f1db8d10d6b5a111e9c62b225bf612466647c149bdf7b37d29c104fc96db0be4c342fd1fb53c542a41e29ca23697b3843a6a67675d283ab9f2acdaaa9e652578046fb0dc0951bab3d6bb9f9e1bfd13177becf7fc02e41a2c645e8468f2c0547cfb81f2d99bff36541a1018e226625e0901d0a5f4c438caf9f8bdfb25f8d938f2d0d86751c6ef4404260d23265757e353cc011f6c889de36b8146841f510729b3889c5524faba650e67965068aa2c4ffbd31e72cb48639db36ed2412adbc18d7c4e8bacc7f460d5472cb6b907732acd06ccd945ce2a1c6d254d55c6bcb85086e194b97607b0c94c76d8fc2457a3ac8fb2de5dc447051cfa234947e7515d630d392a82a8d7036d960e680916ce0f57f7c4c800348f3ad3482ce19722c7e910bd11c9464beada571cabb1699f092d043cb4d237f123a3bb667c3eb32638ee51bb0e4b35140621e5e2f1a553b9aeab59f487abf919ace074207caec8262146c5c68658d1981b768e852c1b03f6490344c53065a687360741adafbef4564abe66409af51fee35731e3df6511c8f74f0f56d46e369bf71d4159ad08f6a62dc123564cc5be89eb83f158b3ccb0cb3e440880f9e1b0215df420b327e9dd29ec8bc07890d58fd506b0b50f51992faf1c250c55597803818e5a6698d2c1a3153e20b74b5954a238bac9ccac100b54350e570d4003afa938779ebd54bdb1987d5334f9e7906a1d713daa8400e22a027cc1ef03029f6ccfe12e697d409ecd2343717cc237c02e6bd96dc5572e0023f4f5f90f172a1807f1fbeba74335186bde1ac924bdcc8dc45519eb42a6824a4589daef61fc4098c577124ca17a6b0de1231bda8a81138b09b516cef605955c8fd5618f3a1c9a0916c4490bfd1136c36644b407adb7128b83219e80f91bf6f9d9a86fb259c1640578f556ba5445d2d2f1bf6950a62ebe44b99f4398c8ca25615ff636a8584c2a22cd6afdb63ecffa31b25e8747c34ad1e6af7dc7a118827c0a11c18359be820ab396f650b852be2a2e86352632c1595ae9df1bc2e8755534ab262121df22b21bcfe37eb200340a351558cec4a89bbd4100e2f9fb03121e16f697ce3c17f1c77a40597c1f1169403631ae7067ebcec8a5d52dd79c5319ec237ac79458ea6cc2a6fe9fbae381df75058339a6d35f32851b01856ef062d88c1155eb2eaa84a5941e423351d60595852b8e8991b3e902ac9f64500599e1851e819ccc3e7ccbad170a2f41841d7c744251ce30dcb84a504c8608a937d08e07f1ae9d1c1841234bc1258f3","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
