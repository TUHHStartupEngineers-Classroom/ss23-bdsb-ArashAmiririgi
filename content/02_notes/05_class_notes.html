<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"338d94979109eee188da56cd4afc977f55f290dd20d526d66e0cf3b20add920bdfe7b6b8e4f2a72bfed4ca5004fbd1c442460e47eed6cf5701813c7a417c8a93e7eff0f1effd43c64cebab77a6b43b3de042b305c3e1bd50d515b7d7cd8dff49a465d4555cfe913eb580d4e16c69e91fb9f1dc3183e658e03414ca4baee13bdcb773548c74f4dfb1351f527ed66828bdcb63f2917c9e39b86bdc55db6736e14d67bf674c6cde7dad34529f4a71e376d19e791089bef8059d4a3523e960dc04069c11042695d7697356a0eba310a6c1b30e329528b50d486cae0f1f4d9244490ed510d28c55a0f6ba456e77d7a8506b0c06d38c49d1c81559a46dea553c28cc9499fa5803db773bc1444007e58363d72dc2bc1f13dd254e5dbe6927a2585203497c25e140417006637e8c5daa97579d6395e3f986390b0f4b13b517f710eb7c62aa8ca8bafddb3b44ee0fb23198deab1f7b312a2ea276f08e5d8ffac6ceabadd1f847f0b89d47284313f768ed57dc2ebc20069d7c9751fbae262530baaa761c566c8ec55a0adf72aa8745e23a2b3bd9102bd303e746a94649528a5f1cd871793efb15c84aaa9e40f3b6206ee7ec8c1a821bf4c481303ec8d97a756a2bc014b1526e7278c1e09d8aec48958c8ebfac3f1a2dbbd488920cdf5c5e32c3fd4ea03b389de8e893d15629dd6fc311d5c40219c30e56d3e7a2b28ef12f3ac3041d979ae89b6a42485bf5467dab25a824ad0ef21f6c466a275d83284e7211faa7ab7747e51c74ee3717ef8b41e3d201eaf24fa565b597cec981cd9eafff85f1a529d469c111fc6bd3dee3dbabd9c67302633c1124a230a3d40683a9d542cf8ac33c501ae6efe8e33bc65a45053f49542b9e3f681b328a88aadd5d85ae5c38f4964e887152f08aa28b1e2830e3475e062cb6bcc7d19b5a5eaab56787a3f10efbd6e85f7c376a45b06502db848b9f6b03ab434aebc4cfaed23c88160c816c57a2a41a746eddbec979ab8f317467d8698745e16f93591944bb90c9326633b2e340d19150dc88be99a0103c23e49b4cd48777948f1a01113de59c2bd4c5e0907f2c0884b48631f1eb198d133894b2de53a73487e29983e0f6c28307d62e3fb1a16af2ef441bab1f2e3a8b8029d1f826c3d7b2e5dd60e9f17098d635e509dc93150d1da1ef50b08c6773695b745a176bc840d80ae4e04fdb76cf1cbf68f453563f2e13c1538ebbb396b449918042aab7c765f007a0755eef0f482b19ce249b1757b88520838910730d934c1d60cb17972bec117734dce7bea82564fc5d2415db5f2adbfa63ddd093c3da6346e882612c1e974828c22fad7eb22819d5b35235d03c49d244131a48d520240fd45f38e8ac5ed12776cb5612496bccecdd3fcc1420848fba3d4a2e634a5fec6ab41908c30eee703d2d2c8cbb056848028dc7e7892b6bf1b7a2089d78813650ef09c63a51e0431a8dbd4f30cb7a3cced866037964fdec498cafec4135d053c174b93f606fb5200b5cdce647f55f946d2e8beed08e4b8976eb6e73ac0411691997f8991d76aedd35fc3b02b61aba523ff116f9c53fefeadc99452d541527a18dcda24876dcc3e2caf2327ccd14c9d22264e8a6281d76e4127cb7cc1907930026cd19e58da27509db33d941c542a160035c48fb2b1f6444f76a3c531551e1170b4692c02200469b32bf6470e77c8eac600bcc2e765355790998982d8de46c48eb612f99c37893cf64928a24af101c96007d0496f4026ad94541492c320dc46ba4ed897677be5ffda6a9f1a59c86607eadcbc444affe2f4808ec055405d1b54f99522fa6534f90081c33a1646d39050b9288fbe933a3f89fa36383344e8bd8f75e416d936c0bc665c17b82ec644ca88ee19b30e970d16ecd44d3fe7336fc52819338c6205c18f619704cbcaf41215849bf7ef5fc24c1e9efa64cb79c2d0558ccf40d932d6e534fbeb44919bcfc102a59a0615024d6d1a3c8055a3c53285e6f9f69ebee40c8d9ae1f1286fea5d4d440069602def1f15bdcdfc88d162f47a87a386154f2040df4081390e91b1ed94307cb9e3629e6f853f8d1baf5a02fe8915b59a1a2f005dfa720413809318d13db7a81477f4df29f463eac946b0fcaa7324110aa5d0749c091cf181596f406d642099b31f0e49ba7421109c950a42e0a750ec5d951a627ef638db43e1a9f1252a7c27d5091e9459d722c4c32a6535f107d9e1ed3f43758e30815345e01f360ef1a519b541e74763c455c265b006805a18e16fbc9f644c62e9ffc6d1d9c7e246016ab864813948a20852ca68e517fd97d2eeeeabbd1baad4c62e97abb426125e5ef66c56a988ce5336119f236479fd7fcf289f0c8735c97c628dfb27170dd533ecd2564bec16298ac2b5172557794b75d9ce348464ddbb9271615369af5816c047e5f0e922454be844d6d7ce30104e1fb40c2e847dc57e8f28fbbcc6c054722486eea127febc027c5a93d4cbbdb947c173efb99744e2317c7c1c039c1e75f921b0ee4525e4b2ac1db9d87c4fdaf80124efbec273cc1c82d14ce44c3259ed35b2d2db1a2a89a9d2cbd8a61518c3f66a991990ae89a9b01764eab59584e5c9595628cef8f6fc4a48a9adb49c952ec40ccb437f057206636feae6245d171a8ed61065f8645e386f637dfa8f0955b3845555a84906a3dca6d48420307f16400b626800dbcccef1f9e8e594c47e63d3a08a098797432db28ad94d86b4406fff9929ee577ed9ab32a5a8fc2c82667c7503e14ab06d0761e9da860961b1a7d43fe86e01c399a2c3c4767120823da1aa20c17b0e1d89dcac4a90c3da54852ebd1c56cdb09d75d1d4762b2f4a6d4dcfc3fa687133b56d158882476d07955207cab38d570286d0d5909148e2fd1e6cc647f23c598035e7e5b0230e1a55c680a7f15c3aefb480876e8a66adb52ae2dd7f3afa57ef01a662f66896dd91047187d1d05267f0287443745c02bafa9e3800dd215a4b238064eead7d04f196504501d3b9138acb8465a670a30721c9b1b0d5aa9b9b7f74424f39687a44c9d7c185807b6f24f770736a18502773109231739de1752255dbd61175c61d5045589cb4016898fc630dda993eca48e37581c7fbc36ca647848b744e4b769433d5c97da8e7167c0ff8e77b46eb33f6b00e83f5f8f2025b360bd2d07c2d644cd7b984475998dd89a6822df7fc22180f097eb90dbf0b8a0b53541fe89955bf6e3754e1589aee21737a49ec5e3c7edca101666de7add7dd34abd941099fc4151f781668f0cab24f609d8a9f0feed12b9f8cc957d33204712febd827c17a9a4b523f4f22a0ae8ac3599938ab0edc66631ba13315471cc88e0b8736db5d85a6ac46c5662f128d207cfdbc58402d62fe59e24312bd58288e0705596f67c393ecf27724cdbef10c820d40dec6290dd950ef06f213fa3f6deb6e7db60a6b9a1807daa6e18494a7167f8296a0f1a7047c3306c883695203ec017605c735c2fcef387ececedd5926325eb70a1dbb54a03228e7b42eee5b0768f4db921d9521d23357d301003aaa743b62af5f5daa57d11a597abfe9ce1268d5098c55fb6853542eca7d5f25b26a3d9570b5694c1881a07bd9870096c6d6fefbeebd083290a65552f0a6552a988d524f186256f5ccf62588e6cf3d8df5e58fc658c3cb199659ef6edbb263f9a3f6738e7f3ff100365776b56ffaf406b6537d03ea94d6332cc6ba52c0625c941aeed8876756a0240056cea8d243e7ad55d2f0c0278159600f1d875ffa30b13fc158e4ca703651cbf2439646cc61bb4d74c030aecc97f0c665ebbb29971b7429f794de1aa43688d323ed6c74dff38294179fbb78c876d1ef94610aa33b0e778a1afef32a675981a3786394cce7f700bd2f610880f230ce7be4bc2f367fc73dbccb102be9e29b60a864547817022842449a8b5b1d2b1989743fa966c4ce3b51e5793b55db55a8318021fa0b19c3fd4284f33a8079ce8addd8754df185ad6cf3ec1f65fa82a2d0f1c7eb2d7cb0dcbad529503c7a0f93f3e9b1ea0a98c801c116405a46c650d5e7980543c1462c19910cbee7116c38b1658f6de8d04e305918ebb180150272ef8dabd8edb8fa8504f4017890d9e50f55b8c1980b2715758a01623fb8b259791c6b496c505879666c0825f40ff5933e7e01b78d1d12c7b28139ed63b9af9b4d22d2b6e371f4b6283b53d8ce2817896d3cad22b9691c1edc5cb7984620eb3321d089016c332c3bc8b84bc6a54cd6ca8437c726a2fc0b5121ecf0480b39bcc70a1ca0a4349d22ac712fcaf0aa545c4a10bea2547aeeac313c08f1a1551683c96205a9938a7d0057eae020d48a55d3e2036aabe0b9ac454b608104fd903a4698d3abbc40f1c0a2ad46627d80ab319b854783460953eddcc53ffab61bdda1bf8bf3825827ef10d1ff767f58d9bc8a4d56553fb294eff0b1733bd16efdf131f37dbbf451d4d43e2bb6a944e1ba3906d60baea89fecfc4b5fd68575e7e08296059f91c7a4ed3e3a1d2e909140f00d06d3a29f5f7a4f13fe97d9cd1ecd6102f6cefd9dd3ac928d5e7d5b88df2456271a46dadb287197ddce199e94bc18020d1b3560a36ce444e063c18b61be176dcd663ce77f21ec89fb7d206d786593811c58774ae038cc4f86bddd9c2f658fad3cfdea8d457f5667283914c3ec878917488bee968c0693f07c5ebbc2a61c561be3ccfa27b8efa3d2bbd3655b639c9dd92bb2619fd73064a24e18d1d2eb2c9c1f77448dd254cc9479b6b02ad2b2fd567aa9f09243e781f60d82f4bfabea04fce93cf92ec0045a06348a0a8fd40ea00ed878acc8d768a8c79433df84e53b4d3145f5489a8261b7ac332b59edec2d6c9c3cb74d02568aa4fe0a8e18b4a1952f15ddd0a3c94d53dad00549deff2c9c2f55d12d9eafc46d32ce0ce1ae647162cbdc19b475b3ece4b730fad3a196e9d91e31bac2fb83bc73fef2ed3cb05962c75e4ab43e89ec939f115645bab5bb70c4ec21c1922df883b2a9aa349a0b08e1e2bfb84275e711c6ff003d8c61f26b5e656c51adac00f4c2993ff1e34669aba6846470ea74b4ea4ef323d57a4a989b8653e8dbdaf330ed05ed8b8b2c00a5ac9d802a6c773b6cc43be1d9a78dfa6231df4739ff690ad30642c9668071146a311c9496473d02fe21931df2c3e3571343d3da4670b2b38b2f35101691a8e04ec91bd57bf9649405e5ed9d0ddfaa3154952b270adf353570dcb05d5d3a56f5c656b1b1c3d8866cceb6b8bb71b07d48d91de95723111ff64890760f27204d6a3d53942af7f0d3a3ed84073bba37caf9303857402f832ddc99f4b551c7bfe4c668670039139bd2fd3d566b1dcbee44ab13eff23322c17ae8e16c27849f894b545e99c13181854606479067740deaf6a47b981443e5537f5cd63436ee59fec4a20d22a35861b6b1f289c055b3c3bc63e6c35b8582df9670f79cc9dfee36c5022fecb26a52b4dcc171d06f3b91dd62252df0538dbe81dcfb3882dc67e5a2d8974b08b4e111deb0677e519fa53b54bcee64aa578927ded4778d87b759d668a72ae05adf62d687817e693a100b47b3b8d9fdd038bfd3e9667e36d3b1756b454578f533e5f7e9e50aad9415e1471b789364130af17e6a0d85f88f6fcd2cd19632021ff0f4c8d85a5b7bbf3c9b9acd735b46828f19dbf7c6d5be015ee7bbbc08a7398fc178cd2ce94ccddd406cf03bd0f8db23a341e4c68642eaf162b5e5c764240d14f26085f7e5e92077cd94e9658fda47496a035bc5b2bfa17272769c9e9ceb20db884edca92fae9439bdd5aa73569e331488abe6c3c77b7de0355d8c743d6ad956a067f3766d60b69336014f34d0db8ab535514dd2c18bc3eee57c6ee9386f75cca4421b1ae60ba9cebbb2901fc6e4d117aa63cc44e34e3a25c8d0ac4f8999ed43b6e692a8fad968c643afd2fba0c17512f2ff04e86e930ab2a9afe067d1c3e768ae11d901073ff73fc528b6e4cb7e02fa217c6647336a87463fa52a45394208e66109b61e313b9cf5929e142a7e20977d051b7ab68351ad22b052c6a4261d5f62757fda27629283d7897928e8863e81ed80ca7b18b7b014eafdd2d69984c90e32e6dc5c05289a11962f90ccb335eedca82ea9739e6a7f4a7385150bba64020d565b8216540e3a50f2f971466b28608f2d6dba65efc9f8729ea34a6e80eb35f2ed2341c72cd5fa0a6f852eeb83c876eb20996605c1a079468cfc56f6a9ed9e7213b384a095292a3968f1af2ab19117d0690d902e74d45e34e39a3bb867f74c56f47e66da1334135da333cf08c2346a79fb66d92b19306e172e17a12ffef6f1a8857f6558634c2e52b886af8a4512b7b105fe1c67b20183a657007d57ca2512e7b30386c0ff83c1295184ed23771260de12130f7d4e21ba3b65a55d257fcde0c2218f7aa7073b2e9329b952fa6dfae991b769cca411b6d11b37b0fe547a4a0a4125b8dacd8ff382311dc9de066f9a56436b07e752230a6e56eff55020f54239bbe3e24004f6d3763ba03480cd546dccebf227e780beb4f8f4eba0fb41069cd400dfc376a1d3b4ebd37aac0ce92da890936706237c088bde710fd1cf54c5fa0880cb4929dcc0becf45e260a3b972ba0d028d59263a5a51255c588d091c6d24517a991cb516dc6e86b882e54bf0f138cb8213968b69b17bee6bdb5c6308325b756971feb33caf9ff17c5070c9fca97b20311d3bd568523be19e5f67a54f7e12adf01cfe4037218d4897f161047e154c2fad626c85df1f5b26d0c70533ba5e3386781f15110a9c318f5ad28d95228b0a8c15c39a67879bbd58d3d9839c9aac178ca5b684e22956b47859b5b29b3b6aded45a50f56370b1b51c2555db72139553552ecfc395e9335feef08dea8df4955d22f7bb97a0f82a23f39ae0812419825a7911dde8802bc8ed95a0d1de9e6774a6b7c971aa74293534fb751d8f68ba6c1ea887032d1b21bb9b675c0afb64c2239394c2f750c6d33fa0fc04d2cb331f12593813e2c71a931614d020420f2cdcdc503f4869bdff2a488c4e2561259880a8fd21dacfebf15dc4172dfd28884d3eb8838f8069caab508053387c23421f4cab04487e90c89d8ad572911ed1a52d2393a264f237d291095501adbd7a0b71957708afd83545b3b3113080b43daf43a6fa58dccb7ba3dd77c17fcb78e6988827eabece7aac0f64210c2c2612b4e87a3f95199bb6c429cd79ad0db454ada49c9045ea5e85d9172110b59438846d81311c2f1b83cbea29250bf9316584ccfbf6164b2d4a8458edd1ed644aab63f51504dbfe417a98ac79a8ffc6e8aea39c97422b80f0feed8b5cd9cf79dc35da8b490664fa604026cc10f52742d91746db4ee5046311de099156ca1588f8c78a05b23b31045a8504bbecb0761101adece629db9ed907c10b9517de9fd843e78c60c5d5720c8287f7d8552e49c58cb2ab20939ac81f2d62f517735e03bde92ca8f132b0d02c798d60e4513e5443e26bbc268dc8f301389caf601089122feb7bdd478037b5059f782e0f77a5bdf389a74d5e5857b3c4cb454fdb6dc43b3cadf300c6ca8163e33174d8aad2af2d5d501994eb07698e3cd3d31f252f87826e6f158edad6d88b8be6f70c04801ed160d1eb3c1a375eaf8d135e7ddcf73310c95b4e0064b8bdd9da1132d97e2c5cca6d240e40891631d7283305de64a3e614fde86e65a8c3cc628c20a2c26ba7a1531c127ff80aef7e00704589606eff6b93cca64258c7bd27c16a09864e545d47bb4860e140de472ec13641e9cccf2aa0525826f92c2304625871f0cff322b1bf0482286c2e871ec777e94c841ec6ee830d609400f03b7e46c1460ccdf6e048807ea969be7158b0bef7529417e9e8b80d66c90502e762282878745cd53b2fbea238ac44db9979034f8d6a5d9a82b62050c0fc5e6b979506693c3044db691fa912d4f3daa99d0ffb3291e47bf60c602c63f84d452413f366bb216ff09807b17cda0f7c80b853579da740630aefc8fcfa8750cf27616a09359b4c81a6cd40b02852221a8fbd9b105f78ff26b5298af51a5edc9d41b4d8f68c350aacc740e0c52cfe14d48c91e6c03777f61f5f35a399b9b7835c1955ac5013071c5bb48faaa38a5bdf3f442fc904085e6b69bdfbe4e98017089ae4b2da2f14bd790ad60b208fc036f278e5f2811f67792fef51806132b792af44afba4a1958e2289a7908af65a718600a2d01020ed17519844da057683e0da00775eae9d9a30a405b248a65c091f450b846951de461f5cf7963d1e77296a7c1d4e7aa7467d32d3384d0c5f19c2368e4329eb25c870040e7c999a4c72ee01600e6cdcbbf5cf3a0649589254f9660b5b644c1a234475b22d7f87cf130feec9e5e5c8531243fd6aee788d25e0b8b61df5896bb154836cc5a04c8deade963bec0065eae56d4aa8bd5b2b95b0620e5a5911224856e7e9f5ce0186da0ab471b98e93a335a0e329ee6562e510e0fd04a0009085094309f191df5236223c400524539fcc977d12770f9d982a6832b78f207c1a4fe31e1cddcd75c53a647478317b5eb1cb94ba5bc119033ac4391795055e2a00f8a86bc299584e02a590b1cdca14ee68ab147682bd0f8a7d260eef0a489d562b4cffc8d1e90587ef6a11ad7bd3c640ce5446225a1a97f197973f8afb21ba7492b8a8ab8c665516a84b70244bfccdadfa41f163fab2b2a80d0afa9c39140c3fd4b94ef3de2129d0904ef948a7ed0c0ffa8929e5d368d1e890ce3f3d40c1ee878ce626c820d927068cda4fb22cd7240d3828695c15cc8952b4b6876f0c16052c02fd68b099a4af904671617adbdf6fff9c5429ca31717f67217477e94cbcb121ebddddd1f108156ab18930c2561a2590b1ed0c89b9b37d1fcdfc924e2b7d5772535a55daaa5f28869ad37231a28d616b0998248a13ddbee0f0da16eca07f95c3d33da3aa034b70905446dcc942151ba6bb8b7990da826849ca33f501385920a15edcac5a6b510a436bd2ee93d30555731decdf747b9b8e8ab1b9a5039df9a176fdf75fc6a75129d7d7e518faeb9fc080ab2fc3502de24a12ebd8f77da2c389d3ecce72715f24ccc43ed94b556d8f844854f19cf24506b286d16932846870015cfd7a46c3f868209ec95279c441e20d6e5aeb8bea76e364b952fc8aa4a49b59f98023ddade2f767ace348b312619e4e6be5e36a4fdadf77d8c954ebc2e2d1455ab1473b2187a0ee607e5700d41c9e1b2221326d74c99b11c5ebdc40d3658596bf4bd08b7b9c8b702f549f4a592fd8ef208768982542e096487752cacf026bf7618c42417a43203a2c721ca3f741b4890785431c78fee7340dd6aea745c756cc36aa7cb445292e306168c90bcdf7d76098cbde519c429bff5f67efec8bedd3a532b312749230e97be92858435b591f9b96d99e4f88821b3e9806d655ac63405a9fb7face111eba0f5fe38ff2ce80a18537b9f4a15e9841fa44997b95cbe4be7bd15e7517b26bebd268c51c9964ce5f2fbf63e54cdecae6f895270354e6b311ef990bf8d13a302cf2be701cae994271a06f16aafc4014b727af35251fcb3aaa45e5c1e78edfb1efb64a26072496113b08da41d10234d6677317ae8b800ff356bda1bdcdbc8b6ddc5dedc8776bd9205298ed67daedc68f70cfc2d5fbcfde58442f8d292891c3a66ad59371136f656a431604bdf5e697d1680f39c0aee8a8a2941b9e463911e64ab68e3ccfc3fa9e28e52439613be17083f87daad6566126a75b74e8c7c2757b23e0d796452389cf7486da94b11ddb5fd842b05c5acfb90933463e140516ce6c6cacea4939b764dc6900dc2d1f887f4851271734277e62e2508fc303f69d4895083d5b85f5ab63cd3e65402b15ee50094b86f82c7dfcecb49bf36aa64767a18474fab677cfd156af0098664d65598c82f3fa222a724c45e579752717ab0028f152ae554faa85deb970d274a555758f0d474e68bc955cbf379721ca4aeea6851648f2338ab9b1e686e139475739ab901ceef0c70756247f5c0c708f9f82645fadd34b492d6bdb07a344be848d5175e5e99204f3fe0fb8b99d934d9eb0e62b5bae43a62905281ae9ed405ed4e93073b01610e866ef260b862a8345c5db6a3865e6db4d2de3264afd2274b43e4bae3ff7d7704919dabcb680030d848841788efaf8bd8ebdd45717b363dee0ba5d7a612e23a9198c957b426ef759ed6ba15b95d65d18836a0795ca75db136da36ab88034a8608fbb5eb60b2329fe64b4f512388a940d609b107d39f34e393aa954b94347d26a2439412c574efb1b58621f20105406cf3312f80660d200ab4300ed08a06224ed050d45fc0eda7ef53a50178d51275c765b5c15a814e3f412cd0a4537a3c928ccb0d75711baa8ae1dfc50abb21c2d78e6739aff6b5ee7f21cdd734015d38aab215c3bccc8cc8e7719eaf188faa2a309fc071e3d8c529068a0f05b9b23004f7b601ac5aa4f7e3a29979f6537a7aada12a0788405567b85203fd7402f8b5622c1e0bb96b5e151061697dddd74310f6b8ddac94fb7e53ca3ca2389d597608b15f3a9ddf8329c03b62a4aa57759d961d55fd7d9b7911d2c34f27b419f31d553a367d704cba0dfda1257cd1611b4ed8609db5c034e660b327f360fe5a17cb72f1f3dccbf7d465d7fc22560c99563c1de2080bd21b5e7e0d0cc608f8ab70503f36dae7df9d60625030978fa4bb816f67b056ee86258007e39abd6260bfa00bb972d439cf8556c01306e5bcfdad06fa2430ae55a80328725ff4567c034d3a8872a5b203d0d9c5a7d8a51037f8901b62a9a54f96a9509423fb76e851da800d7ad813137bc90f0ff124a25e365214bae5c4bb6df605f9d73d84dbc3096ff280f62c18007ad31c0fb94220c939434dfa64d79f0e22dfbcba7eaf97819f890c0e700fbe922277d182a82611ea641180f6a9bc548c0a99213f189dd69a045032cf2e0f29ca4ef2796537cf2bc7b1c98cc29c00c80c41cb9d5b04af133a738ebb4e4fe073df97eb779ff7c45f8609c5ac0eb4dc9d4476c46437cf3ff53009d3bd1c0386005553f2f9a881c37489a4cd8e4d5b47cd9b40ca8712a428dde5f2acc74225b88be10e91daba87b3bd3ee19b8fca91df2fe1e9af6f1ef71a6f0f277f9962cdcca4131e77ce3e85adc75438fea095fe186fd68ea98fc4d16d52c4cf04998b7297300f81e1c4f94cffd7a36276d281f6c4cd06273780a332ee10f5f5d668ed7c5d7a47575e28b21133eee187f37de7818257903098b0df25ee7ece4a6c892d4b34e65cf0f158171ca28fedf67f5baef2b3e5aab8f607779c7a192343566b58b463e14d6db8fd2d938dd94c471f8f2b2bc73c129e15fe9fefa9f1136b264544f7634bb7c7b44ca2ed25f7569e849244504f7672f2a7fb08e7764b6975e8167e71e712fc5aa871d0c21eb7e0dc11d7b83dc0c23e7fbc6b498347edb0486db26019bec6311e4db0423bafcad74224bf546c0457e1746dbf3a46cb4cbe3c74b61334ef055804e7ff2d0f63aeac131cc20d054bf2ddec2c688bf694795e67553faa293e287774215b4978d7e8d91e12c53d816276e1eeaa54a4f366056f329c9953d8b1584adeaad06b2eb396ab99c47b40652b827a3a746c6f06524eec43798921696cdc06d999cd7967b32ed4240d669c4fd2fcb61700d9b66892e1ae1cb4be3c4b98a25d8a5b986510e34edaa6f5b2e00c36bf233f85d93792c6b9925694156e99bf8e593faf3e14507332b7c137bc2e0ececd7ef4dc1e6a074fe919303f77d5ae23b2c9f0cbfa4e82fb189e93006f996d254091c26bab890f8a39252da351099e9491c7b76190f25fb4cf6f7144eb71dee7eb900ce2eb07addf5d7b4c02c1bab1ed62131f496f3fc28d6a80ef31f9dc6469cd294c38035480f9408130496c901b968698e5f086eb0855d2b0fd93c5dc5105aed856783a922c8ee7a0880775de976f513377f9331a8842b6f2e8c2e46878f50eb51a9e3a52b5d5fc41d55912bb64a26e2cf533d7755df1ede7ad91c604d7604ddbf3369e429ee02c638e145e8be840efadf8a0c431fe49dc97777f45f3fb77a08806e09faf8de67ef5b7159c348d80448320640173b270b6a5618023b618a9b8bdd5c77bf57e93df864ac3959a24330f31b9a54cfd6001a8fe9bc89286c04212598f538a9bce201cebdc4188762455ea2c22c45cd2d22d48cab0aa63920903424145ef43f6e8b1b48c0eab4316e3d0e20168d8d885761d65ead0caabc26218a18ed0d80a2f99923847870d2b5b33fab877189c09b0a6bda9ab1ca92b5693c4532b8a808382d890c8c6e1498ca11ea8de277747af52eb05345821ceec4f3f5fc384b4591f407314159a1887b4f4e4faab0143b5683ab89f2f371d4c21c6ad2f2417f67ad667257a8abcc9517bcc8bc08ff1e128c3e115d77328b072a74002a950c0a2a6b78fed9bc6fb96435bccfd545d5370d9a18ce17e5c17332f9f5fd895cf04c01595bf67047a76135dc9c672d41323a3654bc81c2f9a6d1bce7c4c2662ee6e1e7cb20796a0ade9194ffebe8a42def9da4062de27d97da32bad3fec107685f5a733cceb318cc818a0b271b9390d461fb181cd5051c041a32a80e07d42d72b190e04b710d90569f9fb70e54b2bacfe7a6acf2b0bb54d76c3e4b60011946292eea7cefc2b2e1a09dea74f1c28f5db2b337a7cc107f4bc294fc006a0de499655f4326fa3540e46ee9706805b32af6d5d55db7488043bf1a3c17d336abf80a52effd78b8bd9e1a48560abe078880b149aa881aef4be712b60378d2ad91b7c6609cfc47ec39b5b3af618d4369b5dd7c990a6706eb5687887cf0281e20685b14114d57582edd8a0dff03523d6d39c668353ac9eacfc7b1902e777ac5155e1044e9e653db39a6a2fd44fe492fa1b7c4be65ecd1321c0ceb00a9e78d2d88047f43edec5c7c5681e4da8200c72dce0943b30ee5f7424a0ed957554f7209c39690e6aabbf910c6345496b18537934d26eb2dc422bcc8c464dd83852e7c30ae38d19416f735c08fb1c5e68edcfc28939c24fbd26078190ee60f620023ab5d223cbf7e9ec07e94ac322483bbced7d15ad1226488c8c43dc6cb8bc31e30911fa8cfb264a78aaef18820794aaddd3aeebff38dc65c8a2a2fc7e582ed4d59d0995003c25d522568596a90aae7fc5c800810987278b7aa117ff53c7878e4ec76f121a32bef153e65059cca20c2d5874ee3be086122dac0c0377c65bda16e919b6005f0330873240377d4345559c8e46a17704491e8679cb23f96f1382cee33e7614329ca3bc4f41375cb6a05ef0226bb3058fa91bffdddd680ed1104d774ef70e2ed46260eef418b26d507c0cc2c1f6d29225f55a2a4e137ca54c9ac6fa5038952359a57a18201dc50d3656c13eba5907a611cd51ecffabe52bd4f924f8ff072f025dca2dc83fa8fd47decc6be2744298ea0eba6fc82c50066b482de84977bad633d48a85d116c713d3966712c48dc411f4cdae7ed25e4fae4b0ab28bd4237e5f1246c14f356fd04c30632846e964b182dd4839bf277cbd9ee73232a2c28887711f8ad0b9777d2b3bbb133486f6df7e4aaade9fe1634cec33a194336f3cbfe16825918614cb46b1c821c8d3d72eeb54d7416b06acf2ad524259563d107ce835f5e6b81960ac98905d364a2b5e862414b3d08343d48e6e49e6c4273039834af28e31aa64e9eeb4c151f0e41e911b278576c76ce21323568668b875e9a0b9749568b5882db1883eb687909440ed3d25fd14cc072f6da92b7134a183744a292e9a8962d319cc7e9ef56e8023b211a5fcc857341b7eb8480b2ffc5466a8ad2e0422240fcb45682aa4e1624cbe75f0f70cf9c3629b9b9134c31a1c941abf95627debeaa9e0753c4d1f9c33ae57f028d3b3f4bf72b0f32ee76abbce17562dfc5f2c0d91ef68bfc9d836a25ba73b008666991f4a007efee0845b26f1153750921269489db9141daecdce20db833abc880c7909f2ecdfd3cb6fc6ff8a754a0d64ce308ebe84f108a30f795e926c31dbf411f893a3420aa222176a0d70120f5c87df52ae04f2d79b128f439673aac199cf28e3a63ae1dea0ba24f4bbd3187f3d587a99f03cd5c66f9ff486e2dd4f3e08b1717bdcbc458596b4482a0e450b593a4794d1cf68d66e01f47b33e7857760daf744e0a6dfe097b7b32bd1f1e29f9b2d77532d20ecd61504aa37ac9a629140b07202d62c3a3609b6fa95a5c9d7bb5252d175ea349268cd77170e3db8a669f50f352568b104b973017e0f83730b8dc0b59263edc8ce336734c631f49b1295163fc55ba7e1825467fd1b3509a3ed610e18ce009dbbe4175479988b359f57b11de4a064f9f05918eaaea060d5a3b6ada2714bb3d6b721f0708a1b44643b55c2e472f55f75aa0e3e23f30bb8d2f41b00faf986acdef02a7ad8f7460b0f7805c33c9b4ec1dcce68545f219c8e1fc30261277e8d4975adde77d3ad0f93df41065120e4f073a22704f9d330d28cb582df9411ebce9bc3df79964a6f8be48fa41c3e7b35ba16e9cde2d251a03a59e5544c21de650f4e59d42dd509fa40f368957d7211fccffe2304a2f78ffb3e31108a4e30cda1d236643d277cd151544da32ec6530eef36df175dbc19bf5e6f85c6d66001ddeb79358d918951118050fbab81146f575f41347646f4d595bee9d684b177d5261bdfba28df426f28202d48e8c704320f31e12a15878b13f2e46cc4af82390d00bceb471bfc099151fa0dee4dccf83cf6068db1093eff96d644510c3d68542a3197ff1518adf2235f62cfb3f4229648bec8dff6e86085867fc45881e47f8fbd9afcb89fe192d952e1b345e69dda4741c9ace8a4548f496b9cf2f271e7f761c5bec6e7ec2c1547b701704970e8fa9ee010d4daed65e1d576cfab6d66be843e7a32af11147db4e4e2c0b814ea81484998f999324dc5a190395261c6449c58383b7f48c37d28cedcaac6884b2edb705ffecb366a9a6812846c2696e88a986be26199cc1903f44050ee9f1bb7363902f2fb3537ff782b01b45933061f6c9a72b202bd8500adb2da3b9e706a6133384792a223ef5081b9dabbbd22c60f2a954257ca175f83f4dd09600e87ebb70c33cd51405d16f8bf74df12973d98746215ad7d9b7300d3e0c12d7160426a7efbb3b9a5ef2c335cc2be17fce0833e73e6d917fa424617543e110e9625ea4c06c49b56ac7e1a37e3f92e3686a5ad9b6f976eafebbb1a355dbd23b0b5c82f66f0ae924e4a0adcc1c222b6fb9417b13db0556f535dd9b60d545d49bd064e40f81a0f2f6899bc0c48aaf77437c3b0664d5d69479712d41a0e8d9a6551d95c39e5921998e1b84330712afc650fbf0a09fd2cfa4212e7647cc250c8f4c63941ab5c85f9740a26b7b3d2bfedaa67c552057691cc1d6e81cf04c08790c24d38c062acb157c7530cc773588fe0301f283a8d343eb58087edf6be1e4ae98d0b7b30e30ee95c7d5051ed8a0785190e46b02e258c371bed46deedab83707787de8eca4f650d1822a56909983f40db304330f5f711b7fa4a32c6730d4397ace0f9cb134af985ed64b505a1dfe89ff8701eb509126149b00fe26191bfa724f0ed66acc1312986cae835c203b4c8cacbf5c9f91d407bddd8b3a30f1ddff52e0682aadba6adfebe849a1c95515bbae6c1b45b65cc6e111df04ff1372d994e42ab9a81fcdf6121d36589db8ddc7732db1b2378b40bfdac25d714cdc1f2b32d49b3dd1b8bc83c290c2052ce81b03a625861b6cafb3659cf8611d1b39fce51022bc8a31146e4975dd01c0c4e20e8dc58e9334ce1c6eb36e690a005e4b5397312d0223143a4785476abdb6a4991c2f0ce3ddfda46d7a9c0670a3e017c6a9ce863d448325e60d57008d0b0ec4c02ee38514f759b924690f459914b4e215a086362b54e886a63d9dbf65ffc6742d17377847214976b38357c2d432db633b23688efb296b2b82a0a03b63427bf30c8682704fcfd9f4655e78daff73eca958aa0f53ccb549d33a85af35652495e22d97ef5dd6bdcc4fd7c8e5a6b0ed6e7fa223d5735eb6c2d5f3a00bc202b65bf807ef0d143b00e526574f074fc58648f85b0a372ea8af9fd6f50d4834ecdaf7aad8ddffe4801b16652faf5be590bff59cb91b49a6fe5581e215993d00f309238a33a0376582bf8f5323c1b7965d61d07bc479865ec9f606b6574f5a183e4448d4cd4f7bf07b7d973507066ccc23648df465519b4dfaf4534038d624c8b42e6e76fb57f3bc6a9c15116d3c1fc2f660e64ee628c7b2729d1baabfa473750ea82a24a83a4925b24a26f2b58a03f202b5a89d772729452e660e0d734798437be03ece6770b63f71aa88eb3148df63f25d7a6b8e8de1df518f4b9cf72b502ba48282f1693601e2ba05b4c458130b0cbfe1524e6f2dc1ba484122728b2e4fb997548f2b67a88c0c81b4370cf73edeae1a5fa4e3bb58aebd447628b0d4420b1832f1ecf32c03665804467bef559aef17335f1ff844c484fed3ffb1c762839a09ce818074492a9905017cc15608059f5e8f940b86ea800ce639b5509eece6d9586b55aa50d95391ed37c5b2bae617ba7ad9fcf6e466ebd9f5640037ba0251cd02852e290cd84e0822adeb84c2c1f364fec020ae8dcb7023ef5a835d61006fd35f01cb77cc34029293049161570c685a90acb0902b648c3c66f8e4d9c0b24a943113b8e073db0053580e153c11a7ae6fde264fc6987ca1d3ba742147f9c7ca98a372e30d53f905c09de2a4c687a13ef4eb4e4851a01514954f45a1fdcc8d36d722aef3b213af400fa33b358aafbb7eefec74337f31c889b01ce1c40c428e633c6872b258937e45154f41d81404968fb3d77d0c7931b319e92a93702f763c05d3f7f5faa1c12b2429660b46f52ce824cf40be38b1d0b28e6dc1f9e40dc525f6008aebe14fc902369e91a7c545fc550ec59cd4a829681d64f6068fb4fbd53fbce1b04dd43f6fd076af2b026e69672fb475967685ea9920bf8572e584cab29fd377dfbe47cc6bfcef0f3bdf206af362ad0b57324953d515e1623d9e0349a3af1c4e4a609e833704d6fe64b5bbbb97ad89253d9f245fa5d2e7a4aecd5e8debcd8969b05c5ff0cf6bb24e6ec5abd5f1fda31e56a244b3a79be2e4a2219c12c4c46f27becf453b4fb89c71895b84bb03c994b6cdcaed001e27a4a59d952c07f598b770b0cb418b1da287ebc1154d2469cc3a31d611c6fd6e83e79c97213cd2e3e8dd5c8cb7c2c10669187794f59792b21ada8d29c630020b99c6f0b249dd5a3192342b4acd8d12bad3c9806c9d2c638103ac5b9c860448ff53e795ab3d9ac3e6a00da8c56d5d6048c35f7c150513d4a113681acc4fde8ff99e9513c6cfe939b32957d947d23432755218d4875bda2a3c2331c58ff67a4db20c098bd9bb7faf50ef29eb394894d890a5cae3a257b608a6f0ef8ab455df4573517541a12bbe093eb42c823638102769067beabd4deb43e0bb9bfa641f1c40cdb00da235c5b7c7789771be2c966b5b1d9487eb0d1b1640922e79395a6d53b7e7501e445f31376225b60a7854c395fe0e27d2a134302b2705689d6a1d955e7c955f149aaf4dc1e3a0ab5d9bf7b381eb1636171c1da4c18a814f06742c5a24e72cc7280dc92d0140b754feee8e055a7bac7b7e6124e310ea93917c5f4ca97a80e961a1e2005fa1917e9cebd9503d97d99f4d10fe435459b0f2f48c6578eb05b3d63acf50ec6d497d2f0de629b325b884d75111d4f4142ab21635878a43db9e6cbf70addc9dcfc37d638c470a87baf1478a0351baa8607a68cdbc67fccd829d86c526bf9771a3623a6242a6a5cf02b512da3e13249892e8f0692617c4997a59fa956df6cbe97e80ebabd908e4836bf190b1c7642b6d83db75c2ae044bf75a9996c3d20a70b5ffd35ff9b6eb078d1f31cfbe0246622668b948d5c95355952419c991621a4a4c5934c911021c7e588bc7e5e75b1913abd78b695fcf977dc1426a1be64d2343f977a1e6327df29d8afc82eff2399b6929ccd41d5282c56eb9d3f56ebbbbe6517e57345faa25b1be8be1134d3d83a78fc79d12af81faf8d88dbe39731f4e7ded66432941ef70cea214169466e3a4dafaa09dafbd09df7eace0f72c152465226c2dc6dd639b18530a638e55cebe545d5fbc8c65dd19a9ecb6faaafcea5220411610697124933efb20d4151dc51a0d863d3688d037614cef52192bc829885f3426039338ad1d4c036250b9e4657632eb0a0a71ed51c3f0326046c21c4124847f8ace90483709757f815c349d32bfd387258c2ac71c9fec735f7fe8ab03665d7308d59dc72b599ddcc025c250ed2fe8698db08eb01ad14bb121ee4560ec620b125e5fd77354d6d1ccdb5209778f59c0ed2e69ec4ae97a56cdcd5d0ae5d3387e7d0fbd75ce1e11e4ff7a1a34aa99b5ee421126b7c1ce302904bf37e3d6d6db7a2395e52d39faa305ab2bf433543b96efdf0b485985dacf41fabcdf1bb850c0099f0ada1a2e3fc17ab181e8ff53360dd0b6cd5c3b183139b9191c1183bf7803b2029ac9b8fff273717b3d7f0891a4ae2cc13562b8412c54462d5e9e2f081fb2c198cc3cf02d1ec15e6a158c23f331bf3473c7dd53b45f3677c5dd01d740256f8a5e2974c281f8c157ced8ce99b82950a4dd0739ca37a09e76b51bfcf0133ae979cc0b43d1b61d78b57e82ff10987aa11f4cd795bd50e3379938430e8ed969cd245c3bed108822875bfa3bbfb9510cb3504775d920d84c0e144d205f76129117434b4770a70b67188d941bf537b2ed2df1184c1f895640f32e21a69cef6ec779b667cbca252116b68855506f3045499f1c1cb25bb578c7d9882e985120d162a1f37064dcd88b3d9f14b3f14b3efdfc4a16e32a201f3b8d60fa547382278441e687483dd737ab7e9637a704ccbbbdbfefee3354c47aac2376e4c396f95dfbbfc50d9e79774a236b00ae908e27ab3062c4f2c4f187665b97f61ec53434e1be6e0310d9d4d49e41f7b20724eeebc3823d8b8edae569ae869cd3532ca4eed3492dcba92d3642a195c5ac87d28e6d0a0e07be52890ea5fc03101128a411315fa65afad15ad83c8718a33befd6deb2b3a9e0a348ed8ab67201262efbe2c289d0530b366b3b17650988b48ee27e57172e1e1d4368c7144450de87929b6bb54e02fc19441e8a642b0613318e03537c4abf5391b5cece14fcc2e0ee627f6f08175b0cce0e6cc12f7cc7c9600ef257c149573a8817348bbfaf4a627700a6831f447aa72b7733391da1cf39a224a85ae10ab2a4d8b288e11b7e7d981a79f1ef249a064a989b071ec1be36ee403ab36aecd6cf6b70382ffbdbff488cf58c9abb7a0f21ca87272bfc204facb73748b13f292859bf0489ad68c649e4ec50c409a503f71391498b4b8f643394ddbbe40d94634c86350fd000589490c8fd3a0f831316f8cecef33fc6c12d88d501f989b6b49f69b2fa8b574ee44726e96b67cb8f889491351c87a562fcd6b78a2d230d5b7a5111cf13a95ccad210935258fd6cd4288a2cd9b3e80431305b6bf9aa32160ddd3e2ed13b4516a96048914852e2bbd83dfbdb03c93ab8fe84ad53885c8286e7b6dd85d2d3c0da3df11e39a7e89957cc766d2dc9cb086a21a8d3c29d3186992d6b4981e15125bc185c428be470cf644d7048e6435b8fcd62bd4ed451e9d277dc616b67c9f1292d00ecd4c71c8c56928e0f5fc8fa121a9bc5b51aa5ea7fbc73793825831ad1ddff7f35ca7759b9bf60da5f4f69e37a0f6171bb87d1cd4a7bcf7730f37cb715ac83661b019a62b84a5ab3443c958933f7b09c5edfe51cea98fe4483d831c53a99d384bec3e8ecbefdceb56fa4cb60650e6ea6c20e57237c2c2df2524d05723be77896f3a9a2f7c51b3dc36bf5de2de2abb50819890da8510ce836238958ec4abe1c7c61ac2135aaaf3defe04522f30591445f4f998bd3607fb6c83826736063ab0a7978cd31e3b98b5541544e854c9fd41532560cc4bd1114a1f21d1b391045844e7ac5ce45f115234cbc24c3c6ea45bf9b590533e71d76af1dadf39c0222d370f78a7db0ce174d528ed49f8c6a5664fabfc543b64c4f0085ef3ebd7c52c18d5d7fba64f3692390f776064f40d37c5596758d6319665302a2f8fb7fa21924bd1e888c47ef1ad49299ad52177557d778d4e1596e607f91ac10ec2fd6c8f1e2800202d72ec6f372ad0de701a87e19f4a21ab788c885ecd6c94a560d74fb70c132386fd6163878cade7db70115ed08068955a17ed8d0c58c341b291e28c500bd246fd63b9c3f9e648df79e7994b5a1ec3af5280bb89603857e960f999b04346506721740cd026bdd90aa0d1e4c01841ed22c3193570e02a05ed575e37f78bc8e8c6e69926d2e9f20d358c021284f49480ff458c84e6ab78785b77e4b0133c8c924bbdc60fb103e824448342cf39e0250f3ce5b329fc09217f62bb25ef59d9940a26c4bdc1b86c9d7379a41a3b5cdc7b4999988fbc9bff17436b03dfac6413ff0ba751f55426310a6951eb39fb082ebfd6746136e7f8f7cd3da744860d4270b41b71adadf56dd96e915aabe79786ff5cdc23da5d53d3b8db99edfad17a5df77fa1e28c55c14591fbb088b558bad9e48c525236ca548d4fa807e417cc1f7708dabf6165cb0a810ec29c3872a8f24ea9f9e563b7894209b13306120164bb8bf6fd0e43dc55d6ab804bd817d9a9891511ba202bbdc85fae7db3970fb318698f3dfb9007c9463c9f4f0d8e88c9d21b407dcb7211a7448ea413514029dd6017c9395639ef0fb00fe46306944e92224d19e22701e42dca5ca62c8f5a53b8ec1ce7550332c3269c26e6ce5765dd09a8a3b492c427f3fc42545a8184c55a426ca34a8c3c99658c1e0233e5a459cafee94215e82a347c4c4dfa39ebed0b6a1cd0918194b4ffb1f3800b9952b77058dd26bb9f60c7538c2645128cf9dbd8ebc853ea1f8243938c4350b23409a8162ff4ef4b4c7ba41dfa326656b0468718b1f670c5096160f1998dc6a3c3e3a0885a64738b2d4d489f93896d44ef6eec7c475dc63adeaf93a790808102255eacd9f6ffcc2d9359acbac0bdf167ac6fc2e31c52668a92e75462bd56ef11c5531f8fabcc135c79b0b27171b5ca11160452a51784c2aa92e2480294cb11d2522d9398cca56945a2e396e3e3271103ad44f011d38dadc7fc915e3baaa4a41ff285f356d93860902a12c8401be84229356bc7c055edebb212383ce951cc0bf90840809aaf94bb852bb3b74e3a38f3c1f9406a2f9ed9fdece326067cd1b6c80f3cbef16f116f9d292d4a212b6471faa9b40ac3551ef7c376953b71ed14cb08fe72b0b6e02fbae2670b13ee71b849b609d3f55c61f9a1d1917c5c963b00ddde5457c561826235488542c61523c719086e03d7baff8af631a036fdf6618594cfb56d1eb516723029aee4bd813e803334404169d69c4849de21d334ad31e085cc591f920b243f0dc45ad7f908518aeb03a0cc59894df199709066b90c0472751","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
