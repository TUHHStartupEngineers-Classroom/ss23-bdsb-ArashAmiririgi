<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"887b526a456d4e6b669c3579be1cab3b28802f008b5a827f7531dce2469edea03486284fd42d104c9deacf9efae10e5b946d6a5e96505544c0706aafe8b032e822f014cbfa4a2655a4cfe23ef367e3391f8b36305d9ecdfadd732cdc0d3c8c8215132ee37003b848f3fdf4fafcf2cff70e60789b71576b19e57ffacb05b61530108bec28cf0bd0cae27dff9bf1e063111e8fe33c76403beb559e07b4916936ff287b7ff5a5c67280c8e6cf0d806cda75af6e4c520e974b1fce23c86d3ca78cced7df2f5a31707591067693fe9598f028b5b964b5dcd205545610128c246c8a3ccedf37096dea659e0c36838ebcd27ea1625be4c857d015e66a3150cbb00656101e6236cd4a8a2f3d5731447742854a5566eab8992dcaf0d3ee102066bddfb0829de828cf7ae917a14c8f5647df1d337c9022edc6e1e82fe16a33674dc09b37e95f2797e41843bec977e44e7753bb14a88acb32449a9dccb7486c664f0432b5575c818c87ef200806ee8f0c15254946822ac0f2d17833f8f832fc6116c1b0ac4212ed1384599ed7dbd456eda03973b137b62c7b71189746267169f8e322aecef7aabc89d142e5c11f72a2e42ce0b1d4bc7ace731d653107c195288dd09484991af57077452f0f25fff6be19e519cc7b026e1c4a1d1839484fd8a23cbde908c830be36c55291da68ff7e88265e443dd5011e68b2505e4d728575569b67d86c999eea873aa2185fd781ebccc8e92358b89aad3dfb88b64c0a01fb96f932ed1de89c109514f8f8e6e4b7382f070f0a1ddc51a1bd7e2032ecde695c59107820a4cf8239056000604af1e7c9bb46b08cbf26991ad622355567e80f8991f3e5cc4dc14225f98e657a1e8b11a853dd54f98d13064936e0c0f4ce74ef3f9acfc21a4b68ed8ba24cab5af725f78ae568e07006c8147276d41540efb4541ca04836710b639a4a7a4a1c54af16684e70e47263251cfd91264324b1d126c8f2b02e3bd08cfcc0280d8a6d6618b815bc8b40bb289e928cb8743d9d946ad9d0147a141d85520af99f1c992cf4b735d1feb2dfbdcb8ba81ec3e6c0c57e2205eb9142ff2a4a7e6731aa6870b5e2f6bb114634e2e2da7914bba0b5582d582ef7f2d8f8a7453386c616601e45fa103b20178ee948212efb965143443408711b30c60aec61a4a90465be71d790f4e572085e9b49b0f7bb9a3d12aa57a190571e63a19bc523fa00b8855c5db7538b028261715e7cdf1be43eca02c9d8aa07ea999534000e29b9df4e7ff4d9ba100b397d391447121a5a1cf88d6f12a278047a54d187bc278efdd433deaf2b1f7de827688e578c2bee16904cb52a1752d0e06d5d2d4ad5f7dde2e87fa49b6a8f2baf9f5e6d250103dfb07450b3f073294976f002b7ecbc15ccaac2bd53a948c251f6c173d69ea89e1a3038762791c20d5d5fd8a4b661252026d354e5f853af87de9c15131e7f1c4aab889f61278eeaff58f1e78402f1bcf0a3b8a0e51bc764ffb647b2152b9dfa70103dafde5ed0aae8d4d54f113b21faf2438c72f0d735a83cdc70fceeb8bdbeb45efc2300795361663acc597c4193713ac03c9b2bda64cf2fe665e85fae6a720a7e9dad256b25b11e6f6fdf3a98e40542d1cc330f10a4564be93c81d83e6abf3ec109b180fde9ff5dd5ddca930fdd3183400bf4c8255e70b08e890f88fd971fcb84db35b837d158cd9ca3e1ed71e9a5f25aa83377f13806b4661bc08d006c977eea4641024121486fe7c60be130a08c22ece674dffb0060d0eaa25b57491ecb8d88a073cdd6e8c3a928687ffd112c755e383319336e6a41414132bc5b672298587e5bd52ed6b489d5a49132a2720dcb9e6c95ffa23cac225fc7d1292bc4197618fb47aaa34bb6159e145833877e6fc5ec075d9ba929963f09972ec77aa8b38443850ee7ba19b54142ef6fb9e606c49312c806ee5a93a032816f61432a6b3bb5b5a6e1ae1e5ea5afdffc1f12c459792a0b59ec207ae81c2809bee5985abf9c5a945959253af0fddb4731462759617190cf5f8e6806d9bde8f875101faa5fa614078b079f6e255d33539da862eb93f6e3c5974f8f34bff647936d4de133730ab42d52e5743fd667470c62e185c762f3cdf517ba5517bd6c22ac5e1b8ca883c1e2be9396e795c6b0708b6f39d5fe4c219b48c92848444760488d32b1ce3c6767928531c9e18170713f2ca2e3753399fbcfa9dc8d837f127dc4c051d186e3cdbed848f32cbbc2e6498bc44a94930e50634031284c40b85cdcf0e906d449e389c9ad648096388f160be8bb10c5c2d1fe6bb4e10a28be471be6761867a2796345f240c69d54ad0a41105a8b71654ce94d13b83ff767109be5e9297d69cf73d395bbcfff2cdb6b6a73a904ede8d4b3a1a45d2fd4eb902043d24b8c36a8d6c05914f1823a21ffbafb3c6810fcced2dc58bcd6053646acce25d7fc51cec666e980bd06778c76465c85215ff2cade703ee096e7d1102d6c60b600f1331ef622561cf6fc5ca20b90a27301ba02fdcb2a3d5d0c7e948c1cb5e93e97a639768039f578e6474c0888c411677540cdf98ad5d1fdc42ac2390eed9b5c7c050bbdc3ce415c8772a6a0ffed636582052885eae84017af3ab1e3f2e94af999dd2c2341c4a57d8526c82db22df8e920748a4b8229a4b9f3dc1894b79b9efdbffbf24d8de59ba319c0db8c03f1a5bd576bb8954065a2666412ef8e231070bb9907c6501603dbc090cf9dd8e4786019ce479ebb5f9ce4cd02086f7823ed4d7371aacd8e1351cc2f1d0ca39288ff57b301530816383090c3ffb6c56e0b31107aedb5cefeed54a289e72e1a55d36b5799b0651b3362fa1b918d6954b937f5cec727e04e2d6d362fb3a545f3d4945c451dd9524f7f25ba2a14bd44e141d253093605605810b024684352138aebef7d2f8daffba0d9aa37246024c41f2ff5264d0820824b1c7c1016e1c11a34fa692687eb3553e1ebd05eddeb51b3a05524611367a0ce12b15d449372a4b37018f69d02e69fb3f71329c43b3ed8850ede277b28747086bdb3d18357c5ad8dbc6499cd8f88eaa6ccd0c84193161b85eeed02b0158ac91b0f311771af53fcdcad1497b8d9ddd53bf768d3555f12cff1c93763dd0983af6f4c127d4eede013865b87eb4027557fd7a1a1f58986f8973897dee86974a53625d9e29495a639352371a7c720785c4d0d7e82f69578c4eae069b505c81e675331e2c2f87ff2a4d483ddefa482a6922e352a679423538ea90d8f9206bd5b47ea602b657c96f2cc0b451ada51ad2c0107efcc7af1b06afb767b568cd1e8d8079e75bbeb837acd00016c1cfd2ddd776a74128c89830b12af02332063d6a216ce14303fea1e3c6459df5da4d7004616fdfeea9587db04c37e6d01f801922051f86b60cff00298de7fb61b369eab912a64150dfccce19625aafe3c9f5370c322ce1d39a75a30a128b298d4f90e2348b3a8b9e7aa6542f16fd1c3c7cda1ed683110fb4513303e0b6da841efc223d1c6f1024134a9273c79f4fe34cd975a35d50e0791178b8afb49f8685c8520546fc16bcd06ba3df6dda27cbddd6081a86999c3acc6d83dfa80fa7118c6a97dcf7de87adea90a118d550b2cb3d6c22ea1e76ddeb168a6019332643a231b209e48995d00152795e602ea4cd77c6b305c17a8936f7c60acf434308dd1bb3e40af034832b44bf80ddfefe44b476503afe7f5f49cd71b7392b89abe342c39e2311e8154bd025b9d18c280237dac5f7be7f7478d152c1f7695f93e04f2657c994784114a80aee23c6c244dd3209161e58e85337dbd48287d8cfde245a6ac4716e964f27b7bbcb71757d227947b6c5b38b78651061586a525312036409f2d14ecdbd6f4a7dadd941c21f7d6a7ac0e48b8f6e3ac84ecbfbc0da9fa262b32f03d53dbd79aafa22c8cc557afeb0ac843b96f560b4449b6339c8f99d8075e71e7828b5d14162c2b5bb3288023662c77ad620e1a153311144e3f8f4c116ef1a6ee1b1f338274963f11d64a56fb4712e769caf7cd5496c24c5f9ff0e58d7ac088ea4b2448126efb85621913cb0894c5b992c1b0ff3fcabf3ab821d95af49fea497cabd502649a79ae631f11f8e0182523b438854ea94b2e51a5e1f02d20cd3773035d4fddf439ff4fb9d11451407255c0e8de0d3c7967fd082dcb16e934defba46b02ab6c62453e9ae3c5ae26255af0fcd28c0b3238a3ab4a017cc58002309b1d683ed3ea24771ecf63e807c42fa0a252ef2e37e45cd9f2bcb15304fc6e26210f611c788374bf736d272000f08b6bd25bfcb7758de45cf4b319dc990f97b01c436edc91188ceeca043baa85d8b295a34e11e297aa850d6b013b1be394b4b35b0088a70e74ed9f8583f354cb676f70561296710e97dd150113aa0ddbe6da635aeac9bf7dea8649374aefe092c9b7d9586c0bff5ab5e655cdc6c663de7abf7bd999d113e19b647502b53fdadaa9d4f3d07e89587701a65b603e689139cbe88d8bb57de86e3ed3b82f534de6dfbf5dea2d0e61b8dd3763b7c776542f485f81634223573a9d7addedd1e689429070b2c8dc51f7ba635b50ffa2ffbde13bbc7b1e5c6064a6952f5beee10f0ffa009770370a66eb5a5b9341b2013b4f13410e7d4f3c460fddda0494350a7321ec1c3ffb7c1da3b6d97778c8c938f1cc4dc1a5886b71d54cfa06eaeedf72c57294f708b51e4a5210b8ed88b37debfde2527267803cdc5c064be13a0259ceba2f6c24269f7cd43ed981c75e8fc0277d0aca155088b1f1246badbf5fd91dcf98e9fadeecfc9f63ea5294a8a588e449529c9d69f755d88fd98f88c5ebbf6e85354a3edc24218672e78c7b2d64b282df3d0311d9c709b2ae8368395793f58dd524292253f86c16143a61357fa58b5c8bc8db50e2da56ed638f06e8edd7e4052d83e0220f2663d50fa46d46a22f814f7c15a6461d989614623fe97111025487aa88dbd02edb1cea2a7e2260d766e05a02caea3b57746a1bd6b5103772836db5ac595f4e8dfe31b90b5e125cf865829d6fb0a02fe5455d413697177f88e409e6188862ea6906425c647ef7ee676a7a818a265ea319cde9806b5d6096b5ab0fa9f8a9faaee15e2489c45bd21789e6b8d173c40c87216a3cfdffc59efcfc587e3ff554b7ddbaf510ae8e3e05f65f5cf596bf9ac82055b7f98aa1c4109be12e00447e6d0bb1faf187352c02b7e456beb661a1ac3dd20b1ce189d69c0cfd67938693e277b6e45dd773e14b67850599af0c83e5f16ec6934fa901a940d4ebb8f74b08baff4c1ade2360e544ab4cf953f42bfbd7759f66e0c0079ede9b5bbe93f3b07671fc4bc9551531eb277a6c564644810a0516637eb9da7a939e735faf9ed4a117dd4a9899e368080f0ae9f7819841b7a2d60b5ff9536f4e13a65541a10862d2dd2beb3196373aea418e741a089c9409d77173f0628885a28241b8829efaf8a726edb68d9e141cd7f2c0014aeb70dbfb8c747dc66b991b647ed9d206d69b4b7927548dab2b4a4d65f9e5bd200c7685dedb7121428193c7d296f046b0e056203d8ff83ac9213e9888605d7c33ce42e7db30590fca3e38d28b0926a97b3f4287a5567afef13c6f8e89fce6640a52bdbb2abc6b1648755aad1ece5a1cfdc7cdc719e268ff5b883134baa4ebaaa9fbf19ed6e51cce9c086e9e7d2601525edd342fc724fca3e4f46ebab11d311cb40f86b2336d457b10bcc687c157602fc67e3945395371cf96f012fa3899fe1020df52e480e718f8535cccc0634ad045655f9652e2b895cd00543f24599fc085b2879bedb435417d6eed3f6de1ab29482ab8a3caf7888c511d1b29d9b91813f43450f71f2f6ea663a444612746dcdd5b83ad672a940e9007fed1d21802cad862e35be020da0cb304706f19f32adecd44cb75877ef85db2a4327ce720aba18b89052e602364e3897d2ecd5acfee23b283f52bc7b020676eaf704911e5d62e7e9e745beadec82245c9f3ea6ab60c9cee21c8627fcaffe48379f011dc54d4eb1e8b75b4694087e546876f81de6d28871e53c0475e0a9ebf6b6b08adb358660bd537cf933feb1d3cbe0b0ddf51640ff218eb29a478e669fb3244d75701d63734a8e77e0e08a6e308510c08f30cebdde4b08fa5f26d77119d7e54622d46c9f983c2847358dbf9e82330a577f7a67cd1579cc9eaac57af85beb1305e9d117d8f7adce6c345317fbf7093f70e870e202f069075445f08c704f6851f7b13e93ee40ca603b5b1399fbfadd4eb6ff8f1ef484201bc1416985d5b3c053087d494595bcf1280591bc80f009c03f40329a4bdc5ba9a4ea7b4884dedcb40e25f77b9db1ed94069c005e30e0cc305321c58356aeab167613718e0cd3a3fe45fcc7f5428e33575292db3d343c61cd5287ffee63625e110b5f781df29f6fee43877212042beabeed7f5c425cd56990c35569958356de13ddc7df7d0af10521d20418bf480d50efa41a43be963f3e77964210a7d16ef455af7fbfb5fcde10218bc1be4cc795c4e344cd5c38782b25201e755271ef496d2f58e70aee35c5131e0dbe59291c92eb26ed1cbb4b2424559746b2efa3e042cab49aeb2fd03b1d839fc916b13d9f3f6137d9826ed11b7a9bcf598e485f28802eb6ddd5b928d4cdb68bf0b544c4d865641f0bc0fb406baa4aca63a094e7b416d2f7fc02b77c8c15e915bcd0f67099be60c3732e2d43f9cc532837e417912605b2124cf2b9c185bc69ae648ad77225df37ed3e5037829dd4c472aba6f22266c3175f9db7160f9321799d77b9667020155cefa5186ab92200b44eeb68badc55105235d0b34bca490cddc38533d2817680dfbf131f273e8e14025c546cc5edc828ac0e5f573b1c7074c656c746a04832fccbd8de4793c81d1918c5ce24275456098be9009cb4c9f1bdfc7b345f989b9b92b5f8a52d6323b3395a565bc70e4b5acdf06129309277549175540953623aea25dc63c4639e15d93c32a464c6511d1ca4b912221263e5f9ca5f3cff6402f725045b5642bc1f35fdadacdaf45b2f306a2ddaf91c4a6e81c6e025805e524542401b65cc3a5384adc2c9775202fe29ae5739ab24e2065f22727ad58da86b9dac8b4259c16c05964f4c7fc8bbdf2c9895a81c1b64efc103f1a6ed8b78cd355714527320a4890b2dffe159f2e23b8471d80ace3c1058543a0221be3384dc686fbca9968a13754fd5f51f8bc0a5dc2f6593ae902002e7de4e4794885add50dabe018e3b6d12dbc932b6d2188ce4731561b8e52675676ba8c1ae7a44dcbcdfcd547d03f09cff200718fdc79bbddffaed4a945188d8a71e786c77e7acbd89ea3018e6eff804d27eab4aed47e1cbe84f86bf6544c91501c106cb1f16da50d38a5e9ee2af33619128dccfc5f19fd20f1fa1f31b6c7a24a0163346f0f5ca83ae64174fdcd6c44fb56eab9a3adb8d9180c32ed415a6d30e7aeea7ed0841b038614afa9f9009494d1d8812d46d145ab98a52a67579a7238df4e27ee985aba7e567370d4f01ae1486c930c2ccc3655739231d1d544c87882676fe7270071d11ea4476a28b08410647e98b226185ea55e9ab19850f1c20ec05961a000b03ae696db9b921d34549e358596697b796ae6fd3675afa222ae7a6336f72d569fcb6016c12f0007368da5d4c9877801c71fdfbbe41d2f19a19ed7b8a739fb7458ae6a03317cfeaa47585c232c5048eb852bf69aa2b1dbd76f04515af27cac3d3895a1eea8715e4e41f6158a178935777acf9b3dd193afa53fe2d2841215a9c890cde14afdf656988a42bf31e8f5c30402bfe80cd6cd51f837634f52ae51d37f73b98cceddbab17413f3bcd715c88bc0873e785704e64a1c76743cf9eedd9d87853479124b51ed54b819bacf4b77bcd24cb41989c5663932114f7130c2a47ca482c57ce20b5aa08c386f7dd2b3819cfd16c525e8ae3ea366d79efe616db0e58e05360b06d95685e34f794bbffcc68ddeb6b0810e40fc2f33f1949e1326ecca2cbfa5b5bb14f4064ca75a992034fa1f8bb58ade484b93ea971aa3fd3aedb00df4fb8ef20074fa670286ff105d5d7dd2d93d766d153bb7bd53266b18adf6e2fc2c65f38c6c6fb7d00375fbddf7e7d551a12d01b1e4d0f066c1e02b7c3abea84136e351f237303da29bdaf563d82660d9358d565939aa5c180d3b9adaae63c4cbb4e90aec571ee6614b15bdfef89a84b4c86d483be4e3b6404d06ce0a2b35cbdea51f11f20c832f45459fe03740439fbe09bd21b2adc86fed7ff8db1cac43b7924859046ad5d5dceff66c95d5b5deeb81eff56ba8bb4589f1581cc0d6efb9fef1887178e7523c0565fa90625774fad8689ca40af17c6e57a5748af513e552edc31e13c45aa3e810e347059f04c1ba2c7a35d98cdde8fa3d4c5b83fa2936ac0e2684ac190e7769a5d975c0e57ced1cdd5c637d5eb73733503e8e0985b1e1ff557671e5f52a7d8b0715952ca9c7e2780e6b0417f41cd53c650b6f16ddbdf35f51cbc6bb5dfda1967f3af541afa57b5bb13c050eb2560256f50999ffe6e84b40f8db8d1e31fd9c8b1f876770960f240731a1c8a27bb612c042d177ccb4069d6ded301a576d14d51e82ab1290246e61d7206d6f60438763372b5493160642124f179abee5726acdf46ac175ed39c3ea01b1a9c4a9cc973e3b3013adb534439b76e55766d607dfd3d0592403428fc344ffae3ca1469ef1d7ad32a4c7852d2e55a4cd6cb023555409de6b544c85d3f357f2e6124ca89695cb970e258a00472c04d0eb3be19f278d29c748e2fd19db4dc0847d499e9ed74c4f0d893605a5eb4fded230cea8a210ce708706cce3c7d73cd3f69e49bae792a8fd1e9adc45d51fe20f8cdb0d33ffb6147a615235d8d26891c7952039e580694fa9b98d0f387c48d2a109fcfd0c9a7ad72ce75ac08423f5a5eaafafd966d7606ce3192d5883d25967cf97d61bcff222183755e76fb8520813bfa76743cebd8d81d8cecc763d214d60ecd0f89c6adf748f39b8d9ddf245567db5f7c4bd60b73e5c4df37c97c8a0b9fcd8472674fefb71819e502648969f3453f0a991343f9250682315e34d1b4e5b8c746564ccbc2c85b689ebd9697b48b16becbae64a89a540f4bd6e75b7741b0d3d3a1884ec99e4230d80ad0a1bbcd2f39978522351b7554376e77688b81de4fc27a5001a68dfc0250319f97117dbf162f17cb178e5dd7636014fe4ffbcdf0a2ee41cffa32a1552ccc8f23bb4615978af41b189948907779557a663a688d63ab3212999bbb6a1e3a0ed87ec00f192934679f29a5e8bc9223a58c58c71bd670351df28c53cd5be9078e15f70f723e842d83face090713143d17537379eac862052a1a11ada2254605edec0eda209effd6ca581943707b476cf8f7e49430bbdb3fb2df250181f6be643e49afe6f75011421434f1655e67349d09dbae81586a9ba8e291afb4253461e27152b564d8f166d0530c3d67837c40f9c0434f82740507d12b9d390345fff3ceef1eb5caa86dd3fc38c3ced3966274b0bdfecd04aa8190405e0f488c122d83ea82c0a5f28f03f776ccad3226224a0971055bc21c67b588f0400589939f3237149099cc125b37316838075a74d098f0e87a2ebf9589fd5d3d4ae313a32fc8f5bd6b301e374b120578ac33cc4c4b0783fd042e657093cb92667ab48a11b90dd93c68d9df9e3742b75c8b4ec7fccf598b7ef2a4b37a2c709c14a3370eb483a668f10f18169456156623cb654ebc9510580a470f26700e47cd50073023ba37cc583c50433aa38db10a6444dba04d050388d08d762d924e9bfde16e3000a8634598a6a20f2d41638e67ba646e77412860f8e987c0cf637643d4a3ebe4f32e455d9e88275e5b89816c1df8b16ca68f32621ee41bad5fabcc1bacd7bcc123d3a7e0652fe1aeb54a5e4df357b45c2d168376fc4a368e2bcd94066c2de308d6cac790d646558271fdbab22a0b073b43299c2e5f8ccab7a8c21d3279e65dceab4c682d7363f2585bcef65b28e7b46ceeca93c256c37b21bbc9bdfeb7558718c992d1aa9f975a271571e1cc3097bb6afa0cae78cda10c8b5e16ebcca4820d7f0b7d785cb28a1a6349e83d231808205948388faf260319d7de45505506bbd3786cd31c9d4cac45691bdc79903046e5e0e01d0b6e7514c360e5aee677aa3ea41f6b262f852b0a5edf2ee7ab59141d4af673485ffe2268b29e23d9f9243222f4cca8bd5a16a6a0ea6c370abc1586130503a78187c9aa6529cd46fe63c528d14d70fa619ad9925d5526eba5f50a385a56713e4a7f697a9154e194a7a54ab61c8a7d40966167b1c3b035c63238e4fa84375ce84dbac1ba17e7076a33ab37a38ea14b68624158cee20685c8b9d8bc8e9db68ceee7f1667bbf2735c6825c40783814bb069bfdce9562d6d1ef774e66ee20b6f4a232559840e2bb8a869b5de82c874bf7bf6185d5821918b13f359b13086ed961e9ca822e7dcd99496b598be70a4941ad9d0297a43f42cc85eba5300e180fec80dabe507f0e844b1b904e588bee5ee9337d3473bfe1cc349a65582add730be1f7aa83481cf6af995ea6658fae9eb76b3c65250bf40dd62ccca7e151efae45ab529eedd431dfd6b01f235c33bbd4b2d8a0de65c7f934698cf806dc994c094f316877d7662973d327e94c2a7797bf7014c6cfb311f8881c7c796ec436a38ff8e2ee6291468c66f538b19b1bd437634464e1be535373b85b502e5fbf13995a6157d2f492d2c9116dbaaed3b78a0fea224c4c94d2df4a06ee48706341a0ed82d77cee884b2a76baa8ba3aae6f6e22899b012dbc983b5aa7daead59cb6b009c80154bf854cb7d56d441c75c454abf2aa0403b5f89aa61b23e6853bd52d6ab8e69fd9e09a1cf48ddbfc67abb2af1ade417ee46d8842873f711b351582de46793b8b43ea4b1bc371a95de33319ed769cdd339aa9cd456c1ca79009fce9637df9b28ed5e6e265600838652f49fb6baa9daf5430ba6e9954c524aa3645d06332ccd2907a83d3d6f9c38289e5b85b88929e3a81de825413835c557886e143b243df8883dbfe6b0aaec00da18ef3562eb231b22af331b031d441ae052ae4d195f23a6a80c9bf760cac894e667c0f6788179d5840c4eae0bd3e652c5f5b13b56c6c558b9a3b4cf29943f80b471fa8b81bf61ff95bc4e28b56fad08c69dbccc18b6349085dfa56ff25b05f036cefcd274786d9a88167cd6f6bc863f11b595e6533159bf255701d9b5b1c10579a6bf3e9718534236051290a9b37916834cb4c6fb9bad56d1c458821a30e4be6cf5dd344c5268215e891ce1eb9993bafa57049ac12d686bc52d151c55c352f53ca7924f549965f968cc16d9db358ba907ad3f23308364072368444dc8ff8f786e3aa892fdccaeaa6494fe55be624d0c762e87116942cb832cb1c4608d85fe65adc39d40356482724654c49902e4ebe52b8e25f432718811c32f7785455d79a706af5cfc1209db17a57d3dba2746051d4110e2a28bccfa538e3c7ec20d2e05fd8da9c62363d705f40e0ba2a0e6968b721ae6b0575701b8f2942527da8f0dea2a1c09ebc462e1cbdb6de2dcf39d44c57d77c63c5e91f05369ea45884b83719ff6af709b5bad112d02901578746348d1f239bf386c2b8ab87da722643363dd5c0bd87e7b1566b578c7ecaf6613f1159ad012052f17fa7a27038a65bbc8474df658e907d38210b4384377e5a66979aef795c43c8e4eba276ac237b88341583ad9969aaab139e167fa91c7b118a818b285ea697d4ddb0b82eadbc83a00d6f4146803e696eca306c3eadc9a5b9185943ba601ff548d51122ca883328bdf2cf86a093667b92349eddb8bbb9e8b2fec01c3531f1fdb568da879ca9a0f94d36743d33efad098b223a3fd10bb07652ab1e6427080ff531f61e0bd81ef8ae159cf70d769fe875248255e0aee2e1c3b0e461af3c73351369c92ac9be0c28c98f5e648846ef8f290f35bfe0809ed06fb09c4de928b52ddbbb300cb22d7407a00eae35a7e8cc44a7ad9f4ce4e39956940700525e4e3ef3988aa10706dcde32bd2808f6727b3596def75174087a12d62e138d2ec3093f7b6d704bc20fd6672ba585016e440e9a89f7676a26b03153f2cc7e987c1ffd6144dcc1086b3eb1ac940cf24be88d214aacf2e66b93ff8300bb26c4e0583657bfadfa0d7f36ef290001f1445db19514b2c5398f4e88515dfb7305111468c137c2d2c81bc6a04e111021c71ec6792bf1f8ddcdabe2672a6f1bb9faa055372a42f7e97652f9775f5bbf839486009e46e32fcada4571b40193a470ecde7149684dbec3177166b2406aec27125dba5fecb31a72d57167da96c1ace2cea1e8780d283fd79857847af98e0aa37b152ef3c6da99f85c9c42f18ebce87e1886545b7f6badfcb101ea73b5612dc7ba1847bbc21ff1e52ba7180040cc6e7ca0bc3ba9eda186040a07540130311012dde417df95a35949e6846ee240d39537b6b0a9aad7ac403cb06d4b6443ad5791ee063f00a9561a56e61eeff560b70019dae055d4b5187a63dda624580f15bd3b5bca208301399a8ef99e403d3d3ac13e38e28d3a94a888c7770fe0576821634e6a01fa883d1425f0c05e727e93cfa66e21d462330c27b5b2e7dd32d1a2ee6af20a5ab9a0713b74ccd29644ccb9cdd49f512edb03183d8d4e33cf49254d9eab67d5b02980c1a85a2e8b5b049492619ad04364bd295943182792501a8f401613acf905147c0c97cad3d875e19b0a55b15db4ca45599f6dbf571d04c4444532da85b08ee2b01a3884dbf4b9427be4b362e032fcc369f4ba7de5a679ea59819bba853971ded673d4b5f8a90608e79e5f67fd83896d6c9558bfdd1205dcff5aa038bfe55eefddb147706b8f6a8589b3ec842e2462202cc4a67c08c6d83c3d76024757ce62bb98a5e67cf1c1bffa6e0398833238bf6bc5c279e356ed35edca59b2f55eaadae7d18e19db5e99bea64166f3780a346d054f80e5200aaf12594f4591c23bbda46524344d8ab82a66626bafba5b08158dda322a7a233b8ac427858778e66750948ce92f2b9217ba865ec21879c4a8b1ec2af0ea106f42af9a75fa7555d811051bbdcb5010186cae241624c6717c11b3482758111ec6e36c01536b07da77398d9aaed04ffe28e3fd65195fec1a8022c19fd035339dbba50be5f365d603f6a72d0cdd3a044d7b9f878829b75cfb7367863dd3865bc48078b4b2d8a5c7b6d6bafc75e62eb137b95cdb32c78c120293b03ed987b06d61abf9e5d9a80454c5f4623868c618f58ffee9536f96e8868d64983a3a590dc1c848faf8d91dde04201a04a27d68836e2e03773daa5532254d9ac3fdd63421d5839564f28b360bb4b637c7741fc043f4f6dd54bc620ca1f47bd0b7cb74d252f0b1d1693bd4282a74a0b55e8372ff05a1293651fd1bf404f1f61dbcb816e12803fc9679e04acf69ae0674af1ffd63e183c510dbc5048e7487f97f24e6b47c444b9fca009feeee0a9c6914667f2c79084b2f76a00da8fa3f2516e866f9c9a74ad3d740be7e150066192749f00436c8ca255cf93f8a20cff4916c15a198a7c32fefc4bf1a97306d8181e9fefaa50746e854b8d9ee2e6ca723644fe9d4ed0e74ca4bc5ebbe660013bb6b210fe65f13c124642b6295a12c1c2fb86dbb450935c5916752b604f6bf8de5e5bb41d0690a41ae6f858ae146dd0b95e4f0f185834f4cefb85a5afc6fef63ef2a214735bf54644c524bc769dbf61a594e6d3dd4ac05b23fc4602b705b08f9e7d7914367b29c79a44eee35d0be25391078e54189c2d0b216aa792ad2b47d324013094fa853a2090eb7b875c377be56eb3f3606a6ae932d8a149df90439ee08c70ca02a88e481bb32ad6153c950219970df8e7ef9b6a8b92d3502877dd19327aa8c775457650655342d4c281d25059ee9d2ca43ab30f29e84c70e6244f5bcde33e4fc10716e80249f5b8ac6c2d60ac7e871b851a205f836cf68fe240d14298c30490333e4afecf9d8d9d5bbfc80987cb8edfcdd8321b16af71d41c565b8618cecfc0635d60e20ce030a02b03fe2df2ee83c8caabbfc6b50a3b6987f5fbd0a67d7c8a246735cf13379148da20f31b1dfae8b1e93bc925821276e244f9c687105e4e994e0d59ff57a5dcd1a32d1aaa36adabf4f3db7cacf9b2ba933d2c1d26aec1db4a9d9bed74d084a2d81b7c0a6c2c6a64269498436d0a472eb3b2b3965c8c9d3c9d2245dceef875cb6b9225d47e533782678d037210da3c1ed5067024af5942d24d1373f8f112362add8371587475419999bb832d44eefbeebb905375d08eb746f51a7081c67b324e845de9f60ebe7533724835c33cfff154e13c9bb7a55127f1ef4a9428ccc2923463546e925869f23e53ecb5d944c2c634c24fcf2f8ecb172e3c1b80534fee48e8f00c50380da9ac15bcfb76071a8fd5a54c66668d1b9459b19281271884264b54d7876b9313344b07f1b546bdeabb86ac4f56ba8553a79e7d86d14f8f6cb4d407591990257884c55421a6eb6abf433b0d718b7044e11e9b31a593b3e50db7106623d1e6e252b9c9cd1fb82c7073ebb3b9417298241e33ccaddc340d29bc81fc5a94047251afb2ab6224ed0bef4078dc66e44b0e34fd14ce692b6f95bdfec6b7121abed9efa2528ae05857ccc3bf175f4be4173cd5a48bdfe6d02a7b73efda3668651c89f59569a1748f01e13824d79756b1f8d94b799068c5aa134f34e22752ad73de725ac457441909b9eb0e81c1b07042dc61cde1ebeabcd5a416442cc980a706974d9e4564baa8aefc58c7517ac9686a38ea6fee7f74293198e370c2163e6e968848dcc9c53abab7f2201c1f5a7e3be8075fe994392ad5b98d26a37cfdae6a4bbbf59e44cd950a0f4abb2c5c7ecbb517753fa663e53ec0f8296b1751f675671d21229887b2d8b2d7b532bc1c35842d89d6ba7574bdd5973229ee1899c4f6b9fc32c66a7eac0525ded4e2ac2c6080f9d45f832d81436579dbe22165e82a18985789cd1c88b6d29a135466b07e5eb60a536e699d86cf607cea19f28f53f82be9b1041f256b4b76a67d07ba54d24e3426a0f03d34242599064e9411454d53cebe9d5a27aa5b03370dc97ba4cbe9f0fcb93679e3d2dfb85997ad0a719643ae0f156e01a69038830133478e2619671b168643de34e3f2ead44a171ed979af01379c3eca65199ef6afef766e50698210620717b07fc929d59c64eb1340af15c50d2f9e9ce60167899a6c5d2149bd8d4c7e4df35103cbc53736e8e16187f381bbe704c4ee2105fa8d6c3a63b8cdcd496036fd7a5acc0a881dcf7504a8d5aa9990e98afefc2e07f8b3b751407f3644f093cb217dbbdc887dcbb15ad7dd1e0da3720f547065b3af1c00bcd6f203418499a713f29bc41f99b8160d6a309b864f9ab495afd8fcc4b2fb8d92b05cd321acbafe94a7a962f1c763402ea0eb20dd95cc462e88ed023b3c99c05916760cb7cee3d4e1ad19717f8a6913939a7a5ffddb491ca0ba5b414dd09b071414339dd61eeccd9ae5b00cc48c31c5d257c2ba20fdd33093afe33b6a89d2c22f6e4d53dc54ee2e5fa71ac78fd40f5334d2b0ef81fcd36d334bc6c0a957e315606c7354c3908286e89ae696a2dd214f0e16f0ecbab75636414a9c085fafe0e456029ed8bff406bba25d0eb8436ce893ec9d3a088b53da725a1c200389f76342c9d661cfdfe1d4b0c73577a924da8f29f0a453b9bbd2be6ed305087c6a1b3edf39a57a36aa2521f137472066f6d6b0e3a108a788c73add3753b369045eaba1824d49ff7854a49cf094452c5e5d815c7ee65b0734f3a1847af6f53d622c0962bd9f3295ed0e956eeab766027ca0890c997f9a2aaf058f24ac3dff98f785ca5d323f762affb1b69742e07b475bdeab966681752ef6d1ee0b4890ebb135edba661adc0a1cc37b180c5a26478509fa3a014b3ab0207c75d66e50a4986f548bf86b51060fb624832a582cd7b8afcc42c8a18a4b91d86b529551d8d83c54c73e4a235819994491111032ace7c000950db1fc52fc4c4403b244d499b09e9835cedbea20ac1f3ad569a1f711a899561bd903b1e3bba94bd54413a8e0aa9af4b211cd654dffd7b5ac37fca2f85ea7bc0b7e4fda5a137e639aca14e7376387b5c8666a49306103a61efa6e5d2a376ee39f49a44a6bcd85c4233ceab3620b5dbb510b28790777a64a4d58af972db53174d957850c77d1120abb16833b40db4e22c0defa233d367fb0462db397714054f728dcc28ba1dce390f5a3ff6403fae62b1198fce09e92a6bab81cf9e770ba5b8d8b851d23c36d1a01ffd700b1c79e09ef1f8fb0fef11fa2b1a642e719bdd9c656fca78084c60169c56968a2fa46820b52a8158fdcc239cda7dc3b5ce8164b535534b8e09adfa9ce4b131ecf155b536a87cd2dd49617457f26942d764a07a14eca27c4335d9973154b253bf100dea92b70f5f785d502ef23a728682405087f3aa10f2ce940cd94cf014ecac5d90381e1d24213789ddb05320248cb085493ea3ca1697422ff1ecf0b60107577664598549cfbde6fbfa689077f479e62d5c38f9b3bab031c6f102fcef9d71c0bcd139a71f4fb75993dd4bba9bfd642111da8512ca482b04fdc88d35311a306f0adda5dc9e637abd945242c9f917c34378a92efb04c1a80c55217e99fe8941f410f0cde3ca5e707e05c2a54cf95d5e5d7804d9d9f252b72f3cf52d7ad97417b66595941fd8119c0393d328c9f38cac7f9a9842a23561194f244fdd4bd65e676f1c8366e7e8b0a56fbfa70981f0b9d6d227c18fbb08ef3992e9743b50fff2f105bb48e717675fa90a90bd72132f83320110629269697d928220277af71376b5e875519e803b216cf3518c5d6acfdfddfa0ddf45e4e1d64ecb611b106ca22d425729ac03d6e44248689503e40945805aafc0b5856c7628694d518cec77ef38ef99e8dc3b05777a39a5c35444a253170c751887d6dd7a0356ba35195e594f1f4141bb090f9f14bb0c7eb76be04b75cba53cf567c4fea6b46f41a24810230717bb38c7d69201ca5060e3f9ec241c323dc81e0908d6ad3800a176c9e2443a670cd7774902188beff879431c2850a2c705053b6b804445a631f17f9c5f4becaabd464127d45a5a0885f8b65894f203d28e4f15e56cbe4a3d6fb3f831b317a0cd3d4e5b503f08f03e2f0c5da47bca4a3415296e64cacc534a6c8f0414daf011aac7dca639531cf6eb51727db4d00cc25e1c88b6f1792d644e2309c02bec4a71abd9b20d5b82304ba14d2f6c6691e1f4e0f2453cbab425ceec27863218d6ba0f60f6af0b59a952b937f348b6fa24a7b1a008755f8e5dd64a94add13679aebc34e2c6760ba8f14dad59a146665e3f2d4ae3f64a1139814b42e6fd3e44deac9329dfea6d394bfa99ad0b023bcdade1c652ae54bc3d288dce88da30592157bcf283930852a868ada40b31b41baae313cfe8d3eeda075787c6e552e952981fb5d880feff2c0e8f287dc68d17f1c0e1c1fdcd7f12a6a6b851fad981a275809d5872a2fbbceb2f29157b9b03da8050b721b2e5bb6ab9f89590c01beace76c45b4d328145647496bda7795393a73bf7d7a2bdd0e2e3115aff83895f07d9eafe966d21b6c474e3f9573c1a30aeeb3fe078fb26dd972e51fe0b2abef10d5db040a8346eb1a4483d28ee93bbc1bc2cb24fc333fef37dc8fcf4a22be9bf04fae587ffe33f74bc29ce15db47360880a4ea8f46b354ef7eeff94adb2d45e91e095ed46e9d66067c90d1f973a78bda557c92c3f5672db5ed32f08e3a9b24be6c5be318cc0b77fe02a67064ebf4d783ea4e5198c07ac05eaf6a0432cf811e92d027d272ba89a7218a7ab4e5d774f35e3adc198a50cfc8c8d2a639178dae96ca2689ce8cd31615df245b6e910baecebe1369aa474ef865bda015831ce2af46290b4e0c313ddac1960ed5f64ea552ccf9427f1f38ab34e950a89eb0a696370d5423b3ccc5343abdce0916348157849280f270cbc58a6951ada7362e0399e03e78532a9c6a99c96d7bb6bc1e14a5983ea24fbe02b790917f5e4b64bebf23e372d6c21ba1da21dc264e16b9f1cda83eb2f9bfcfd158b451da1da1bd4c38a6337ccedb069e11b95419c01c4fc28302482a6aa1fbfa61bd8b613397ed3de6a5ecf6d026670b05d6b9a997f2bf1af067d166d0a83b37be7788d2e16b367a87a2b76bbae63dedc4ab6d4c50627ad13f78c28124ce837ab4a7154c26e9def54fa63d3e29c3e2aa6a14b89d93712737faca456bb519465dd47d9f1c7e22d590790b2041e4ecdbd65635291e6b7bf6106beb9075f7348bb448a6092e597c5a38236b143c0f765fdc337b1fe30ffefa7ff6affa7c4f522b1b47d00a59c5ace0762fc39b6c6accd3e5f9ce01725d338def6fba145263e84e2ea4b6b6be6620e6de6d49a79c4f3b88ea599f9b119649e04e271e487d414dbd7e2db528a296f1f25c66f6ec0a7fb4dae13c8f177575a2df0986cf7ba167e4a3f9d1de8beb089b29b19cb5d3f7fd0d0c9921e2f6f53df99167ee415e61e7f09819b41ffab3a90907fc8798e329040de8880bf56dc78ebbc23e7d0868c548a85307e132818492acb679fe2c0b09e51fa2f29941c4051e329c1074a94966e4cd3596dde9ab2d0b5f385fdadb61dcf92ae40eb3f7f5b0b7bf5890c9dfa8fb6567b3454fa47c49b71528f8db4c5fe08c10e701f58ceb13e5dc658fd6ba33623f547fc960321368a17ae6266a0e852d1ceb15945897b582edcc1273776d956a6d70fd7f6bf77360dc5bf4462c3dfcc4fdec12d3f786013faaf873380acb8b5ef7b94912e1f681dc7c4d81b6628402a1ef46e25648209ad2dbf0923ce834586e0544a2ac7324dc0cdd025aad8f6cafea0a37d3d4eb2454b4ed732b26a087f4fee930180c3f5def4a2c41338e2fecfd0eb7765ce4f1962a1e829a5fb9de8f726be4cfb9d23d765b5d03c52fcdad8a37aa2ee9ab71785e7fe520dde24605d8e223e05803d856ef4cc66d0310e55229883742ccc021f5b79d3695b043aaff97682a853ad8bcebba520511851d97fe8a188c0c69138b6149e5d45b1efe348d8b240eb8cf4a7b21ea35652eff6fd5a131c56e9e87ef4ebccf42b507ae45e6bea990e4cdd62c9019da6a88468d6fe89ba7405fc69d0803e2834c407748e5c282bd7395afc8a12c707dcc4c6495bd3066a1c88e00daea2b6a9fc2690b2bd4ac12acda025f66d478eec86ab3280f40f524a73e84890bda4fd313014686e2b266af7e467a43aebe41340f137d903be422fdae7d167fa74c91f2d855d8c9686684a4c4e57854b199f9f72d0a2cbcb3a7875cb6d50735dd83ade378f4a5acdd5464d378303685d1149255aaec613ab944b058a73cbccb15a92262f0ebe0f5036f719a033f26644950da16fff1cfe94f5096762465e16e91949a98cd5b6a5d35dfc8da073bf9f5d5760e6fd9b20f3c4d879c0814c19237861fc7f07285ea4a71be692e18fafd312b95f6bcd55f3d039d25623ef074092b5bcc7fb2ac2c73f3318e5c9c03bb74fd1a1fec71a32aab27e4ef767d4e84de935a358fd3a374ba0411dac3b391344e8500f61c9daaa1b99307b29f9d65b2cf399744f394114044497af1b079cf1df5de9f8bd6a1180551a01440d10aa2f620e935fac88941bfee4e9ea1d9b1bc738e9abeb1eb8da244a2378b5c0c294722c58c70e950fc2290edf9493ec4466de01faae83d0b52ea97db74f358bd8440c2a101ee1c35c94feefb8d410ec033b060ef6dc4c85cf14f904b64d52691207c1f681c001bcf60d1d53091bdfdc68f27995bab5b60999c48c4d2390ccfb2441fcd404aedc558c1239ea9841d613b57ac3ee8e02b058a6d1d3130c79a21e2a123fd1414464560fb3afdf76d52baccc1efe60a81574219a467d6bac264d750d9b2b28e065d330d9daefd1395e35e25010585c37c7ae5c22bf0e04a9bbc60d9bee47bc7e13bdf1cb79539719a6dcd35f8e53de973d66f52e26e6670de77208c24e314e2c55639847cc2e53a078b5c3af79666dbb83c0f4d80263ecbcfa72f2febec849b7a025895fe5769f64062ca92fb70408184bb3aa28654800e033f82ffcbe31944c253bc48213586e9ca1a5b612b61994379dd4af45eeb691990970237864d1463194b83975e1d31b89b483173aad158982de35736eb2c188ea4374a0925b2b26c94d70294b17522907ddd029f980bf1355223777e0f836fc4e1c5e91294862d056a5584c6ab4a02ddefe07936b5b9c477b87fe0764545c87b3f099c18128ad2801017bb0e6330a83ba65c4a683ff546c317ffd1b60a37d8f5d70f8e4dd479d1c466e47e5fada446a6989bdecd4c51412b545402c5936899bbdd88809be0e9c13f79ee3eb30ab82af127a0a47f3d8d8daa2ca9f36b5c1e735b465e2c65316e5765cd0cd97a0989136e30e93143d744ee798e5bf0db39ac49e6d054b3004168b6f646b12246d77ec39ab8d39eb776e267f9269b99fe70f8f5e5da26cf89200c6e46626ba12d77669a74f1986158b44dd39cad444dbb79e667247a26099a893fa82bd80ae1df12019af65c21ae55cf9836c82dad9649f189f3589ba578d0c7852f6f438209b6e91b7a863b701a9e6d6f780093df744928c323de46b7a7126c75b64ddb0f685d31fc8547748e80053155d48f354368c219da8676f0712c8c326051078a2d3afe4917984f5d2aeed27ea03e6872505458ba59edd6276c23fef49345015f954a338c5da46803321f34cc19f232beb7e25104c55383a9c5df8e6390e1f74007c4e81b49fe0175fa397959d03dfc80bd1637c77b7794f1aee265eaa7f61c32df957e39de76e8d089b1d2073db76c595bac288a5c6798ae584a2964b48239b2aae79a3b79e7fa808154faab438d405eb9d3cbf4757bce2631cb54835e03456d6536046cad00d80a5b7270f9cb8f059deed0fc9240275f82cd79374593f9353a11fa35e1e011c47f05cd631e78f429f6e608cd0bbe30f868386e5e1e8211146db9f83a96f0eeab6a3d22d59f7567cfabafe106011b0e31dc78f0a7419ef719ff83ea629f535977c1ed0e05a23f9abe78ab8886c48d9538352a5ed68504545820f8338182d793f7677ec718edac958e78abf3a95d1cd9dc91857dea501d9eabc87251e09682685f467162cab1b870b4f3ae289743ee77889468965a9918dbae404d989555cf01279bf089113e7d6e992fad9b50fcfa516727734117dcd1dda289dd79acc0f9b77e7c7e78f037523404a52947ac0cb414a5da12b7b601c7b155a95bc3c57e7ca6010438f99cc84b012945c6f7320263de8a2e391a9492cdf25afa3f9ee404fc59cb3f412353409a532750ea7d784794afa04c0e739dd0867b0408573fb7869d8eb45c9b023a0aaf5a3f4a815675601c9af8ef72f663b9b4621836c88e800971b27304439bfed2386a129d051a94c020c6b2bc46a6c048ce53a32bf2aabe877fe3bf42db6f0eb0850d2fcd3f83ee2a7ca93772bee0a7733b414","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
