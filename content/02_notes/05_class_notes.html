<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"f51794a18d307aac18283c3077917f79c8ed847835d7132b95d3b7e4b3b05a7a5617d1f2fd6536436b67b5ed3e524b7a91db39535374f6e25a9691b8ed98634c158743260e3cd32433d309bd690e7e028587de14f1326c7e0adcccdb9b4ce4ff274613a4d3a73271ab7ee8d60cdd410e03235049c4d5cbb2697f448e918104cfc7654d3c08ef104a5606ca9537eb66b269f7a45e6706adf9e7e6f7e3f18293b99e5466f1eeab4f4cd09cd6afd71f5b682da422e801369cd2856b8c32b89e1811b9b5668d6e20d86dfa941e70edc3cb89e657c9ad9d101b17878e9b91ce43c3527e29be9bdb0b5ea98a36d95097b158b88da90221e8ad4be29d421c4491d95d904052ee60f83725959ffe9c1f28dd8673a32ecdf60524c59a64af3c9905b8d690288300e2148deabe65a919102bac580f84271276f5bcee156e1adc175c92976538afc3365a9edddda70057518674e9a25a1eb2ef4d21779ac8e73601f537ac305afff8e44d9130c5346b924f1838e50a7b712450f20569697321224a3226eb804176834a28d7568af034ae0ec7088488340e5278184dbb004006e4da351d7ed87cb648e17f8b805eb5c09cd0bfeb284f365b330c53d157ba27ab746ed908610c0d43ac3871368ad3b840c793ff6bdaf75029252889dca46b19b44cfa3b61b9f23cf205ac631989155c4da09c5b0591b62867d2254efe58eddc7d3443285db47ce83177405f696680149b152f3c3acd5072083133e0fb4fb7af4e33eeee9085096e48292089a3af7593764abbcaa1d653ffaedecf70a4544110f454b07adde9b2ea43a10140279f4bc4580cf4ef07e30635fb87ad21c84fa8e3321b82102d7c4e4283f086903c4c42666a02254ec20082b3de2942096cfe008b2f08afb044e9e4844e1d762aa9da4669b954bee3d3e00cb9e00f6264c72f9ec4b82ca61443fcc2540040c20638b21377657c9202594fbe04cb1769265e11a92df04f72a20b4ffcfee19e0d97e445865af22f7b6fe1af23ae8f4b75e31d8ec727d36372aedaa0abb637264a9e4318f6b3cbead798516991ee3e6d9fd5413c3653bc3c696f3221768b8bccce68eb3a57106fb42a607c538f2e2ddeb8ce8507dddf5bdefae36e840036964bae22053420a0b746bb8d8ff644f7e117d1d3ef8a6d76015c522f6d0b68b1345fc54a11cac9697ed336b8bd8ca2c2f1ea0f337cd48a16a9d35532edfd7934b41e75bdb03abbb4334087881311c9c343fe875b6f850aac4177a7847c551c4b0af4115af19e89e951d3f34c7b74de5e735b081e91c65e433bf6d52bff10016e759503097ed8c578671f6193b9b915151a4444f12e7a59fcb13f82a42fc03b1bb897d530e7f2f7ee0df1b57db5010efe15c221215c1b0db8a202281f1fa83c7efda7dbc9fff02de03e2d83cb047cf7d3b4cfe38225cf67e2fbbab700839192ee9f7bc253594753e327e1b48da5f95166e0ec323226659399fc93290f40641f84ccb385ad727fdb97728ae80d1f3c61e974fe85076604cf638cf9317d71d2dc97f0ab779ac6404ab891654e7e2e90b7ce881ccad268557139cdce811045f9ee6ebe4daecd28ac2410538742c1d1fb5f1da6d32b9c555c1dd4c49e8dcc8916f87158b32d2a861b83df6576b73d854afeb381b242107728ce6326df7f944ec0d390be41ce05c8b085592fa9a519270d1df5da508e1d673f684e55237811e119eae3fb54806c65a9bd61c5a17cf7dc110025c62ffcd5624158f335c93bdda7d11c0cac4dfb7100d8a7ba059c56db81e83360e2712c79b77ee1a9879039872dfeb382a0da1cecc74302b563c00ff46d6756ed38567715a492472c474fdd655a2a4594f63914b7df09724314ad99db7cb09ed43159b8f1ae739dc183dc21500679a6986d53738b05fb6f14054335640c8b52eee3c4fbf0b8f0694c4c300b2b98420d956035792ba6887cbe0c450bb1a765c94bde6b0b2b9b7c4c733a0ab5627eed65145f43128e9d92cd339c3291d02d7da592506c50cac1986e4f2fad94da66bee82ef6acc2489a90e996731b1bf7d7ad9a21cc8c67684325ce9cdf34d18de0fedf20d5f97a1b263c914e61b007913a5c07f9406211a811b6ae47619eeb89d078bb8d82c6e49735636a0da329ee201bd19665411d323aec3893aa0c87d39c2626b65d63c54a02f183048f4adbf23121d459a415bb85960036bce31ca22adb757f44043fc6bdbead6a64fabacae61163a1c16d6dc27538ad334ee1a655303825a04d01932901bcd91dc1e52b52593b47dc41f9e98ded56907e16afc3e263a1a4e765363b7935a41659e684f82c7b4d473daaa8f9e57d6ae76a6d3f724242837f97fb904fe97c7010af2410cd7de5981b8bfd4b3f15bf8205f574bd313ab869b7a5e1dc080e79d9d28dc9d380ed367ab1f39eee4f5e760e9da94c4bea8cd9e1461683142697621bdfc2be6a83debbb4d21760c5b55b7922ba16cc3e38c7289e615a459c195175dacc5b5f1c3e31469c039ddef61bb089c248d9b5073b4c2758efec75939852690b16b002aea00e6ab2f9516afde658cdb759bb1454842c2b9c9481c3a6f3d78abdbed99f5d17d2a614fbd8ae7cbb10b2a6721c440f25fcd3ba8e5b7b2ddc74e326cea4ffd7a9c4e27082b258186823f5dd455cd95fb517e31c5c4a200c092bf6ccc5bce85e073aea3132ec0cf40c6d50ecc2ba7e19b075333e8266298f413be1b0a0ef618f04a15aadbfee9556279eeacf71ef2f0f21108a1e0e495516cd6eb7d294242704a4c533f61a77209e6b4a3b0c648faff637af45259678d78fb513d540ded80563203db852b477065205949e49b2db9e4a088afdf9eaebb9c33c7e4ec972f66f71834bf37118f59dc52ef4f371ce948dcb5e1d8fa1f7a8fd68d011d854bfaa6f10d6f30720b2f46c9cf16c3620a5085d7038e09eb8c3be2a01dfe61d3aeade0e4ccaf57f4acea2a8d4ce561f9dec49c7207283982879b411ab9163f8dc45048ae26d600269c31c76269c7bd5213a068ddd474328a15aa246b35e600a5ef3b74187ca56e13d73a55d9a837ec412f87459abb6adb7b514638d54dcc3c34ae9d8646750386c1484b75834ca32258fb4b6b129b671789dba07ad27efe723629140d67a801754daa54bad8c063ec64292456c11ac93d3db6f4ab9e07a53ad64298b692f0b95d74f0aa772a3fe57205ff66b5dcdd07068b43ba639a454ee383fcd594be68c90859260c81dfb145dec0a762590813c93af4dd0f530394607efc8ff4771697e0dba5c08ed56854692b9d80e5c6b11378ab6e5a2f80be8cd3186e898829ae587b546fdf4bb55d1295fc0488a812f5dafa191d6f33d574a36252556a08e6dff9c9310a4a06f413aeddf7794744f04afb943478246fe44b71fa99acd6d490bde0379baf27770d31abeced349a9391cc21ac28c78fadd464f544ab6b218a66136d8fe6c21ebe3ede5053c0ab9cea91c35526c11cd39d9ad4a02f689ed89b02cee3a3704a8ad3b34574fc0982e95a1aa800747df3e67164383e77ed6c2694bfbcecae9ce9d075d12c80798f65d66b3352e7d6bf45f5016347958ddacf1d3a10374616a555fd543a00902af3a6ad46d13513f79cd090c33c8fc012b38a962f876d431d7ab640770bd314d0c603dfffbd7ed0d80ee2a74ca9799599268a33e6ca873771ca8d460a8f885c0458a5246105ce3cdb301638661453dca7bdc82bc01b7ac5739d7068e918e841e52ea531c65acf819155b2c7d79706264ea5fb274b770e77321e43e89b3557764bcb745c71151d3e935ec2e9176348293d922b965fc8746421c105cf1c1203a4cfadba01af4421de4ce1fcb4a0aa12ee2899491f9d41110593e2a9999ffec89b9201ead1bcbeb4b7266f9019fac73c9859a8d8ebf633ca33f101304907777098022a138cad8f9f764485b5ad2cdf182b87b8b9e8bd571e1ac7dce5e36fe17cddcef72b9b8be05d98d6715561400cebe7076cd384ec0a6dc1b1b188c1473237a4a747f1ea27cf2e66310432d7f0fb1f65b1128d546c72d41ff196ec191bba75dfd61db23853617fea1b5c59536ed1746e7d74296f2dd81cd0edde9479185123bd619e15ce03ffdacdfd28f073813924370a3fa42c8f6a1337d4b9531694a80b234856a872016b201cd56f4410a6746dd741f85d7018e69d1fa4a11e0c33dd1b3995f5df597820d4cfbca85f5020a70ceb66532d352d8317bd6440c5fac5cac183835f8b6e83317084c5b9a40d79c65ef8bb6ee300ad46b9455705f4317ecd90e3d8cf615c0e8e2e25af003320e16ff8881126b1ad72714a7e0918feaa38ffab4c16a704e2063f6cd2ca79c515feeae3f7e2cb4940b7d963d4c2d57ab4534dbe87448a5cf88ccf25927d68f55ab97d886c918df91a7546e45c2f1f06be5efff302b9ee2ae8099b23437f5ff55edd6222e845138828bd1b3886be63fa2bcc7648e847487713dffe0feac9c6c3e67222bb261a7a2dec1c4f25dedaa5db277d058005374ec209be73cf4d9fe57f6fb667edb1e5fb2226db8ac0eb878117868a609a65711bab9401bed19c7bf359efd8dcc3187ae144462cbcc4cc8d8e489201c6317f53ad61cd930f0bd4ac05a763a5775b4ea12423a2a941715f30a033759c0e83395db76251ab8f23a3263a6764c292f59b4d6f193468cab465c18f9247e4315e713b698e3ece67a0064f74b0df9b1e16944b1a23cf7b2de0147ee8b5ef0a38447b8eae4d28bc3b9405ada6a2b5bc531f2871f2de4b7485462c96496f1e70b70b5abf8b96001deb829fe32ebbf965b50fe28b4ef438b0798ef3c7bcb44d2178be06ad3b7da08f3285d54e417a294c9db9d94ef8a51c2190b32bf651f635dbd75a91f82dc92a1786995d0c6c8a697e5488283074db28f91680fe87f17f5e7f47a4a757d7cf56eae3920a7473e2a5813976bc0e87f7b4a9f324a39319df80843fd4ef638df70c24380ff3a9a8569b646c67858a637ca97d1d9974eb2846b0e89108ddb6276e865867be7876e1fc79a398236921e485dbd92c1b9bb2fcd97b812f7b459350560d4801b7a52ed65afb326a869eb22f7efc8d37adc1a2e8f977ec58e64f8add2bfe5dd8b69743ec20a99bf7896aaffd916124fd0e3a4617a2fc71f4d07f5ce0624903df9ab57f749216eb45b71b8237d96f09df22596d8647cb024a2a6871a65792592ddad1522db30c78914e65d88b30b89a146a31d80ebdce448a00019021e0b235fedd218e284d51390defea38c21837a6f3afbf84d8f173aa86e2298d899a598911ec8ee0c74ed9bd27971a1befc2c285e0a19383c854cfd2878955345ba014c6e69e55e15840992f126b8298e96feae3a539bd117ca654ec99cd23dbc03994fcbb47b296117e6146ccafcaa52a152de75b4b3bab39c8499c41b0dc8bb4017b8efd73b3a9dd198ebfda50915cec4e6a371352581d84505987b1dc10848973c1894a9dada02731e5a692ac1ab5def5d3cef3031ee822ab1a9dfca1bcae431298cddfce6625d2437e6b451d554d5a5ed1fc7ed2db87d42119a0f56f8c535954b833f8f4c8665810cf729acb85ec2674348493ef4477779efccfa804695e476e3e654f2793f10ada8feb85cf5bca6c5277592dc8003796ad3e2596b894f1f5dbf17d7a3eb81e6058db925767eaefe9cf9dbfa4c3dc38bea55597b22aa334f60c22a884a41da9f49cef165caf9c687c57dde9574732247ef18b94560cef24fcb3158d44530f5667717b5b1ea675604df21c89dc925f8d52f28cb588d1d55c156deb841edd30d8c184f9aca20538af93cb7fbf0a97cd6d30519bccfdbd21f4103e706c4a8ae8f94e011208175538a70dca1d708812cdb058fd9d76c44bdcd8487b0b89e19f98ff6fd837aee733450f3e5a42d014686bb994bdbc9a567b7e6fced0c25e7f773b4c08f9596f6f7342753ef3ae7397312efb2bc18b63c72d6b8d9b7c10b7869f4286295a021eaf642c245606f42d84c19ffca0bce42bb3f5be7d56738908d58d6f9760ca5c7aae6dd11a58deee30e43b15fb7dab513adec228e0afdf3246ed03d8304965364d6b3c393d1efa3b938991579897836567725646aa1e57d34eae7f2e5cfdd67bc80fab5e5eb26e510f28a3551763d14121a3a4dc4fb492cce4302c9650b0f9c02caa5352dde28ed075bdbde348fb225179b3c0a2048780c3412aacda0fae7c55345770d9315b961f5d46b51f32999100caaa938c38b3340c106c4e26fcb80ef2a2d056e2a689184e2551dbfc8beacab5bfdab738007afa820b4882f18925592656ba8156aee39c947024e937fe9fd05da32c9c127e3a4883f8cbecc4462b68dbafd952c838963f8a806ffd84e95f8d450ea694d6cf5defde76144cbf785caebc89df6864339f8d1f30b2ca2c44ddd6a8ec4b5eafe6634c90e5f8367e6dc6d71bff4f58c7767342a87a5b9a4b218e05ca94c6c577024b265e859cf2357eb24c1b2223db6d947b63f4de862778c7402e301ce4d269d53afd40f4ca6df790ed51c5fb39a86b6a3c6c79507250d8d997f4847d5446449865108b1b2d138d8ae230fb1907c9743615d1efdd3a87e12897057bf7f5176c6a1783451204301dd4fbb2b4a77ecde83c09be361068abb26b7641f837f984617ff227c619944ca5c9f752f4f04ed23f49206c0d941a9c2905236eec51ecb15d8c7a50e10e3f5eca8204a6a0a4bcb23021bf4f4ba436bbcd74f4638ab0b8cf182c514eaf356d4f88d2a2fb71ab822067e13fe8307c061103e7c505c3027d3bfd65809a2c4fbdce22d24c6f913ef91b29ecf033881b10e9b7699c1eed4c1cd44460ac8e88369e94ef9621a10efd3ef9a96b85762fca6053524e7b0a1ee45d21c5a2515dddef7f67c747c7caecf1ded2d83211a14a3a07e5993d2ca707474d6cc73fb56c4debf7d1c17dc44a17c34fd3ed238b3fbf3e371567ff3cdea7f085224da39e71d07a1960ae3ebe0ee21f6345b298c32f7998a8e111a750a7fecbc6801985ac95d8d200517b7397347888d26f707170891ab80ab5f8c7c5437736ad603f342668e8cc5005e1bcbea93c80f5c92e2d54f649856038c512c5e2648efeeeb668c708cd3b36afc4a4611e3d8b1b74674943fb8ef7f37d8bcf5db3101bd0aecc110bf6f941d565de4c7281908e69f295fac362e506cb76832fe4591ce0a3017be35b95aa5ccd895ffda9179a1fe7f1d600e94b70a4b20931b17cbc12e79507e087ae95b88fde76f68bfb550ccae10698f65e4e161721f72044479fb5ce1faf86bf9213935fdd8049a562b0bce703ed1d250249cd0ff87bc6c92818517c5546c2e33fa50ce9554f62f244574df3fcca2124ae717ace4b7d7d54b34dd54b531d92040fe7a914eb5a916599ee1061d0327f07bdef7e3be56e0a39dda2fcc0ab00ff76c5b5d570c959ef3cd30dee61a2c3ed51dc2d51877bb59ff868b249d0e7e9028e17286a85e932d4db8c6ed3dce6ef2249dedd77dc356be150a11d82490c6446fdcacc4ad961e0b7517f7356b0806261e924a2acb44bbb67d81c2eef560266f543412cd6e5022a77fbc2e50bb963bf096b48eb274090ddf9f83288823033209b372d83dfb1d29bade374efd55189a2d592f06f0643e23efc4ac52e14c951be26c271f427c3d4dacace0a7688681cf0a002fd16bc354c570f7e7d2cbd840eb717e0e416e4f6e7c6f5c9f8ff17e738f182e2f270b57f12f728eaefcb001a21533100b4ea9e8e2405209f429606dc94e3622e0fe3c2b3a79370a8b1b608b06e5279446b8e468496597d7de8ad4d1acb8baa1acea3c4e19f8f2c32ed8e2aed9091f39f87c06b2a29cd85b917528ffb76d7c8a529951ef49729e3b2bb2c879484fe91d0609f85d3876417f392e41d0fe06793b1bcb33afa014dbf5af9804d9e55a5f8063729e6f5f27e1595f0963ba9620b19e543349c8d871a944b5240e7446b427a336484ee8d06e6eb983fba40f0811bbe737223d22ac58bcb85934c467004f971ffbd8181d8954593964419bfe75ce43aa0ba40f531d5def5ee90bc1a8bb97c572ef2ef28f970c05f4872baa6f6755821c75448d8df8ef31cc2ed6d315fc7b47511f816e90f60de6ecb20df2d301e67dd20e4c60155cb3ee3094c5d0dd66585d1853c5729b9349f4ec07569b46da9114b5d699c752a10b8d4fd47fd82a60c43998a9396d4b98a3d3f6eefe10cc40d76d4ee27ba6915724eec5904998d573419407c1cf051bf99cc188457b3d08da3958510cd684a210665778a68170f9914b1b542d82c3c456960510cb341b3580c5f21d4ee623bbfbee6499525e72dcb5958a984a11076c57a89958930e327222a52664a6a97d58a134ebea5eac2c190413388dc470fb27249a7bba411e97e5965f9327d1045f1e393b1d146ecbb75a7015d1791dd1e6c91713d6985d93dfadf1c722046a93f45241d530a14060351dd0c67687de77861a04cbda45e62ccaff0511920284b0e6059fde0fcd2df4316fe55d723db1d2dec15ac0df37379b2485b2abe13032ff6b3aa159cb8fe4801608f3078cd12378f02991f4b70db8665997bd90e5945d1bb85e706aa202abfb2e5215e04f51a1bb71f7ce4a43a5c06780116fe5b20cf22ee17da470c4c75ae19fc8c4d03d1e2da856c433b8dc43e4ce253cd0295879278c9bc67035a68739435ddad50b049a9623fe256093ddf8e576b3d40ac3820a01fed3a8ccda9a936b929ebb3bd21614f3f09ea0ec78d38357270490496bbb78d0bdb947b9e75b3ed3338fac01f4a695f7d541d485433e121ef8b299f6fb36e5c8164f58465c764177b560db49da35705cc43d0d323850ea218f242e301ad15621ca3e78760c76efa4053ccecc19b81356c66bf7093ebfae08e3166bc0a5d99d23afee4b6986ddda2b653722716905b45a692c7a6100d87cfb49c9c2a8485402d0325b05c78eec5ea1f747a12e9c57f607a8bcbc2dc4bf7771f457db88560e7d7a3854fd55ad8f55c3c8d5a38817e0effdd75e1744bba59c2d31ddda3220424216c3d02c849a8d2b2737a57d675787b13d561a23ab6b711a6fc529a25f3a5acdb09dab8668f782425915877133fef460cd3ccfa27b3d4a068263b980c2c8eb5eff3a6a8598a67ddc303a409c58b7a3755466d759f4ffd6703d39e5598624c2d0dc3a074a18b4faf82c75c61ea1547b8df37b93795052313bb5d0cd0cd62b9eb56ebcc4caaae01309a5a7b0c1979d9a629148843f83216674ce4d316034b5602aeec40a0ded2f755a19ebf74d6efe9831cb51e4ea51a5e51e153c84209d55a4ead5207f4db6452442d89024a69d28914663e90690b13232a0697b67646d7abdc263fc7b9da58318597d58da5297c4999f2f01609a4b19fae08844bceee91d54aee87c965363650a2d94924f04eba1d216b6e5ed540c48e67a79fa12136aed43d37678ab71cac218daec875244e3c9be052be9f6be48b9b73c40488f6a96c10d8acee028ff1d1187359a9c7da4865b58bdb2da8fe796c59947d260873c3dfc31123efae0b3af0ff6f39bc3b3913f952815acb07c1c6dc9d7df69613daae5c19cd84d0954b70b04f0293651df8067cc03b46379d13e9276b82236c69672b9379c20af88cddf57c2ae2516995de9f09f38946aa6cd6ab38414e16d1bef544a96b83aea450b2569c37b1226877cf8db871f02754edc533959741061b3cccbbd36a391722e54722253bf68b150b172b6632a073c868f737232a4a520e612723196716d3bedfce904575a4f0426f00994872c991c2f3e6c580031309aeddb0473f81960e01f71cad3bab10ebf2db7df4bfe24a8a26bc7ad67d9426ef0104c23db2fab969e0368736bb6d05a5058d36755857fd395327a3d8b3a1806fc639746dc6fce22928bd2fdffec2059694ae902eca037784833edafb05539dab914c7260bcb6761080779504e4aaa1a44bb36009bccb59e568a1cb54b076bf6da4a92e7a1b3c9240409791dbc8ebf5a73c6bcccb7d81996f4cc23de48d96f9623c3024c2f85826585d7c1d06b691cc8e4d1de3459a4c7216a4e1068adf2ad7630dbcea4e3426e3617d0da96b812a8ad08e914e8cea58e2cefa017d118ebf6ed4cd99914081fa45a42787f9a9c9bf82a391e2bbf8b00e95dc443fd8dd54e0fb9586cdb26eb988fa20f2499b5fbf9ceabbac297669e1adf3efce3b38a4f0f8e74b2c4e3d5c751714c494e1053d3ea5662f4b3383f0243a0053c23815e16b6d39906cd5246a97dc664a567ea1f66414a15263004ba4aa28408ed1d94dc72af7f4861393bd517dbba683b10f8b067ef44ef4f733192654f1e746ccfb83c3b175ac3dd8ac7df22a171fd6743dde7d003fae7334f83712ed1f53300938effc12002fbf5c2fc7e3ad50d1e3767e327aa84682a0502eee4ffa59d449745382902e09a419bf737b1e7442009d16d7621c52b8e6e80d02f97644c61ad62ac9f51d70f8dcdb806bd49ce40439566910a74ae1e95bae6b30eefa132989e2f20ebb7aa0010f2e9e8791d31755cdfc84d897b9e669a734d9266dc71dc76c5d9deea734246f926a5c5fa9c8d1b8e5efc7e37c1ab674dba880c5c359e55da007c13b55c10ca8ead98257815d05ca1c18531d5d065559a0d7d302f044f9f757adbbb1c01bd2f1b6cd08298e2c526ff40b62d564afd32c32b8a99138667e1b6ef9fce21ffba036ac5086175877500a54072e8d408ba5e97fc780d56ad92942bbeb108bdaebb29ce874a6307b621aee12da654c4b9eaeb9b9e643580e0f69531b92c3a02088afecfe3b4b39a4ae49fcff9c225547be22321ecedd9c031c09ca3e515fe093449ed2882b9740e1c2ae5fa04f79bc8a91ebdda3036365bae2acdd92da5152611bdab3e260e84b57f7c5b35de6af571d2db372b0d85a7f9498de9e4d8a09aaebbd9b2311acdc2db8691df9329f6b73a2332b6cbf6dda2e63a5d1401a1ca349c500351db6796b18abd5e4851370ac77090f88a9ec98b893389e617a196a47330b40c5bc22650ce92a50c8aa4e4f6fcece00bf56a2b0fd229ea91761a9ff7cffddc609eb6bed6cb395e85d89765c02bf2bc3e7ed95bf8f08d003a4ec33ce10a4fdd1439fdca7fb50ed260e33d8cb7601fdc7a6fba75e2713730f5c1fe7e3c650b548c667e4e97f344e97d21bd12267ddd0ce62e994e61ed1619acf641dd0831e5de4fce8c4058a4a95d6a4c97c43e9c712ed11eaed2ad65df253a8e235269a5548677688a0f6fcaade10c7d49d88ba4d1f706906324697c834000e75932f861ab1bb05e2de23c279a5c9d9a4124b804080c1961c117cb68949320ca0cf86b1d52563759d53295f6b561ec0b47f2600b188e5fd3850efdc96c9dc3ba62e0fcb114fa9086884d3e1f399d869e391ac6ccda4c03d24d75548f2e999cf653a23e50d848a302150b3580ddfdd8f4a352ec791e1401c930e657fb352326f0baaf0ce237ff15de6c60364d2a75cddc960a22f304e2d6dd2ac83f9f78f04d4a1a43799bf3f2ca3326fcf3b6cf0524f19572172cc5efc57a1451298c3a2545a2a22b0a222c737b62c517ce1ecd53f6486c171ee1b6f2a4ccba765aa38e60c1c5c6d14ad23e45788cccd18c2cbde0d37c86031c1588c09feb23aebe6e641210818ee0e99d7af037e356485e507c3fca0eb6564cfc927a67be800ed84737f14b2a4ad477af58377db6389fb46cb9ac6c7fffccb721730f26fbc2a9e60c39e9df8d823027c57c0da86959b4567fa3899f57195462c20a08dbbb5b5653ca20095269c86725efcd0ed4c405cfa5c03d743c37b0017781ca01fb37e40dd61e62112590a43994ddea1d1dec5767b65b96d67e12f3b5a204a8c74747b9a85bed471eced46b33b9b0f961879fe94a6cc83f98bf58cb59cb218493ad2a8c8840946af5c5a8c29fc9481494deb5b8ea7f2046be255f0f9a61196d9515fb82086d7967e962acac1a1ccf144406b337a12d0362559c6939e88086a441f22c4013c15cad7cb07d6b81ab0dd0ef69430a282daa98e1aba485cc769c2026220b9e151ac64a9457bc172621a869795277710e3938a60c1005382204b3a6d50130ad6205b9e17772f93873ff9109d2c8aedd0bf92613e6318b58b427696c38232758920b4450625ea25670cf605e6cd634e0cf10710c2d42732aef9efebf545aba70eccc2513f8be413d44723b114ad89c2a1ae3391659b89abd2f3ff829c4d346e8a95661fc651d11ab0575d3c2ce896fb210e6b93843132aa1bd25c04f9097e32a83bf5d48ec6a4ae549a0e74434e8c95fc43e9bef121c0693658d150076c2dc6943cef68de8da269e7fbc8f5495bb35a9b76d1782bc31651318a60431dfbabf82f42e5143c7e3eaf307eee3a9918f90cf4953cc406c108448e35f316bb8d548591c48ff5bbcf5a89d3ece4832ff5209c157b7e25181158e59e6d6bbc7deae001bea819e13de86d34ac7d198e8466e1ec835105482358a79715bb990098c3ab38a7682d8c041fa89840a12c2f3cdf4e9df123dfaf3bb07833592944406167af84e775c713790e0a47435c3bdd44e3c511c441b40de6328e9048111eaad71834a53a859d5fac1db73b255070d744f7c71ac92ab5eb6c580d389346070c4d7067d33db32f5841e1ed9445c803639bc1cf2d018762d7c36aaa3c4adb3baae6c287aad5945f16391ac1a9cef3bad9f944437a53c665f299d222298d9f3b19f3a62db8f5dc1519d3d4493440736aa49132fdfcc3fa50a785a5f176ae772654c9998ce38b991a919ccbe630c3552292750f285a969064395700cb15ae7cc34dff963675572997b61ff9103386f389066eefd2e5a6c3d65b72a11f59b07d364a668104517225ffe71d1f791b748e963c9ee1f7c9a4673de9d42e71281876a6d5de5d2a2c078257daa392858a7f671f3996a1e67e2097db7d217a1589658a4c5802505311a5466348385ef94c98239e1d7474bc99c8ede73af344b1cb4595d5ea14d717472d040223ce3ea01322e7649bd8038065a030bcdf5b1cc3039f66c276f803ced6a33069f099ddcb0805a883f0c2cadf70795d3b89ce45fde4e164c0411948a5f3a727203b6c3fc491e70a8ba548dadc837071457a645a4d38dc7e833b9e020ce243f7dbbd012588c5c409a82de543f6865e4a2f2e300c55f10dea8088add1df8ec36e9cb4bc14fa478c3b4b9867007a9132b2881b197b476b8cdc7b9b11eebdc86c774c70df208d951ccd5f310954ec61b68d4abda1e03150a1c86898c8104e4d52ec95991767891acf8bc1f9ee5d59f6231672cece8acfc86cd7ba9fa2acc3413a145ddd3bf10699147925de6a149605b6d8efc5e5a5c6470add7ab6274401023c237c048ee6f25c37b97602bab34e60c07faa576c37de34f65c4b7c4f382862e95b114357d189762fe7f3d613e3b600823b4210dcb3646fa06e958a0d4291bbbd189b5bfba4796d3a48fe1f6acceadffc3845d736ed3a84c01b28c5d734d4f35d1513a4de27876205d9d02e26577382497c41a550b3d7b570a724ef60df98ac22db8ddf1883b3698f82e6174a2f8d81e4286c33b26c27dac296a04fcc31f27a1ed977b4b60a86cac5bef3fe292bbc9b6327a6fb74178935b087fadcb09188976e06608973cf56eece5a4e5b0bbd7c87fb4c2ee5fd6955e569271d479b70b39b96abc3c1c0a9e2653fb220fb92d8994a9674f85d6035d9f9cbaba6323295ab160ce9004b5b77824ee9cdb8c58a07260ea382d2ba6ae44605aacc3fcf04e98e51b2eaa5bda83d99fc238f948bf7ccc67ffe740f56ea0da2c381220b667e5c3ee8fad2b6935940d78fe71bfa01800c26baab7c1354ab9b8ad9e6a832aa87d0a30c5ff575a8bdf2a480b3a3cd2eca4ab9440923dda6fcff1c45b04c79d797a1cdb0d0cfefb870a7135108ec0e6510c7f3cc95cc145e77dda95cb192a71800a5f0f3a12a84695aecb30c92aac0c6c01b48e8ea79acd37fafb3246a8a431cacb3831e24fd0f110779027f08afa887d9035455c96585a97d127b62344c5cc1693a3706a2e3ad9bbde8a15eb74bcecb399e9bb5462ce30c42e4e0bbccc6c771011c8c5a0b414f3253866ebf56b0dc043ed43e5cd06b7cc78b54df2d5636e973c2f48ddbc75826395d51a4cfc204895501d9a9d66502865d764b101237dbb4ad968ea3c210c3e6035e1c0102117e6b68b085bd082e2831ae4461d08cbc081a65fae74cc16252dff20ea82120ca64142b451f76778ab1f5045ba8c059be0d141bdde6e2a910512b02f7490db6d5681001cec60390f902ead2da7c51ce310030f60c5cad2e2615414c83d44d8a357770977e03fa39139ef6acca8bcac49afd82618d665775d454d064d2f2e0cde10336e900bfde44c318fad3b4593aa31d875cbd6551e366aa8907c06d2d377ab32049749546f0a581f11eb7b883db82645a41f7954eba9cba8cf0200154aefe1d55fa659d6b422cbc6e271088ed1e4511df8dcb8c76834c41d0696804ac905dfd5e7c974edd78a295ee022ebaa8fe73594c860f43376bd7cefe8883bfbe66a665f32345e0ee56dc993c4e34c90b040d986df4fe29b5a7c05e937720f412c21bee0dc994d8750111746a7129ebc32c81b2d2b9f5a460ac27202267b201b669b65875519985f7bd35de23184cce2364f4bdb09dc8a6d52876c11e299f627239677310dcfc43f04db3e3d95d6d8e0c30a728d44e41a8fbe5f88c913050feeaf5484dee940f9d290473936c75204b28b77f816efb1d93f46bf3fe94bc73309758cfa02b0c80325f8e317166f0fab9cb183f3a359b450a9e89c3a166c80f5463d1f9af0c449b581dc76036d6f2f0cbaf5cef14a79888d0b3c8dd61a7f186d3dc4e13acf75451eb003d8485c4dbd7248778c0201da186d0736019696d880bacd3e3417c30d52c7a93e1f0a1d988a615c99b18a553aba1b2b4aaaa4a25b224b1182f0e45aff8e4e342e2cba95b98817d6c1696af6d7edf9f57bfe54828b99517545981f6aa96f3594d433c278c2c1450462f4c3b6cb20e5aa8ed2feac62aa75e5a9d3d6ddc6e9c71bcd947a1516ef682300950306f2254181cc2aa621073fff8fda78035c4f0db34b6aa88dcc587d55b2cf9e53d3562dc465080268ab5e9372639aae6430267c1904030bd16ad1288d5fc98127c84351dd9bd1aa88d0d4893ef8fa412d72b25b35580a33ca1128683cd6d0aaa07649f49c3bb41d9d54bb4377ee8b18334dc6b2d2ead2c34abe827717a1418f752c280058c78e39af19468ddc73aa9e74f940686874efae27f1a9598da1380fd46f28248ebc9f06e0a4be7b335da93572c43a6625efc11a88d8ad68aa31b16034990f6d01f44c6769cf7399a521f8d42ea18a03aa4a3484d5a6fbe358c0b94c102fc4a572fdd87c2d9ae22f9925d1a0cc2683a64ae5fad0eaec6c032490be64bb36df1115f7b768a9077384c479c9afa119a8d9e9152f963dab2e7eeeadc4fea6e2e4488f2fec15c54871e07e1ab3ef90c811d9832c75f648d4b409cd8ff08002f9bf40d7d8c862ecca362ccc37408cef1c1f69a06086c6c2e40d989b5b8136dd492a8d58e65474796dbbb5fb8c8e562d1ab8fee446b11c1fcb1bdccf9cdd77c35235330d8656d9f4f2ba648a92a4ede569f626aa800f3b020a9f0917e0fb67a9ddd4c2a3ead1092e5e599a59fc96d81bb1983328c7e134bbf34a78432f1c22dbd44bced06e1555c79fd9abeefbb781e9a0c92f239419021dab435dacbd1f61145d15db8bd6f3e88abcf5e679cbbbce16b86d3e0048704b0a94d52ed22905f19111b24a6e1a2b85113c949ccc0f4fa82fe8cc055dc639984d27dca45e2ec4d6bccd8bbc9c024de93cfde15b4d0ff8239a25601c465ac68f7cbf4f67139276a62467ce4fbe0456b817bbd6dc80627003bcfea6ab227094b133e8f0f33982540023bdf456184bc624478b6e7c138e0a8d6ae40cf2cad6954953f18d7695a71b44220c0dabfefb0e2acc181b385d7d862ed926dbd5e02a008e561ae52aa5490e0560f091ad83c5e9a8d6f246830a04c5a18a46c1752d91079a6b7abf1d2c3bc04a572c6112cd72ad8979a682cae059e8468f00ca6be534cfde586512dd51dbe81c966d612dc393ea3c20f5b98b9402de45f1efa937cefd9787349b201ab1e3e597818d4c9753eaac414055b56e6391f549c9e898a7d9079f41356e5000878292a372f16f06580016299be2bd5b069ffba820e8ad74272e90b91097d711797d65cfa957b879c77cd0bed66b9664e0ac32feb072886076d08040126bb3a393b6421e42f61a5af269cd0e8919f09bf047f67a2c295cd61c5d4c50bc07220032f01ed5c668fc0a1f5bb49cff0599033f85889ee23a370d5adddc3094134c3ee477f217718f10e1081a261c3bfa83abda70fcba9efcb9433a4d5eeed6417cbbb6029ab0b81820bca8bf4e62dcf6e3b3ad1fdda91784f3e0a8eca3c371d565ec64165046bd5b83ecee206f82612b750527ddd9e21fefaf4637f361b2d08685031628a1ac34c1eefb54648b82ba40d6322fc349cc9843304ca5a0bb2096b9a636fcdefc4ece4d9a38bc97bfc1f1f2f08dedfe3b0596e6d96f79101047aa8f2df6de882f25efbf0e1413dedb51009b5dc513ec1ab2dfade7d1dd020dadeb24bdddc392132d673db219ca688ae46b898ff12c3d4abab57be39ae14ca03042ee640424e9045d25c9d3ba61a42356868ffab35f78b8d800a26c10185adf615589693821aa13d539dcd7bade7ab230030420e4d4946e5745c3add50a21346d4d98654ac1636f3a02e4aa234894f7c87067bf7fb705ffadd0ba91beff8bd55376ef0ac518692f73ab2597b3c2f67bc29a25c4acedb63e3fb2f093099152d0af77af6a07fac2a505aa2ca7ece1c9c1d0fb12e09594619d655c0f1612f397bcb398e878afadb9a69625002ecdaea1386df34a695a5f5daa00903f02d02e160939a7ac6ddec3c48fcf222291f62365c1c737bf4874c5b18feeee34c11d5311e7c9328ae4baba9d2b67ae6d93deba665540a787042f42f1b15f8287955079e4abd9e7c819397040305ba87d46bef4bda3e747b28daca75bf0ca95367429a65dfbfb258afad07c8671bd6c499af8ce7da8abd47e6f727c7c8a2c5bc66a9a558a6befe2d37cdb7173824df8cf23bffdd751c60f755aa1c131b2a29f66be455395dfc039ce0adb6d66f6ecd89ed6bbe3e501c68d285ad42fca106275686cae729596e4c716379b0b35c1dca4ac9f13b655dd661f50ef3ff53488656e26d8281ae9c2c450cbb7003e06e5bad8098088218c8cfa81a17df248249028d50644a0e9facd1a6e4b1b9d973f29ecdb0c250aa675ace4beacd3fb0b8c174c64afe37976e804c6c9d0d8147a973a7ccefb7f0ede3bebaf420660fd5b9a18458f6dd3bafaf4ababfb8e6457e1d895da355f6f72b30f5cb9850e694c41110004eb643b4a79a2d31528e3d10d7a635190a86ace7b059b9a4199699563cf44399454c763220263794abc5f67911993d40e75e229f34e26ec14ecb11e908143d87b97e041c63684d13a3976cacf0432d6e8cc31d6f1210dcb8c7d3d23997267b8c71c6fa78f87caceac8e1ac7d26fe88d1ace5543d5f2fd44ad1938901328c4fac2effe25f6a2ae4a43c47bacc1407c9b47eb53e24dfc28dee74c3f0ab7f4b30e51f5ec7e5f770fd461cbbcbdd7720238e1f2629a255d0244a33610aa44c326787e4f4d45c15be7ccc86af6c0a1ccd4ff64999e566a23799aeeeae24e51f2fcc60de08936b4a26ea1a27a0756be82e3e2b406bfac8214df2a66c0ff7e017c2ca11cbe2399a6dceddeabb4a5cb6a1c0f8d408b4eb76ff95b7721ec5e4fc8b92b3e83b306d10a90c77d537fdf9efdecbfa2357f0ad03c5945a4cb3b02767050a837b3baa2346ac0a4d7ebd0ee562d75464d6bb3a9a80ab9aebf6b511cdd1d99775b24d8f1f2d4c355f18708adf857218ad35e4fef1d5fe9dba3bb80a308c76459f22097177361a1784e065e9dfd243bcc6ee442a5609b1c8765e0bbbcb20f15e8fc2ad48643b4dee7145a68ec90092e1f432ff9cceff33e5a2e3e6d056060876b4ff67c35df666a28a2792a36cf0d8cdea05b188b4019eb53fd9ec27a23f7c9f36c00e2a91c8402eea5124b5f881b01c59458d750bc32ff115781a778f0a21005882aa3fe3e0238db1d8d672598600795726256307fe9d818391e9c74c40606be11630b3ea3a45adac56542ab726fcf4d702585625fbbe3782d5ed1472ecf2f7d2ab84947fd9e70a7ec91c5df633bf844cbc89ad8a63c40b20c42815ebe42032983158ab8a37967bac1f5b0c48d942446c9e470be72e385fdfb579af38452037a294bf9b30c3b9e46255d36008e28257f2e1524094932b87d893042dbf8e2f305cd08d39c1b61630dccece0671a1320c758d22d2660d3dd4430d088d8398b4f5380c8b55e0a9bd9cd93fcf9e856cb02a978064ff6c56048be047b607855f0628c2a3e53cecb7e1d3c7deb8d1b8b711a19d6186b74cb9955c5b86588127cb2901c4e51a90e0fa0c645664dfe06f3b6d8ea7a2c83984be56bee48be06bc7ba53a4c5424633975e0ecef46949ae8aa8fe8bdf55cfb9ff06a8dca74dd70ba4e57ebc9205bab414f4a2425df762c53442b2006d733b83a8daac72266abdf8d08538d5940db01048cab643bde6c2c3d19542f57d17efd69008c4a18e4b6564f464963e41391d423ea7057bc103f6a26a1bdd77a1cb9b8b7c8378f600e64635434fa961ff1e0cc40786878aef1741f57a2d056276268b44570b983d0f5498ed4c61db627d642685595cbd7fd9a80229bd374955e76bee96b123c0561119d373d5e798061432025d9ab8dcef02bd70f686e96462c7795ad92d4b05506494abd2d48ab7ac9e42731f1017b815791220853f5505b2314e9b3a5af09392ffb5cd38e50ef617ea93a7b948eb55d171c2e9b0562fb3ea6ec8e35c1cdebf54f9ec78320b32858af1d838f4904eb057b29cc0b6430428c0c771347ecd1b5aaa67f1cfe3b548340e794c5e1b50c94880e67b4a452c64e64fe96ff90cddcc6b883a6c5550e72a04e1c4950e74f77cfe13c4386ea2afb6c315bb5ee38f39f0d38202c773a3ae4de7e99c42c4ed4f0ce57a98f996edc7c698de628c3b82dcceb18380f4b1c9c93310cb0911cf32562607e72a2d38aa2b70a6f0d2d311836cab12a2e28b18b2fe5187e2e69ee859654fa882c81531c4f1b720f7e38fb75087eabfb1995798b1fb6b4677e8864196628ac4f68fcc35b811be4460442ac6f2a0f2b24359d4ea5a4ddb660a8abed8fb3bb79eedb9252a002592fd715815022f35c9626bfe8f297b03fdbd5875e63d18c3d6f522d348264c0355b77e11dbc33e35a1fedeb332e8330d535b2ae9b8f4d07938cb8b882ee702134607382642aec340fe093c1c45e8b45d7b2f425afad9f00ec88884f448b46447c9b1dae61c905f6659c18eccd1e395cbd8988962432f11935b385f21f7373a3d51ec33212c4f3c0db5487acfac56562a91de86ed70c67b112c3962957f2b6da0e3395bcab6e865f0e92521523cb47d912e306778519ee41e15ae4ce74408883cde0464f27d3d84533a28276858e708b97aa9a9b7407cf9a1aaf4fc684d20576af1264b73bfe8ec9251647afb3da3c9a13588a2fc609115e97200ef0578d2fb1a72dd66c3ce0a84a6f10a5f9242593f517be2efe4b28fbb284e771334c6bfad5b7fb0077a659a1b478d80829647b2d145b5b5739617f51b2999fd79ea209d568216350e546940944b8c4f4acf5ffbcfe164d88c0fd0a003b249e501798cd3f4ed98bc80e88730b2444525b3b2bd541249a3a475b867b8d52d0dcf4333558e471f72d08d9f7718bb656c8236d16a78b00cd13265d222ad9fbe710c19e534acb4e47e2fe2016acafdb134226f71abaaacd9009710aaaf986cc4056f9d7c42abe853dd65d2af52aed838ca38e2c70c871b82a9c0a21c07d2ec227fb43f9c8bcf567b945e361ef4b52ae5025352d3c542e3a9c0d98e43f03dbaf9cdae63371f49b8c5c751bcf1879633054709891e8d9940e7a3b86d8f6f9445abf0d74c90c514e5406ceb233c9d113f5bee882dfab0f4ae59301c807ee8aac9be24b1da1aa5d2416e2855dbb07b613bd4f5c6146f9a2160d1035f89e7c900d192f78e02c924ba8dbf98dde490fe8978523fde21aec45586887f9c79623308cf0606e5b7bc8438d79e695159f562abdc15e215f2a66ca757fae533582a45ff55e20d85aeb90ec50e8833c60917627640ecd845b1dbc2d5f133992f35e94ede51c89eb8c73663a13ffd94dcd85e47ee37d2376b73cf20655e638eba835f6e68ec39680b532b56be00ad5245806fa0073308003f4a0031f39e594806b15bb5c7e75d067dd9277a0ff96d07b6cb16f95d3a9c7808cfaa865190fef4115c856d7e1b865b8938dec551c1f1778274f8bd605f95505e7514e349d48f79dcc59a9eda1a5e313e5e0ff90c0297c9b9b9ccc1f87243b62dc8bf96d07bc7461e6d95e9cb12b570bf74222302993db619deb6c2f3b226bd12ed0f70f7ae482fc23252c201cd4bbe97f70c2ebb03c473c123a8b2b99f2082f7f6dc4e7318468174efc0d77d65ce0dec2d96f39c5e44a1601faceaec84d1b80fb0ad376bd632a7452dcb4fb5db75205dd1a0d7ed21862f03d4c3f4e72be5d3a6d5f02e233ecd791cfe0f55a95ba270e0c3b5af3fd07733300fdbef247e8f2adc1f44a737ee436ce2d2bfdee69681e3f37667661cf998a2aa5ea0385f3ad9781a63f86c9e3aa96546dc89348738dae413b4c72a30e73b2b42cb848f7e1265ed3537a7ce6be143bb6d8fd5253d54f9f2edd6cf302586ef6301e6d938c57d9884f53add9ee24ba374d0088395bd15aeffc7cfbbe0b8ab2110fe7243fafc690f9907f9713694d5323f929103df8034eeb886fe38f73f2c3586ebbca490083ae6ad5403bf88665d997db8c0cd96a32d5d112a753b34c37f4c3536b4c095b5ce6b73109d56a94bca626cf8f02ee1444541b9d4d573981e353650f8a140c9e71dbc9901326067f862681de944305cbc64c4f2fd6a8bfaea1fe84261265ffa79161bfc88c24fb93922005b440b1e5dfade77809e79e00315e4530f9a3cf28b234bccd2e0814d50bcf9be7891964353aeac06e3968fdabd397d7cd435ecc053addbf8eb021c1320ed3cee4c9a602118dadf50b9f7c995c1b0a238b77624166c77e0a01e939d7764eb34e7d2fc5854a1daaccdac45c3a1a2894b4fc0189b0084d44661dd3443fe0ddb6c2a4e7016f8af148607e59c2dacce50eed6c2987b487d939225ee5b7f74c3b0e0fe22d9452ff0f4d662e86f41471df369c4c9ff760da25e9ab988d57d0f6e3698999269df50c64978188684e55488a3b473691c07548f48aba055857f65bcc11dc511202faf852caf92be683d6f67ec75b72c1f800c7fd87b4af78bf15f4d9984593c2a2c671df13119bc74555925f1dd5836922f5dd8f","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
