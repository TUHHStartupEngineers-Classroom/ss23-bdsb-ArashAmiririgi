<!doctype html>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Protected Page</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0"/>
    <meta http-equiv="cache-control" content="no-cache"/>
    <meta http-equiv="expires" content="0"/>
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT"/>
    <meta http-equiv="pragma" content="no-cache"/>

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

        .staticrypt-form input[type="password"] {
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            padding: 15px;
            box-sizing: border-box;
            font-size: 14px;
        }

        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #006a81;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #FFFFFF;
            font-size: 14px;
            cursor: pointer;
        }

        .staticrypt-form .staticrypt-decrypt-button:hover, .staticrypt-form .staticrypt-decrypt-button:active, .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #006a81;
            filter: brightness(92%);
        }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            height: 100%;
            margin: 0;
        }

        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #00C1D4;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }

        .staticrypt-remember input[type=checkbox] {
            transform: scale(1.5);
            margin-right: 1em;
        }

        .hidden {
            display: none !important;
        }

        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }

        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="staticrypt-content hidden">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Protected Page</p>
                <p></p>
            </div>

            <hr class="staticrypt-hr">

            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus/>

                <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                    <input id="staticrypt-remember"
                           type="checkbox"
                           name="remember"/>
                    Remember me
                </label>

                <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT"/>
            </form>
        </div>

    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["encrypt"]
    );

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        ENCRYPTION_ALGO,
        false,
        ["decrypt"]
    );

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey(
        "raw",
        UTF8Encoder.parse(password),
        "PBKDF2",
        false,
        ["deriveBits"]
    );

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;


function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = '';

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;


  return exports;
})())
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
  const exports = {};

  /**
   * Top-level function for encoding a message.
   * Includes password hashing, encryption, and signing.
   *
   * @param {string} msg
   * @param {string} password
   * @param {string} salt
   *
   * @returns {string} The encoded text
   */
  async function encode(msg, password, salt) {
    const hashedPassword = await cryptoEngine.hashPassword(password, salt);

    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encode = encode;

  /**
   * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
   * we don't need to hash the password multiple times.
   *
   * @param {string} msg
   * @param {string} hashedPassword
   *
   * @returns {string} The encoded text
   */
  async function encodeWithHashedPassword(msg, hashedPassword) {
    const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

    // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
    // it in localStorage safely, we don't use the clear text password)
    const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

    return hmac + encrypted;
  }
  exports.encodeWithHashedPassword = encodeWithHashedPassword;

  /**
   * Top-level function for decoding a message.
   * Includes signature check and decryption.
   *
   * @param {string} signedMsg
   * @param {string} hashedPassword
   * @param {string} salt
   * @param {int} backwardCompatibleAttempt
   * @param {string} originalPassword
   *
   * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
   */
  async function decode(
      signedMsg,
      hashedPassword,
      salt,
      backwardCompatibleAttempt = 0,
      originalPassword = ''
  ) {
    const encryptedHMAC = signedMsg.substring(0, 64);
    const encryptedMsg = signedMsg.substring(64);
    const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

    if (decryptedHMAC !== encryptedHMAC) {
      // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
      // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
      originalPassword = originalPassword || hashedPassword;
      if (backwardCompatibleAttempt === 0) {
        const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }
      if (backwardCompatibleAttempt === 1) {
        let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
        updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

        return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
      }

      return { success: false, message: "Signature mismatch" };
    }

    return {
      success: true,
      decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
    };
  }
  exports.decode = decode;

  return exports;
}
exports.init = init;

  return exports;
})())
const decode = codec.init(cryptoEngine).decode;


/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  encryptedMsg: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  salt: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { encryptedMsg, salt } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(encryptedMsg, hashedPassword, salt);
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === 'function') {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, salt } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === 'function') {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;
  return exports;
})())
    const templateError = 'Bad password!',
        isRememberEnabled = true,
        staticryptConfig = {"encryptedMsg":"b8deb804f59d73508a0ed17ec273d6fd1e18966e174da4bffcb6431cb4e09010ecc468f108f2b831d425f3a2ebcf5b33616974ef38bd0e11ee0c5fca7b9eb7e8e01d3da56e35d6bc6bacd77cd78deb2e00e31463ac45998759274f0e55e7034d324856adee3248743df466b51df3ffe073954fbd8f1fe1c82c62e12f2fd3a1f9dffaa1426a33785d2400ef730c0d95363929fde1ab1a30ccd7585b80342e49dfc7b78d1a5e87473823bcc0080204df31ad839043e671ccff2be566070fd7f614e4c0c89234a255fa987a5d08914f9707c7a3f5ca784d281de17807a55f015d060afb70afcd65ddfb03764f189a26183502e8eee7b10d9fc9b63a15e115e3bdcaf93da835dc77d561b12612d555354a550ee5f29f4857d64c2e954f61e07687406b88cfce84c1b2a516168fbb1b4398b6839e398e0cb4815c8369932aea37221d82534d31c756c62eaa141ae301fe4b1eefb0ec2b323b8bb7126ee1a37c53975924a878e519440224e51c679d33ced8e97917d6cf625b5d32900904160e80192a595e7d3164257613986e57d3ad2408b1f8f9e1a2a45903e5dc9bfa1560b11fd9d9aeb9f422a8b1e6929a9335d42672ca026d14452bf1fad3d90dd6239c3111efaab1b64e053ae2bc3a186bd1095c2ebafedfdbb7e6e7e379691988c8d249d8668ea20821bbb2f0240fa8a481a4a0292bf3a8760b874e5483b7697d00798f1dc4938ad3c1677e9b283864007f6c17586039480b685f9a388d3ec30881eeb65b51c1a484636bdbe936ba6ac5ffc4afc1a7ef7f11561760a0778a08b8c4ad0070b1f5935c44e8973610d4b7a00f635cb7d80f845e41dfa6da34e72e1921fef17f561a3ddbbd7ea6561cf7065c9f32ee2d176d000b0e2dcae1b43d1852bafd7fc67eec2476605074dbcdebc171bdf5572d05d848e959522ab1eb88b2f199ba63c08f87da42952296fbdc5a9bc9da81973ea74dbf038e241759a19cb0aeeb980333583d627b4fddf21859808d6047905996b1c79c8fd391d0629a2a9928a15dbde4b745aff5ad3d77887cb34d0bbf8508eeb9425435662f7a18023a0d9bd5da0fe89bf63a05351697481a1c950e1cfb2233c4b4dff6cb539911013b29a99d7844b184af058de2d2376eb340b6352bd56b713d5ef3cfb8badda692c28eb1f7bc5e0f010067f28688b5f89d8f02268ee668e1035ba8e61ffed7126031168e4e0d21818fe62409b4c7f6ad10cd0bb5f131dfa7eaa795bcbcf07ba20979d5189c06b0821bd8256ee1fd09d1998c3ca982aa5755d2120bc8188b55ca5aaffbdac742fb665d797cbbdb24ac5b86bc467cd3e5b238c1c40e96bcb12a778ebef12e60695d6036c9bccaf2e264910200f577989ccb08ef8b9d73a7eb22d398b9474c99c1e92a71473eb126cdd5a7692e6ac7bca604ab4101fe1a3fed3294cb92f2879ed64a78301e771ee88bd826f85670228566114abb87a4210a00af7f43a0acfae9b09d3c6aa6663eccf64648b0f97392931d63a81d06d78f80283bc282f948d86e2d1109f8104165d49a9eae162da7691b0c6803b5dca648da40c195687072be3f4d0629a7fb6c120f2650f2bf80d883e880d2e1c6b28b227ab180e2d731569664fe3d4db6437eae862afe1047f598e689b0b3d12a825603a6b567f5b57e21ed6915588c45fc7de5760c7d36878c6d42623396f2f7a27d1f2b3eeb3fb5aed71694f158a393616134d51740cda3ab4bd1f813dc6d57e382ba962b2a2699ec11e9306facd600204b953a7683e5a2f626df24f7519a3016d6e0a3cf8d6ece231290a1c4734c9d80bfa3efb42094cdf968b6ea3c9eae4bf6977931e8ed9acf417e1001a274a00a220debc92bd86cb7feb20489ced575cf2f316d418c0c1572fd03560431671eb8d808e5cc8fdde7a33f4f72abc9654407586ced7fa0acf6e18db88aee96decf4b006b0e2e3b5dd4d11e85d439ed09ee7ac8dde4903dc82c4509c7393ea6a499d96a79b4f13e761a1d12aa7eaef62fbce2674f71bb18b1d4988288f874e3c5b83330391fdaa8602490834106755f13683484596380291ce17619d3103dec5f0054c7be6b69ade3f9740c9ab031923af8312ba5e2d52851e788ebaebc681ba5c803d73ca68fa43d57713afe024c4e72381eef2c87bdfe4077677de779120fb030a80928985c8a48ebd456af38c587daddd180d50f31a740d7bdf65e76b45a9d66d26c67807b13382807f1d6eefe223d6fd5d162b3b1d8e1bdcf3a131f635f82fbe16134e8dad19881a629d03123a38003e3c046324dd4e80351fa3059a536975aee6859a7336cf1404d71caac94f9dd3e91ea3ec572042fb43fc5d78705e5c66db71e69f7ed982f36761aae2c81cc64dcb6a621ab2d1aba5aa6eecdcece45b8fb93bd3ae60555b22c3d6498cda57ef1515888f4c346fdf7da1e197c19b2951c2a65d8536d7e84eee1ce0abdea296ecac7cd097c8dd4e543ae4961f3e9646c54763a629efe019aee43be6332ad2ece012a937b78455d70f12efbc20f88622afc375a081ac5947df688e20c33e44ac66a942d246b5250fbb496fdbf69ed130f6ef373095c535c707f7aca66915a319bff7a34399f4a2ad04dc20d6a4f104b9b6a0fc6dc8a308793fd301a0dbe164b5ab3b287b03b0eb4baa2d7ba357b851017cb230da328c36865bf6cdc5f859d2765e1258ed1ad0c8e4e7893648325fe455f720c21ffd9f902b816c443d92b12988d6ff45198c646abc610115e1f2cb05e80cd4e7f9d1136155b337a7a1ac1df9512d6b0c3605968c8ffec63a573d1074fa7d91b20dd53b238d28674b123aa098f2adc47f99b2ddb6fccd22dbef3f2094e961a6b83dc427c479e6c330f33e587f0bdaf7dc783e99f1f43e9ef390710fea1426a3936f046595aac205e7d08fec3cb95d04d063f984ed360c3d25845109e211d206b4a9a6e308ac0bb8dde2c106b39329bf6e61fbdf1165902b07199756edb687f85f64ee6fe685caf72ae7bf1415fcbb5ea9a1bc364a15005629e0bc627910973462eb79e5b7531c1892486dba44ba06c573d0e73f8ee2765c32de1801b88757dbc552c0a5c957d6254bfcbadc5caf49f8f8e93ff8e60f0e27a887fc7e03b5c89d5f4687815d99400278959a9018cfcf44c9b9fd1eb8047689e22ac6b70c0af51b74a1564170db1a43b7b400ebb78bfa4609295e2df4f5edfa9b0c1b920675d1388323d6729b3b28ab8bf64011f5569b47b64bdf5f8e9dd42fe9a3d88c3687bb06bca7b840a4c295008e012e74cb96d8fb34e34a07bca6520985bcfd4c90c4c7e18dccebad0e74eeae54dd8a38ca87f4309fd9713acb8f47abac92509e2cb7056accf0a1f9e182f130d9982be09aa36bb469ee029626a05b6681fceb0ca1009f1c4b5c64e104c6e94164eaa1a1ab31b2354c72d848cd43a7d0a57dd0f47f845abedc9cc7436c1de9389811c8ec1f9186a835053e4024f57ffcd248a49871eff4c6096103ffa8fd15b872fccab488a778f3d47297cca03fc9eb9fc29f15850e6061ff632a644b1e456da06d6c61c65eb7e458d4ac9197a5c849be7d5590d6fd2b2bfd85f5f348572db5a58e0f4f33c1b5fa64830e36f68d30cd2a2725cba0a5866b30778c83fdb2ea93b669ac6dcd19720a2343fcb52d7650e695c92d062ae29aeeb91c7666e7edc58050055f06217fca24d9cd752d18ad93625619634373ba664bd0ec1652cbc331eb711bdbf75164806769a0598198231924cb088284f996bddce6170f6266be5b0c11c2c83f42498040152899890f8ff3969529d9acf41c9add65d001bd09a24bb43e1c361e23918326861be437bafe17fe989df6945b60f091dc9ec2dc45ab08ff9b2f5210c7705ec385d7a64fe6478fda34b6d965f5f57f5967e815df2ac5ffe181d669dc9601c05062e22bce4dae1243595b24c0ea82316dc1b8dbc4ac0a03bba333feb6d82fab861d201c905d4932439f7397f135ee700767cfe42710a333c8c573c5367dfa1dda9a5631a99fb4b3ba28a34178bdb3c9cd10efdb769f30fc159aa0b003165ed1decb04e8f4bf51b52aeda3a86a525f7564f6bb11d9c135e92a7bb34105b066e45c598fa5fd61c44fb0c3dbd0c35f4bc9348130fad224a4168a1371335f21ffc24df19ac02006487b755e6283b2c6f5a055f57126d1d6f1ee941694641095c5bc1bf6554ebb49b3369a62a2455b0214bc029b48d280ad3b06559cfbab0a555ba19530eb6f7beaa79189979074914e28a06ce42a497d290b9d6b2a86952d7a082f103f3781e929264c7de148a4a2f96f8bff0baa81f8aacdca6bdecfc311f4b2f91e0951e4f7d83c2ff0d6269e696a3db1cffdddc85efc747d68539f714e522b9259300531cdc937f7d2d868224fffeef748341de1c5ce440df2c199798be849ce854a88402718b83e35368dd45f0dbac1771b4e5b77cb2612ffa4c65812d8fb9c3f1ccf6c71a68a01256645d60dd7569c4530cdb0bdc2a6dff23feec21299a9592a42b1da30d5f80dd9c7df221f5ab1df167c4cf9686ab2681658151a6321804585fc5a4ae5b6026066c812c0eafaece8e3caa1251257200f29b9841fda5c80f884ec3566fdeb68e1458ce8e3c2a2d69a68ef16e29dedd4e9b1374e27813dc28150c54d2b6e9206a97d56c199d86c340f7cebd8a527769c197204b2cfa248df97eae577535a7de084083c1e7ca71129012204d93987427254424859cd873eec7d1bc723a4a4564382d61f2e4ddb1a56126a867c804a095b0bb372d3b566766966a53cf5548e997d0dab1b9d0f03209056926a919cb8b5b44867cba1ce7e0c1ad64a65f7a036414c616e2308525797e6032d16c081c1f476808a9f0ce7ea89af6cec36877e9713118af7100da90fda940480d90a589fb2b3003bc81db9942c6a583bea9e10c8dc351f5aa6470ea01ea39937bde932a32bebf0ba6350138129af407df1b575db6dcd906c0d1f24f590a0e72cb43486300df5adfc5feb490609fb659a65ab981cc7e4cd84d457bf8d5a28c57b8dd07642aa430ee25e2a627aad5c91d270758e7ea68fb3456b25914e363091ba35387a4dfbb7cae178d0d59a7a97d819623fdd117aad9fbcc859970b1f2a57e566d80a9f663dc5d7d32a6927beb9cb5a1698d2877deee21038ee8ac3662b8f6cc873fcb77e84a86143c0e3be00a47115923e148b3da4c3f96fe71556e84c9d7d2028f9dbe3cc9776096894c17a98a2f4075fdb9af8420233e748bc068f1d28e81dea923b1902ca435e259b11aa898cb16ec4f57af4d902499f683e49d8ba81433ab50ac346de4dd4cc841bf4635bdc8bfc548810b45a8167a04f2ad020d336def45e11d4393b4e803271a5b0e8e3377facc870934332b4b75865f650649c92102c127f6873dea3ff4bb61dbe907abf1320c6b4e094f202f5b81dfbeb9c0b04d5ab69901b517cbd14777d5fe4c21e1fac38b2b060cef977f4cd22bc6fcd80e28450706e8686e1a87b2056d131b529d21beae754f88535afa41c86d34095bd0ef302091924246293e57d84ae8f7a729625bc0df08040209c2bef55c2990903d267ccf65658643ed99eda2d757d86829c3ad5990331da4f1f86211bcd52c169b93bf98833e0fdb36790503d7c11be7b413edc58393e3917e16c484c7f47d03055f9c12dc2835cbc9d14aab45a1d54e3f6f6940f948415fc3bcce3b919b95e3d7f938484cc5cf2a6b1694b956a64a7ac1c77afdb677ad0b36b6009f7992a910343bab2be213a9025ee35543e2458abfb4cb66e64bcec1f6465a52e82005bc7f1badf3f9a02493d99ad776d948abc17f61af2564e7e1197668229c45098276141e0889b453db96f3d56ba6f609c0da9bb78930be58f7d2fe7339ec89a4bb47f7c7726cd486d30472158a568d192399d38bfa9917520241bc26a5cdb74962cdf9d37bc38d4ffb6817c8f6012fbec44ce3097bdb1f0b76cf2a390b8e07f877e08893e127e117a2952a784775b8551e93b8435b5d50a737437df0313a681563349e16bf00dc70b40f1e6c2ae17199cbe21bb7a38622ba8298a20cd6555cbcbc3f571b081a10782959950799ce4c997ff9a6eeea9c13f81cf082b12cd4f181db42e189dd28de5515148576a2216af5d559a7575587eeea83b10162816c5dbb33a970882e64c977a6bee389047ce136bbc86f7af10f51004b09d303a4a701757cfd3ece62770190060651568b0486452f1aa2f52d9d91c890c2d6d44d7a355563c5b356ea537f5afc7d8ca3be542eee9da8aa94bee706ea274cc252698e65e0b8cff716c8fa523ee9ca28d529c92703bd3a27cbdd37859c295ef84e591e878dd706c2c2a6e5128f04ba6cca908f7919446ab53bf1bc76e457e9c0a15ca60d700ff6f8273525ad1a9ff3dad20cafdfb2dc573daa4869ba8d809d27e093097a9146df3196ce1a79a6d6df392c92b7437daaa8fe8f44656c6afd3acd26d0510633ce9f4fb723aaabe89a3a701275ce95edc2112c23f0635bfed8f7c8e3121214e509d292520248ab68a70cf4118bccb919b29a81fdd28d1e3b3fd09622f7c87745b6dea38e18aa9fab822b45018228d5bccf80943287703d8d549eff5e041a79ed8ce42cab3ff19bede60e7d7c50fbc955ec56f08fe335aad23f40b961feb559c3fec9f92551c28214ee23a58699c3f7a2623254e6343cc0a045b8ef196afa12829ab95f219360f2e44f601961fd88983ac50802837f6a06d98593691ee0223ea89005d70e60479cd0dac0f01fa411badd4b1cd52187262957f7583d446daa2b6ac2c6072aa625518301f95d2aa15c9287ad5a15eec2ef7abeb7b12548c26b4f57a6756ed9a62380a792dcc6ca3631c8a4ce00b1d642ca58a8c0247aa0c283bd6983f2a2b1fbd81926b3b82f0b07e1d6a4435ec807cc058f6c176dba9d15713dec43b2ef67b0276b5fc8f51c87e00f6d6f897615cbafe1162fcac629c5a8aab9914b0f0f770b487183d383e1798400c82b3870d71ce49955003ab045e7d2126b2e12b151f97bb60e582c441c3c48d362b9ac641b32427734b4c0571ab3689cd31d34d0ec4cb8b10d5d0fab006d62a58e43c3688f07b50ee0c9ffe72c6ab9b359274d35ad2c23ce84155333718f8d69a8daffd2871ddae4a106ef25b024ed4db965ff67244d5ce507ad8045a37b2377faed03e6aeb34593a1eda24f9b8188f6f8ceaa5b48ff45ec1b17cd264b0f34e48b397c79efcbd310b40e3b80babcd266301f284af6e2f71396797855b5b72c643918108ddb362e9911464bcd7ad358dd7d040a51dc131f25d43063b2c6a4e107ac3a957d8e4fd1566ea281abfd5076c9e865c203b9cf89815dd607e472725649050d432a5361d0e23dcc4bbf2545838fde692efd5663ca6a6bd019581312dc76106a5a15bdd1b0212d47fd63a1532ae2945686d195537e1e5d4a8f95067651ad14e88fe6424c1b10d177ff538a658cce51dd312d1906b7957526c30e8b6f251f0bf5f9cbe57e34e8826ba0c629daa93a64c3d8c39eee127723dca1eabbe2c5d176265f2b6e14beb62815a8e0120097a3a804a740aba1675042a4002574f3f75670ffe39b26656cda4df5b0f7ef4b383fb88d9a310bc4c3d5659549d1cd7b3daf1b9091150b76e55902b66344d24829b399704e3847c614e73e7e7350592631a04da424f23064ba7401937494ec539f3ecb846034b43e22872f9cf4770c775fedf08abf43e68f2fe517648e87ef81b286345513a57c2662040f5e882cfdfae03316c54f30de2f5996f21d8b29cb69eb89828a3a4d63c40c6407133f40e66f16bfaa9ebb7c3ee43ada49c7132dc24099171b7774e64f244c1d9173d50490f1dc0603531322f94da96c9fa5d17ccec76752e9f618d54505a3fbb49fdc2f8701b8017fe71889f31b139ed0bc82cf515e105b59c0f68ae233ca15b9a62c922ca4601634100491e5380a3619e2fc54c7c0edfb909f31ba33843a6554b630a6bcf54450ca938eb9c4ce1362199f5585f21bb603eab47d01fe46935f1ad1052e797dcb6cdab9a25cc1c243490a8e19ea82663540a1032df6307add7a8561f82d4b431e370e757d307f257e605655da19ddb7120c90bc07cb65488db50cdc46803c9f66b35d4226dfe755d23e5b7751ad823d21d3db379f7befe08a41284f612f51e3c3d3b2725dac7795f2995092c3ff66e890ea7edbe4c6b3f1855e9245e9b48a20d1cc2b82680479771f245948d86ba89de690afea1eeba685e90643334c704b54c732ac7693df2f618fc1bcd9338f0fe2356f61ccc2589e7869686ab182be5f4dd256a85f043e09db94906cf68a664b88dc636367abf19772001291ca963dab9f627a257ee574140354372fd2402931ccad4b732d2de3f8b4c9bc91cb04f473e39d9c03829ca67827a88e22848b7f9c704a14da30de1fed8e0061f9077cff26f5188b308090c386609a9e7f880979496055cca681c3bcc1cecc833a513db71a885d779f439cc408ded09ec5e7d2272e11438b1c452d60b46df4082385c36457adca9eb673c72f3b5f08f6a0d8a8b6537e09dc18c722c520658268ab3c36b0ee3f08b516af58ea4c2415f4c4edc66b8eb3da405ec9a43ad0238eaa12621846b92954e2568f251835785863421d2b60778155c215bf9ca2830acb6bd2c8891ada5f214d87aefb7ff21dd2a16d36af8aa9c3c8a64ccc8e65e337de6f1224628fe9a4c8594589d50398258bf6f5f5e528b0b00c331515d30a2f6903c44448c9c3e1b0ee5ba61616cba7c2d2afe58e6a516f9b56fba84401075e71d80b75497df8f3eec61ea95b003e9f8efabe728889b3697daceb72edc3ed4bf195a1b6374b1f3e8195bb3ae9b4e8968f43971ca6cc6909762cc43482c3f32adc06f019d107291ff754739ca52483271b2711371e9c96af91ee1881f9859413a6aec9255278768f90e39288aee9a1649237ee6d6506ccb16e6bbc57f8d40d433b586d3170e224d8f2014c3fa5a66f05d01769b0477aba06ac8238f64816214fba824737b156384faae6386676d879d9e8636dd9a9d279254a9fad10e04379e7da851045ab55633d2072e1cdc8f4bc4dd494dfa17578d8dfc759e8c12486547db3d6b41e2dde6aecd50cc79633b692cc7cb65832fc25e76e665a2014e880038d3335f320110eb0772d00e1b612147cc3932a94354ce5cad569802c9ee10acfbb62ec7ed74fe882b1ecc3c5b52cfd731fcedb34985f54a71ac565225fc0bcee1c1175b95a6fe566b17e50a96a5b00ac5eb845416d4962c0d91105b8dc87ca6f9a0c4910d30ee392fcb91775ae518c2a20ffae8dd06608fa27049a123e0dc4264a6696798be81ee31ee2ea9c466f8e9c5a098a060f7179bedb41361a3ef6d8cdafb3dd397bbe1e08c7fa071b434218dde3c685a82aaaa19ff81bb8d7fd14e4ed8d92047adbd2a2cc4a78080a3482f9e5402bb99afb1e36bc56beae21bf2d71c8126fb1b5cc0265dd11521d9c2659b4e4495ae575c6ea62457aaa79fc4ede98927cb91a969d6c9a30f7aa8696f6138ee40ecd8257d337cbf0308af22c122d7fa407149d3290c2f122cad0fbc38d2708a5fe23f0451ddeffba606e3aee4cef846a03306f954cf783678b4876ec026162bd75f6361857bb3c5f4abfc13c78a254b656c466d83b4a0ea99c7f52373bae782c313a44d2ee341685667138716970ec22548282a5dfaf65f420d82ab22dae2920dc86de95e72ea1a0893a4c40bfd6eef5041e49bdb4431067b0d6e5fd0ff0880084fc50ae62d66309098de90e2dc386a62924df711be642b20c9da67482a72b5872376f466a47a6cff584e3a7bd5edf653cc151961bb6dd5158a9c735fff04bd860d4926f827ad5c0b777a8777234f39eee294f678e575dfb6b9158044a517c0830ce55b7b1d08e4d6c38062cfff389bd0f09f42e65927e9cc1fe25a396e009b1f6307d85e6f0d2487bb996cfb204d526579c1b74e41c39dcce4062a4854ed5e9f2d8f2ff96d009e2ca76878c64d3cdf73cc4892dbaa8ce2c95c1ebb819985a16f346ed3421669637cf06455490322d23bd12c2b48ea85a7bab7541c97f7cb6c8066337cf5b42d0b6637a025b155dc704c52ef13f6656bbf45e038aabb9d1acca72d9cf6ff9cb0be3d7cd89bf67d74b35a64e76eeb0135d3d82bb1d80e5ebc71b4e47d2e937c57a88eded20f59757b6d4cccef1528161b9abf35b9698029d6f753ab4adb36d7cee3cea479029b66fa37520cbadb16c013d5d5fac8378755f5df88bace5f4cc326f749abf882d63096830caead23faec83c3c40b7c8331e8c053179083cb124c5cfd6210bb13984f93b345f75728bcb025b463b654479f683a70566b5dc49c7a4d94f974f61d59341ee8b37148e23cc0380eb43e9bea3b964ea2fc94aa2c18342785dbfb9fcaa18a87047c7e5f2f179a1efa873a690cb0fe27a608d24ad600facc9f6164c0a33c1021837845f8472bf9e38bdba6893c3bfa45132034a74a7c561c304e6b22d2000a138babf7d18758a76eacb668e0febbdb795130fdb01c63f12e199380f6b0bc87da53dca6648399f835e8babb5b306c22e25570ecbf01780d80db77302d37831eaa8ea352fd9603686e3b5a6ad6c0bbd3c3940a8e94534c9bba4ef30fd1c6aa6b4dd558cc316609dbc98a8c06351155d2db76d491d86b08318752bf400bee1d7f87773415d725943cdd61b61a9432cca25736c018a0f6f296cd69f18091c1dce476648643a98202239923ed91ca824364ee08263c783325c70ad2fcfbde2102111c319aae56291fdd0b650978c33d23fc5e9a73f9eecb46743c8f130754e0e25d22055ac0b118321dc8a2d095621b76931defea38c86ca1448a9314c65c081dcca007c99ce7145fbbb4349d60e7cac65d0ab4a9aa5497e86c5c83cb8564c86608e6546fa6ea6d4e38e160dfe97501215d3efcbbf30664e900c9c65fd8c0498fa93de945fa6c285a53eb8a51cfd0ebcd46130b1cc2bc77a890facff33a0502b3486869d4daa1b440b05aef30d0b4965c0fceac0fba999ea1e970c05087e5b32f3326a4c7a101c23129f26c0a39c74474e26e7d3fb99f1ec16b1471417e04acb776222b25e336e442b37e87c4edfba349bedb5ea66760929d2b486d3ad5a072d7a2f9bdfc849f26d82fc9bcf19bb5861ebd5274c889b3c2e06a357e7ef5de5a7006cc76d090035e52eb4d45cb38a45c7b374f7c980b5e9fafdeacf73453d829dba6fcb17058f2848b865cd27bf951652e62a2c3d07dcc205251b2c4f04c291ac1ab0b1d55f246213a1be7944f00ae518a619d6797fa7823ca5a607220031f3fdce50732ffff304913720b49cf9bb000a6c296c70a3cd3d1ae824d3508fc0847dc47dd4df7c8937bd9fa7df046be2aa66579cd8ffae0cb67d87266111e8a24e12e1ddbe5637d6a92c37cadbf080f4248aaaa24b0a790cd3dce2b933c07493cf17b8d122a5568e19cd4b38f04b7ed81939b1224dadd3bd3ffb1f2e4779dccbb6696a3538dbfc6030ff7ea7ccb116464b171864150e911e1bbdd3918c1ad4e1207b45dc7914d1597e1bb1c8a091385cb3ecf2c5660000568a0b5bc0c053b9a8799c08a96a2a3635d98b783f80c491f3f7d2658f93bb6961a353cf5b5bf434196b69e318fe320fab853eafef7d12d9b275496adfe497a9f30da034d7ec9169bb783888220c27b552429e4812218fda90b921e6ee6ce6d60f880cbe5fd38b287af61203ec9023bf3a98b854323d78fbdad07e2d70e7dafeb6454af4c8ff06ad0d2031a621ff4a994e75703caac735827e5e81e17f56aa429e5df62c87f41ed1ac806081c230aa6c7930f29020852b419483d6c686bd8fa6264aaf653cf2e272c588787db292c304259a0548589ac02e0dfdf3d2897d15dfc930ce5e802c1831c413f80ef2eb4fbf239d29fa6222b2dededa01848592ae8c811618050412f669826728c61291a736d4768cecdfe3d5a92134686ca98db0a99724d53a81c488e404590fcc891f3c6fb2789ad7cdf8dbcd398eb7618a79c247b50755528afda24bf3f516da0da20b3ef61c6f00de480bf8fd4090091abe1ee35a4f4802d9b89f1ec727c61bf498043d249c180bbca566f5c27617be311af4195d0174c690e82f63649fde882b2dc8075255c7ac360602b86405396d18bca3be5885b7eca8bbc933ccc6a4b4d5e9f3977d227873da353dda59e3ae198932f40bbe4ae0fe4edbbdc8fe4c4cd77054ec7357b774e86b0e340f07ffc650a7d79681825f0c2f1f6bbd098898987d4f42f0577c3fd175144bb5c076095d6d8de711f940982f37b84dafcd211739594e90a2845bdb5cbe3fc79f9c4c1241d733b47e24d24bafedcd9b5061167afd20e08b9bc17304a92c37e0c809aabfd39ce18f4f638243c102b09da5c8e43f9b162016185fc9173cf214c3ee130804f26dbe1e81b82cda0863d8239efbf3c2de9eb7d8d2deb24cb17525fe4a2fe751b4d5be2ef4a28ca58a4f72a2a4840ea7b062feca5dca9a38c6f2ddc8564e07be0a1dc07a482b5c3ae0d57d3015ed7cef6edd65c35a132ba5b4c7b37e8090e889360e406d7c667a9f27ebd57e48db2ba86125511e22bd511ba49171b067c45f1a01bb2bb090ba495e8ea45aef5d275538d39443a40a590d45fd6e08359540778149a59b7c29e243646551f1ff08e18eb36d9cf5557e7453c9d0b0923b58fad39647f4c64b2544ddaf33271e80e48da594f8df2a0381f0fca7f689d3885450353a02fb51b52ee94e0fd4484a2654d39efb338566403bb71c5282152be2b201e5d0f33f7e7f6e246c7e7d33155bce20536dac96d4cfaa5730096430f254fac8643b69b35b7e896bb5b4959be65339687df4d9563ddb684d1ce47766eaa07cef75fd41dda0a8c97abb6ca406e6373edee1b9816e2bbfb5c0a57f1e7d92b86cda30544ded262747c48079c7fadc9ab746902352d52cda505f2d1acee09dd6535ab6242597b6957489a580a039fb03eec28df1dfb1c64ada8d731f35cee6d0169adeaeb38aaf5236522c51fe115d77fc5431e0dfb86fd42971813836d8f8cd7053dd8502bef38ec960f2ca81dd94c655bac69fd2e88ff57dac38efe2b2f3ed7d9825aedb5238a41ab895df2bcee2e2c86449d3d7a9d5483a82611f888c9ea645931d8a006b0915e70fabe2d663d7be837e829730497ed9d38dc7efacdc41732524d159c0ab70c48a769b46b3646380f21e558b768e16bdc68b3ffc12a1796e70f75cebc31d9b911788b6611c9d78cefb5189174be826e63e10b793f22d076f0f65990f6025f32ccaa3a4a9da02709e3b9ceebfcde7e6513d7740f54163641d621cc1d6eecb316d550cc0f94133e66e31af3e6cfb6469ea307bea540d8b76e92118bc7c5fa385e0a45a2f39f4c6c568303eac025f50d05064b93d82f8c9c02696860fdb9dc40cbdbe972dd51ef0380a27b84f85561066e0367e175d4783ab0758e8ea33f6fb13fbf2d351da2e9b97af6fb9d7ccb77ee638baa5ed6b88aa7e64d3ee636c233f0c704c452f77ae711acf8a6f4ea250b4c0de46bf6441a02565eca069259476a506f522657ee7ffe0a8cf1257c3b1888c079387b9e8f3f80cdb78f5f5fa02b401f247ad3ad046d0190a37af39dbd7ced82e874a0a9f447c1c30aa37ebf9494e07767629821e4495f63d04d0a66813bc080566492d7042a1584b027ba3943fc11cb6f7abb77aa94ba1d532d9970b4eda64d92c0df87809c38f1cfa572be656b2cd87eec13f18c4ea586bfa5b5a30df60669935104d0de5a2b7b038956ddf15009c4f19a74be8eb6db2a4fe45996754a5df1223be1664b5ad4c68c3dba1d04b4d905074461efca1ae76204b28977146f7f1c0592453621c2b0148dd08d935b8744d1c1d4efcba86890039978d346fd37bdaacc987a26edf8a2c4e2ea7c9550f80802dc7ffaacc4a09d1711717d1b2a2c378b7c0a4366cdb79a709547d85c38c88e2b766d0a0b882a285284c015cdfa7f1bb8b97d28ea5a62e0181827135592700161104f86b1c2312f367738d59cf1914f36f2159faece28c9d805e090cc8a79fb518800aee11a1727fc34ed6b2b629542337c252f37fe741389e733b009fc97470102590312774c1733f07b71e5f0ded5a0afa4ab56c195d82108d4ade84ed95803496179008b94c80c752b690de5d7541f1581f8fd637db1c9383f3814f69f11a37c25992a07f5183f0c0e305c504c1279d4df7cad0998b7a187cc09b056aeef1ba130f81aabee67fccd9f6735bca6c4abc90aaea6f11484e8b7203621d9b0afb8964dbe7d37984fdf8f1de0319d3a925878d71d58da5a2fcff48f40398dfc303edbccec07b19b726ac329eb4503e5c77ebce182bec09459d2f2449d5187f9e34525fed1222476ac051216c2469d50f34e031cc9cb6d794a2da2d7562cfea829032bde4063f5661dcde8eb3623b81cccf4fc21906e1b02ee3e39af7a2df659b4169fae03dfa0863ef8873cc460b8da0b45d2d53720370033477cd4c263dc0388404fdcd1c83f85d1596b5a93456d6b45e7e8c81ea25ae49d899a92790095201635c828c51db4d99b9144f94b26e1afa17d79be54035d7a36e1c002e2c341a2a393b39999c33c79ab0a0e0fbe100ab286e85c5e28c5641191e768583dc430983423df783d127be6ac7e3c6c290bf82a05ada490c6789168d46bfa5469e5a1326fc3752082a418a22320a9a97e9b7012217580e2b2b6898a1128da6b6f613b23fdcb5e1dcce05befcddc36c406cc493825bc33d64d4f21d39b8afc27525166ef6e7502c9d39d94b777205630fd973fa4379e3942925f97b5e9cbe2c0fc4c61ae3bae0df4bc1cc2452ce010c9212fac74d46c23c7a41fc7a8058d5ae25ec830e187b1385d6494cdc53d8af6b0818990fa8bb66286fd7d68da85c9200a45294e4438ae7da59b7be94b37b5cfebbb4190c03a0539d6dec78a01d50d64851f7e22ae45daa7eaf8f8bb14a00fcfc6cfcf7ace92810dadf3374838ded38e9ce4b6fb363b35bbccfa671ad768cad1bf62d9cc3baa392dc1179f368c6cf8fb9803ad5d40728086c2f76d1dcf6ec71d5cbdf3ff2259ab3f7eb8cc164ac48ce2816822665640bfe23663b0a3fb211caabfee5c45efa1caac4980e2c07f43915409c5af4586382d148b920c3bec755716226d290cfa8140f7c7a7fa313a91419da9425b6c424ea7e382bbd94e845193a0062f2dd28958987f2b1bdd18ff9be77f8684cc971e241c47bba5427feebedd706b42175dd7ed2bb456a6feaa881ad38f15607ce68cf306a401dd9861f83c72197df4d4d9f9731b9731c8d51d27e9320c3fb9c038508596de6378b7f529f0caf2119032e175b4b5c08936c545d5b066e1a65b0c420801036e0d6e7ffd1f9678cc05ce9a23b11335d359c7c4e951f6dfe157ade1d18fa1fe14c3f0f3ee8c73eba997473097ed9fdd9a0094147e5c2c70c759dbdab2dc3f85489a25bf061adb7fefb9649d9a39cd76f9dbe28fe4b5c2b3a0bfbe565b86afe17d0b2d7ebd2bfd4a62748bd5dae67d11f69a90cc9e680d6890ee55488a685aeeeed7e737092b3a290985fba66f70ede2382f463dac491df3ea2625794446ffb8998b8e8ae91eada208a6e97e75cb43635101597981ebe6ca2b60c6332efc769af98bcaffa953e421c1c8d729310d729c38abd5643406696d734eb13c7c28d85438fbc212b23a1a9450e0f4c4682f324bcbecbeae99c5783a60d2a095870015405c5e1165e04c86967895db4aa486ff2c6c171b19df6dfbaa98a0387b41a4928f20dfeabbe4ff2b945f720acf70466f5dd3d38897b431c2725bf58322fff3b0daf451532189f53de775b251077ce5d0425365975a47ee392f39101b4d97576877eddb809623cad1c87801306ab7738c73a96f67adc078177a14a3a8c588dcf0ad11101ac29d81ad7c6958eca1ddfe0eae415d7ed3d27e5a9918c61d09c68dd0d493a773be5a7ec02c7424195c0f8046703e2baf71a4e731bddef65520766300900dac7f2f791675a43a909b674b9e8e99ac8e3d8939eb457a415ed2e94314d9097d96793840ef0d5d58bf34bca148b14caa279f6897dfa499d7703491e748df1457ccbd1f956a33bde19f790e3ea6553c95550e2df683d994e2a550d45e95d560e8937a5663c1e49ee5ded30217a60180569afe39983b2362756facc7f88fd3b1005f27f3ae1e709809d9e3bad911c52ef2f7b2c83ff256b2c09a56bc5dbd6314633086272316939de8dc30ea3b17eb1f5a6c848ad9491b1045aa0a9bc00f81f943b8bb7ef73df3d3affa5c88be201e6d3f24c4204e7ed8b09422326be9afbd0e6b449c82542e6ddc98e29225c034854b60ad9e90c49984096abc7ffa4987bdf1db9ba8fef0f0f98018b717801044d432bb2fc9c9366d04587b6a49ca4589b770bba73ff0ef2b919648c48baeb0ba3ebe6922d934458239f0bfe1de7be8357320ecf2d308ca58b8f0ae3757e92c510c449e686902d2341abe81cf42f2edd2d18b44378e50612231104de392ef28fe9906a9ac761106de4199628807f09154a0a7730bed019d7bb3187479866bdfef258b51d357ddff92274124b5552712634d1942d2a0f199ef0be8b99fe0824da581ec4f59b881b963cb56990d9b3525a656cc20e860555a032a3d57c2b8c169e5d144a3067e2a1e6b2ab8f024646be1d305f12354baa4d3e1638f5129cce60f90bb09fe0babfac9a67062dc5484981d63d10a16f81d048a7c8f0dd9021b8ca4bf6e21121d9169c69fd81b045489340d3fc4d6224890aee1b0f322bc714fcc0b892dfed5c46ccd8efaf75a709dd19191bea96edd72a32e3b231c8f3d074932f57385d18803e2fa7218f1b5e385fa0a9995b160d6cae525838c22072b812c1b6bf4af5e1a03785f37114ea866b8c05890d0f7c88298ff6b464679d9849ce9d8d4af6ae0a6318b287c5634a88084878eb377d78db883cbee32cc3327653ef771cb5206a532fa80f43e259f7007628e014393e15bd39459feb792fd6091e100b054c0a7a2fcabe0816b1df96ce80ba1a15c3332861fedadeec58e619d1703a9c950904c626787d3ade6a02135f5277f5bc9759b3b352b7aec20ef49f9836ddff1faca4232f58a2f6b5c9f3b874eed5299b8f8c7f315d1438682372f033833dc4d1ce9cca5e50fee1e4da0c8a11f1d633c42ca77ef0ed09ab61e3eacf05e224e167209a3f2893f4c7db0fa3cd5da0e1125b97b572662d7db72c395c7c2dfe3c9f2d261f5d94ef732ba5ceec2833b6bea227eac7ca48a2919eaa037782162c03609178a45f49a163f61401f190dabe24a7992af84436c7db88bdca753a59b2d6f47cd8122679954087f7bbab10686bcfe21199f3ec58d2d8f9c6cffb5fa8fe724d40baa257d6c0dcde239fd14ac14e854ace5494d68a10df7e3035ed67c91d29a85b49c79ce59f64e4bdc5d2260785ca2ac7d2ae15f25c19a9bf4e1c8bf09ad5205cd858397ccff0e9e6a5a86a8090cf97d7dd3f35b96ce6577d000bd725e00feb83fc6367b7e5fce922bd8fbf377b5ff8ea41951f5219be89409386fda0cda3cd33e029c289325e34c13f48f9fdeaec603f30f00fa09f1bcf31ae7e6fafd4fdc1b2512675b461ad07838a67fd4fc25fda387bc999b98aec92ae6a3b1bb736a10fe5521a822e5eb4816d471f89af73b63e4bff88341bf1bc830c0510eabc02f40521bd2929d571f8f8e5f90015111c763ac46855a4d40b1d373ff7930ff935c4d059569d8e8c6e89d319269992f1e1278563dc1b897bbe6c48fec2151d98d20db8ec6a4c042c50718f275373a5d8ab7ba6574cf4f7ea1c340da1015e09a8e4413e5feca0212c5ea558c3bfbe85e313da7c69817363230e5812b1a4d125aab9da7c15cd10c072cd079c513415a74bb9bbb950066cdf550a30fb42550968deffc669c8c89c1a462c81fb163a9f66838a25d9ff5ba53117705b7d1e9c38f5123e1075e3cb07dc704bae050099a62be4f23e992970505d3811bec3bec3a82c50cc47cf009d513fc18002cb5b2fdba14baccfe161f6dca32aaf6ab3c70c86e1026ad9684425790fff82357b2c589941d5195c6e7451a7135b0821cc78325758fbcc97409222685747a6aff153a4497975276b6563e0b0821f690c8bd1ba4ebae92747064a46575f123a1ffdae4ebc17e2f41e717836f78e4a010d538d60b17184b07470b4a864362645e24b24b1bd2b0245b6a131b72d44aac5033147531fa548c0548f3f9731423d0ff7ad74f2b45169edb47ba0391a4c7d348e4198ce3c355ab9b4f4ef7c1d6ab10cc1e59b4405d06ceabe41cebef2169fe88473fd6f715ec111e0ab8c456fe52e8333b969094958f942b9745b609e0473d482544308a633b5c48e18bd3e24314134655d36f1864a22f45502fd4e08d4f114468a907d7bf34cacd28bcd208246b52152268a5a735ce70ef1cf6b7a0a666258c59dd4a0c28285a396ac02de1305d2e9d64326b15165a3d930fe9747bdae015285ffd6a333745589ce4c694ab51eca104925ab9786005650262981b30e527189acf9a2c5c3a47c5e8875719228dcdf0763bfc2121fb6954bd24a45a7dcbfb14f3b4c79414891b594058935672f09f8d72080d7474f3a3e14b653461d33fbc3063631fb6a41670b67fa281cc4af82ed4f881b11aca6eda73dce169a8679b6c8dbad4bdc5a3961a56e6d0aa30de086d14b5518a06d56bf87456f3e5a81df7a7277e99e00930906c8045860b2c1c26359b20650c15368e1ba98d267ef3d99a342e03089acca46f08b6676da7aed92b48b0d1ff5cef2f8784a7d4857c57e4ff661ee190df6d02e2025aeab382227954022c67a4e147636f3fb44d2e2934f46368d27ef3486f84fc38f96dab71208a4a9595a7f5c412ef968d587093bfc04fdf25f6e09c0657de540c0d6a706b04a94d19e0539c32fdbe9ae0665f432529def158ab17f8d70946e90cdcc272e334aeab5b63ff7a99091b9cf272403a955ff9415cac77fe57359feda2b676860f8aa3cc2703408be5d32611a3007a0ec09807bd55a98e41e4c2f67d5a4388d48d47bd6c95b84a1ba581bb7c4837dbf13338bb5ca76b5a13f997125dc69f60ed083191092ab7f5eeac0425165390784bbb89fce16de2f5fc291b1dbf088e02a6f20a57ecf311e378549e7d58283622132992b03a09ebb2e908090b91aeb599932679574fa4a9bfcc10a0e73a0f948af64cbcfa10041f3b753654b230a01eea973bcdcfbfa386be2ea389fe2bbd22c27b3b997bb4f3af45faba69503df630593e352ebaac88818bcc16a959b447d6a660a83f4726e48a9d0fc0db2c66e0ef7c95b17e8db4df6a6792479f4d4679d4a07ee0f2b031b9b379303236769b800cb14d7cdb5f60b6e08cb55549285a5932677e734fd742894a9708a988ea4f4536bb992d924f3bb37700a47eff5d042f6b1cfc50e93a4bb17cb54ea0dee4bd75930e2bff5446f6942a4a638ec7ae02dece139ff78af796f17b9e4e84f08aea6aade8c1d77b7473c5d8b1a4d621ed6294ea0d332b95ebe476bc090fcfcf91ab627113b3e8cfb61aac5e8481208e4fb4290f7a343823fbc4d3fc24b106d306c5a260f317a2339fa906e097fa36d7a4223c50f0df80fa821d538b9248d559a934bb1ce98c54482d6b5e5a21050eb3fc9c68c5db8614f77ca14a6442da7817f6c58f525ebfa779b79f53d3e1ee8c4daf2ed6500b106fc8342feadad4e8322d333c1fe7e885cb8e880efe96897d4239500477c80f4e523e36e2f06172becb8c2a95768d6c50a7024a7d0bcb8c4c787a6f98283b32082c031f3ac4ccc05380cfa91e45bf55979ab6fc9e94e319873764bdec6f13b023115462c8ad18fe3e6d5645104fd8d1c04edf293961fa4fe9c28aa2b68330c61c6153f255985da401d99b7b0df1d1e69e020d576297507ae2a81ac3cf677841e16100b412c1f0bbbbcf55f06273637dddb3c273c3f1f9ab51934a79449e8d59d61a96ec55b0d03705e2ad511914527d4fa0d2bc3cef5c839c4f0b88dc9b4b8d19eb0a07466671960170be612608f6138438b29c9ca2e4c552b67aeb25c2e20f8c9b67576fbc2cfaa087419fac953e869a62c1b31e2c7b5de8f1a28cc5c8a1fe600ec20a7d48efe5d0b147aaf3673237a89326034977f6d58036d8b6d5c022d9c0e09c56b1289b2b85b8650c4c3280c30e0d9dc95e96cf328a36fdfb636fb3c4d9d211e63c93c9875810738d49b488dc3567db0c2762f763d7d3e20a6bb266e77b47ba408d5ac187d5f83d3bda27bd9df8f14b18022cf69ff9484f0ebf84d6f20747d41bb81c9a509c321d56b6042b5b5ed09c8c8c73602300c0a55b82eb840c1e52109c583e180b544f870780cf5a8599ef44e93820493e15bcbda36bb8d6c63dec62eb0bb97a8d968cef312e7bdd797d6f0a36d0efb7cb48d40faab9983f68976dca6d04ac5e7c8b6289df790540f3967b198a80a859eb8e865eaa15d0014e3d31ede81d8a6fd91ea18cbd8847d680cdfc8f6787606dfbd10aa8de8a79ceb02d886395ba3676d6c303397915e486c2994a90477ef084f0915d8ef91529e9bc1b531eedb97507930bbc5c81329a855330e8411a2b9d20467eb0bd58727d0faee96e9e415b87cb68333d8f12a9df1aa6dc6b5c13e3efb1f8fefeda224f4ea075a4497475584d386cb5f970befe0c18bf0e8164ebec9308485ed60713a6979cd3dff294241f01b30ac24c3cc00acf175593411fe329ae4e6e704335a133f452aceddb73357c74f1602ab192fc16b3d21af2db5169b35b99bee60dc8c269aaa4a83e54e909408f703f85b3bf05763fc4e9e851e6a49c687471a2bea00f08eaed9ff9c93220c628e59960ca6e714f020aae0b45bb9e31f6af97c5a64d59506dce235516d03f7289d4a1b5542dba9b677ce1dafdf7336743532240f1d37f37da5fbbd9d73a8643192d9d47ce14ec416beb8349856003ea629400b6b45c5b7d0425ba12345fdd1f87cb46da289a4b5109cb57a6d20e3ffce6fbcd3a71303a2a04d172aa2d45e65a5845af9d1ee62a840265cb979056c138e198a3ea56cfa4497e00c984f17815e641fa444c4948c5d9e310393966ff3a84b8a4b478dbecc1d1435422343b8e0fc319d6beb527c81517b291c8a2775658675f96f0dd2053d20193fa845ecfdb19d1f67a9c8a008110e0f0b07811863238d302857445e53fc9d98b426d5a37cd286d317e4e7f8484bb47e0f7c202fb221612e793b1074dfce8ff30ce017b85e36c5a989a49879e2b999d6afa222b5eed3b4432052e991dd97bb2e1ed60a63feee9506c43408f961e9d3528b70b00283361e846bc9cad4fdfd471ac8aeff7f26811c4222fb5ce4e606a3f8ea8e32bb613d7422fe7e3cd19f0e187c5773478a5cf1cd3b7243d883aa46607f562371ed89740ccf865f12f241fdea7b618a70bfae88584d7c0090297d6daca7f1c1a655e6691299e189fa9a93830751","isRememberEnabled":true,"rememberDurationInDays":0,"salt":"e71e4e78cbcc4c36c423ee621b9dd43d"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: 'staticrypt_expiration',
        rememberPassphraseKey: 'staticrypt_passphrase',
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("hidden");
            document.getElementById("staticrypt_content").classList.remove("hidden");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById('staticrypt-remember-label').classList.remove('hidden');
            }
        }
    }

    // handle password form submission
    document.getElementById('staticrypt-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const password = document.getElementById('staticrypt-password').value,
            isRememberChecked = document.getElementById('staticrypt-remember').checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>
</body>
</html>
